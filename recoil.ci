// recoil.ci - RECOIL core
//
// Copyright (C) 2009-2021  Piotr Fusik
//
// This file is part of RECOIL (Retro Computer Image Library),
// see http://recoil.sourceforge.net
//
// RECOIL is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published
// by the Free Software Foundation; either version 2 of the License,
// or (at your option) any later version.
//
// RECOIL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with RECOIL; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

// The following conventions are used in this file:
// Exceptions are not used.
// Errors are signalled by returning false, -1 or null.
// Called methods precede the calling methods.
// Simple code (e.g. uncompressed black&white images)
// precedes the more complicated.
// Each format is decoded by a method with a signature like:
// bool DecodeXxx!(byte[] content, int contentLength)
// where `Xxx` is the filename extension and `true` is returned
// on successful decoding.  `content` is read-only.
// In rare occassions there are extra parameters such as the filename.
// Decoding methods are grouped by the platform.
// The order of platforms is such that simple code comes first.
// New formats must be added in `IsOurFile`, `Decode` and `formats.xml`.
// Invalid files shouldn't result in a buffer overflow
// (always check `contentLength` first!), divide by zero or endless loop.
// Code must be tested, because format documentation is often incorrect.
// Test C, Java (Android), C# (Windows 10 or Paint.NET) and JavaScript.
// Prefer concise, readable code over microoptimizations.
// Prefer stack allocations over heap, but make sure no more than ~200 kB
// is used at a time, otherwise 32-bit Windows Explorer will crash.
// Don't introduce variables for return values and loop control
// if `return` and `break` statements are more concise.
// Minimize the scope of variables. Use `byte` only for arrays.
// Braces on new line for enums, classes and methods, inline for code blocks.
// Avoid unneeded parentheses.
// Use tabs, but only for indentation (i.e. at line beginnings).
// Align long `if` conditions like this:
// if (foo
//  || bar
//  || quux)
// (this is the only exception to tab indentation).

/// Platform and pixel ratio.
enum RECOILResolution
{
	Amiga1x1,
	Amiga2x1,
	Amiga4x1,
	Amiga8x1,
	Amiga1x2,
	Amiga1x4,
	AmigaDctv1x1,
	AmigaDctv1x2,
	AmigaHame1x1,
	AmigaHame2x1,
	Amstrad1x1,
	Amstrad2x1,
	Amstrad1x2,
	AppleII1x1,
	AppleIIe1x2,
	AppleIIGS1x1,
	AppleIIGS1x2,
	Macintosh1x1,
	Xe1x1,
	Xe2x1,
	Xe4x1,
	Xe2x2,
	Xe4x2,
	Xe4x4,
	Xe8x8,
	Vbxe1x1,
	Vbxe2x1,
	Portfolio1x1,
	St1x1,
	St1x2,
	Ste1x1,
	Ste1x2,
	Tt1x1,
	Tt2x1,
	Falcon1x1,
	Falcon2x1,
	Bbc1x1,
	Bbc2x1,
	Bbc1x2,
	Vic202x1,
	C161x1,
	C162x1,
	C641x1,
	C642x1,
	C1281x1,
	Electronika1x1,
	FmTowns1x1,
	Msx11x1,
	Msx14x4,
	Msx21x1,
	Msx21x2,
	Msx21x1i,
	Msx22x1i,
	Msx2Plus1x1,
	Msx2Plus2x1i,
	MsxV99901x1,
	Oric1x1,
	Pc1x1,
	Pc801x2,
	Pc881x2,
	Pc88Va1x1,
	Pc981x1,
	PlayStation1x1,
	Psion31x1,
	SamCoupe1x1,
	SamCoupe1x2,
	X68K1x1,
	Tandy1x1,
	Spectrum1x1,
	Spectrum4x4,
	SpectrumUlaPlus1x1,
	ZxEvolution1x1,
	SpectrumNext1x1,
	Timex1x1,
	Timex1x2,
	Trs1x1,
	Trs1x2,
	Coco1x1,
	Coco2x2,
	Zx811x1
}

enum IffType
{
	Ilbm,
	Pbm,
	Acbm,
	Rgb8,
	Rgbn
}

enum IceFrameMode
{
	Gr0,
	Gr0Gtia9,
	Gr0Gtia10,
	Gr0Gtia11,
	Gr12,
	Gr12Gtia9,
	Gr12Gtia10,
	Gr12Gtia11,
	Gr13Gtia9,
	Gr13Gtia10,
	Gr13Gtia11
}

enum AnticMode
{
	Blank,
	FourColor,
	FiveColor,
	HiRes
}

/// Read-only stream backed by a byte array.
class Stream
{
	internal byte[] Content;
	internal int ContentOffset;
	internal int ContentLength;

	/// Returns the next byte or -1 on EOF.
	internal int ReadByte!()
	{
		if (ContentOffset >= ContentLength)
			return -1;
		return Content[ContentOffset++];
	}

	/// Advances the stream until after the first byte with the given value.
	/// Returns `false` on EOF.
	internal bool SkipUntilByte!(int expected)
	{
		for (;;) {
			int b = ReadByte();
			if (b < 0)
				return false;
			if (b == expected)
				return true;
		}
	}

	/// Reads `count` bytes to `dest` starting at `destOffset`.
	/// Returns `true` on success, `false` if not enough data.
	protected bool ReadBytes!(byte[]! dest, int destOffset, int count)
	{
		int nextOffset = ContentOffset + count;
		if (nextOffset > ContentLength)
			return false;
		Content.CopyTo(ContentOffset, dest, destOffset, count);
		ContentOffset = nextOffset;
		return true;
	}

	/// Reads a hexadecimal ASCII digit and returns its value.
	/// If there's no digit at the current stream position,
	/// leaves the position intact and returns -1.
	internal int ReadHexDigit!()
	{
		if (ContentOffset >= ContentLength)
			return -1;
		int c = Content[ContentOffset++];
		if (c >= '0' && c <= '9')
			return c - '0';
		if (c >= 'A' && c <= 'F')
			return c - ('A' - 10);
		if (c >= 'a' && c <= 'f')
			return c - ('a' - 10);
		ContentOffset--;
		return -1;
	}

	/// Reads an integer in range `0`..`maxValue`
	/// in base `b`.
	/// Returns -1 on error.
	protected int ParseInt!(int b, int maxValue)
	{
		int r = ReadHexDigit();
		if (r < 0 || r >= b)
			return -1;
		do {
			int d = ReadHexDigit();
			if (d < 0)
				return r;
			if (d >= b)
				return -1;
			r = r * b + d;
		} while (r <= maxValue);
		return -1;
	}

	/// Reads a decimal integer in range 0-32000
	/// stored as ASCII digits followed by CRLF.
	/// Returns -1 on error.
	internal int ParseDaliInt!()
	{
		int r = ParseInt(10, 32000);
		if (r < 0 || ReadByte() != '\r' || ReadByte() != '\n')
			return -1;
		return r;
	}
}

class GdosFntStream : Stream
{
	internal bool BigEndian;
	internal int BitmapWidth;
	internal int Width;
	internal int LeftX;
	internal int RightX;
	internal int NextX;

	/// Reads a 16-bit unsigned integer.
	/// Returns -1 on EOF.
	internal int ReadWord!()
	{
		if (ContentOffset + 1 >= ContentLength)
			return -1;
		int first = Content[ContentOffset];
		int second = Content[ContentOffset + 1];
		ContentOffset += 2;
		return BigEndian ? first << 8 | second : first | second << 8;
	}

	/// Reads a 32-bit integer assuming there's enough data.
	internal int ReadInt!()
	{
		int value = BigEndian
			? RECOIL.Get32BigEndian(Content, ContentOffset)
			: RECOIL.Get32LittleEndian(Content, ContentOffset);
		ContentOffset += 4;
		return value;
	}

	internal bool FitRow!()
	{
		LeftX = RightX;
		do {
			RightX = NextX;
			NextX = ReadWord();
			if (NextX < RightX)
				return NextX < 0;
			if (NextX > BitmapWidth) {
				// The character table contains a position that exceeds the bitmap.
				// Display only what we have in the bitmap.
				// Example file: CZEC18LS.FNT
				NextX = -1;
				return true;
			}
		} while (NextX - LeftX <= Width);
		return true;
	}
}

class DaliStream : Stream
{
	internal bool Decode!(int countLength, RECOIL! recoil, int paletteOffset, int mode)
	{
		byte[32000] unpacked;
		int valueOffset = ContentOffset + countLength - 4;
		int count = 1;
		for (int x = 0; x < 160; x += 4) {
			for (int unpackedOffset = x; unpackedOffset < 32000; unpackedOffset += 160) {
				if (--count <= 0) {
					if (valueOffset + 7 >= ContentLength)
						return false;
					count = Content[ContentOffset++];
					if (count == 0)
						return false;
					valueOffset += 4;
				}
				Content.CopyTo(valueOffset, unpacked, unpackedOffset, 4);
			}
		}
		return recoil.DecodeSt(unpacked, 0, Content, paletteOffset, mode, 0);
	}
}

class ZxpStream : Stream
{
	internal int ReadChar!()
	{
		int c = ReadByte();
		// ZXP is CRLF. We support LF just in case.
		if (c == '\r' && ContentOffset < ContentLength && Content[ContentOffset] == '\n') {
			ContentOffset++;
			return '\n';
		}
		return c;
	}

	internal bool IsEof() => ContentOffset >= ContentLength;
}

class SprStream : Stream
{
	const int Width = 320;
	const int Height = 200;

	/// Reads a decimal, hexadecimal (with `$` prefix)
	/// or binary (with `%` prefix) integer.
	/// Skips leading whitespace.
	/// Returns -1 on error.
	internal int ReadSprInt!()
	{
		while (ContentOffset < ContentLength) {
			int c = Content[ContentOffset];
			switch (c) {
			case ' ':
			case '\t':
			case '\r':
			case '\n':
				ContentOffset++;
				break;
			case '$':
				ContentOffset++;
				return ParseInt(16, Width - 1);
			case '%':
				ContentOffset++;
				return ParseInt(2, Width - 1);
			default:
				return ParseInt(10, Width - 1);
			}
		}
		return -1;
	}
}

class VplStream : Stream
{
	int[16] Palette;

	int SkipWhitespace!()
	{
		while (ContentOffset < ContentLength) {
			int b = Content[ContentOffset];
			switch (b) {
			case ' ':
			case '\t':
			case '\r':
				ContentOffset++;
				break;
			default:
				return b;
			}
		}
		return -1;
	}

	internal int Decode!()
	{
		int colors = 0;
		for (;;) {
			switch (SkipWhitespace()) {
			case -1:
				return colors;
			case '#':
			case '\n':
				SkipUntilByte('\n');
				break;
			default:
				if (colors >= Palette.Length)
					return -1;
				int r = ParseInt(16, 0xff);
				if (r < 0)
					return -1;
				SkipWhitespace();
				int g = ParseInt(16, 0xff);
				if (g < 0)
					return -1;
				SkipWhitespace();
				int b = ParseInt(16, 0xff);
				if (b < 0)
					return -1;
				SkipWhitespace();
				if (ParseInt(16, 0xf) < 0)
					return -1;
				Palette[colors++] = r << 16 | g << 8 | b;
				switch (SkipWhitespace()) {
				case -1:
					return colors;
				case '\n':
					ContentOffset++;
					break;
				default:
					return -1;
				}
				break;
			}
		}
	}

	internal void CopyTo(int[]! palette, int colors)
	{
		Palette.CopyTo(0, palette, 0, colors);
	}
}

/// Readable in-memory stream of bits, most-significant bit first.
class BitStream : Stream
{
	protected int Bits = 0; // 8 bits sliding left with a trailing 1

	/// Reads one bit (0 or 1).
	/// Returns -1 on end of stream.
	internal virtual int ReadBit!()
	{
		if ((Bits & 0x7f) == 0) {
			if (ContentOffset >= ContentLength)
				return -1;
			Bits = Content[ContentOffset++] << 1 | 1;
		}
		else
			Bits <<= 1;
		return Bits >> 8 & 1;
	}

	/// Reads the requested number of bits and returns them
	/// as an unsigned integer with the first bit read as the most significant.
	/// Returns -1 on end of stream.
	internal int ReadBits!(int count)
	{
		int result = 0;
		while (--count >= 0) {
			int bit = ReadBit();
			if (bit < 0)
				return -1;
			result = result << 1 | bit;
		}
		return result;
	}

	protected int ReadNl3Char!(bool skipSpace)
	{
		int e;
		do
			e = ReadByte();
		while (e == '\r' || e == '\n' || (skipSpace && e == ' '));
		if (e != 0xef)
			return e;
		// UTF-8
		if (ContentOffset + 1 >= ContentLength)
			return -1;
		switch (Content[ContentOffset++]) {
		case 0xbd:
			e = Content[ContentOffset++];
			if (e >= 0xa0 && e <= 0xbf)
				return e;
			break;
		case 0xbe:
			e = Content[ContentOffset++];
			if (e >= 0x80 && e <= 0x9f)
				return e + (0xc0 - 0x80);
			break;
		default:
			break;
		}
		return -1;
	}
}

class X68KPicStream : BitStream
{
	internal int ReadLength!()
	{
		for (int bits = 1; bits < 21; bits++) {
			switch (ReadBit()) {
			case 0:
				int length = ReadBits(bits);
				if (length < 0)
					return -1;
				return length + (1 << bits) - 1;
			case 1:
				break;
			default:
				return -1;
			}
		}
		return -1;
	}
}

class Mx1Stream : X68KPicStream
{
	byte[256] DecodeTable;

	internal Mx1Stream()
	{
		int d = 0;
		for (int e = 0; e < 256; e++) {
			if ((e >= '!' && e <= '~' && e != '"' && e != '\'' && e != ',' && e != '@' && e != '\\' && e != '`') || (e >= 0xa1 && e <= 0xc8))
				DecodeTable[e] = d++;
			else
				DecodeTable[e] = 128;
		}
	}

	internal bool FindImage!()
	{
		for (;;) {
			int lineOffset = ContentOffset;
			for (;;) {
				int c = ReadByte();
				if (c < 0)
					return false;
				if (c == '\r' || c == '\n')
					break;
			}
			if (ContentOffset - lineOffset >= "@@@ (1lines) @@@\n".Length
				&& RECOIL.IsStringAt(Content, lineOffset, "@@@ ")
				&& RECOIL.IsStringAt(Content, ContentOffset - "lines) @@@\n".Length, "lines) @@@")) {
				Bits = 0;
				return true;
			}
		}
	}

	internal override int ReadBit!()
	{
		if ((Bits & 0x3f) == 0) {
			int e = ReadNl3Char(true);
			if (e < 0)
				return -1;
			int d = DecodeTable[e];
			if (d >= 128)
				return -1;
			Bits = d << 1 | 1;
		}
		else
			Bits <<= 1;
		return Bits >> 7 & 1;
	}
}

class MppPaletteStream : BitStream
{
	internal int Read!()
	{
		int rgb;
		switch (Content[4] & 3) {
		case 0:
			// ST 512 colors
			rgb = ReadBits(9);
			// RRRGGGBBB -> 00000RRR00000GGG00000BBB
			rgb = (rgb & 0x1c0) << 10
				| (rgb & 0x38) << 5
				| (rgb & 7);
			return rgb << 5 | rgb << 2 | (rgb >> 1 & 0x030303);
		case 1:
			// STE 4096 colors
			rgb = ReadBits(12);
			// rRRRgGGGbBBB -> 0000RRRr0000GGGg0000BBBb
			rgb = (rgb & 0x700) << 9 | (rgb & 0x870) << 5
				| (rgb & 0x87) << 1 | (rgb & 8) >> 3;
			return rgb << 4 | rgb;
		case 3:
			// STE 29791 colors
			return RECOIL.GetSteInterlacedColor(ReadBits(15));
		default:
			// unreachable
			return 0;
		}
	}
}

abstract class MultiPalette : BitStream
{
	internal abstract void SetLinePalette!(RECOIL! recoil, int y);
}

class ArtPalette : MultiPalette
{
	internal override void SetLinePalette!(RECOIL! recoil, int y)
	{
		if ((y & 1) == 0)
			recoil.SetStPalette(Content, 0x8000 + (y << 4), 16);
	}
}

class RastPalette : MultiPalette
{
	internal int Colors;

	internal override void SetLinePalette!(RECOIL! recoil, int y)
	{
		int paletteLength = (1 + Colors) << 1;
		// not sorted by Y!
		for (int offset = ContentOffset; offset <= ContentLength - paletteLength; offset += paletteLength) {
			if (y == (Content[offset] << 8 | Content[offset + 1])) {
				recoil.SetStPalette(Content, offset + 2, Colors);
				break;
			}
		}
	}
}

class HblPalette : MultiPalette
{
	bool HasPalette(int row)
		=> Content[row << 1] != 0xff || Content[row << 1 | 1] != 0xff;

	internal bool Init!()
	{
		if (!HasPalette(0))
			return false;
		ContentOffset = 896;
		for (int row = 1; row < 50; row++) {
			if (HasPalette(row))
				ContentOffset += 48;
		}
		return ContentOffset <= ContentLength;
	}

	internal override void SetLinePalette!(RECOIL! recoil, int y)
	{
		if ((y & 3) == 0 && HasPalette(y >> 2)) {
			ContentOffset -= 48;
			int bitplanes = recoil.GetWidth() == 320 || y == 0 ? 4 : 2;
			for (int c = 0; c < 1 << bitplanes; c++) {
				int offset = ContentOffset + c * 3;
				int rgb = (Content[offset] << 16 | Content[offset + 1] << 8 | Content[offset + 2]) & 0x070707;
				recoil.SetStVdiColor(c, rgb << 5 | rgb << 2 | (rgb >> 1 & 0x030303), bitplanes);
			}
		}
	}
}

class CtblPalette : MultiPalette
{
	internal int Colors;

	internal override void SetLinePalette!(RECOIL! recoil, int y)
	{
		recoil.SetOcsPalette(Content, ContentOffset + (y * Colors << 1), Colors);
	}
}

class ShamLacePalette : MultiPalette
{
	internal override void SetLinePalette!(RECOIL! recoil, int y)
	{
		recoil.SetOcsPalette(Content, ContentOffset + (y >> 1 << 5), 16);
	}
}

class PchgPalette : MultiPalette
{
	bool Ocs;
	int StartLine;
	int LineCount;
	byte[]# HavePaletteChange;
	int TreeOffset;
	int TreeLastOffset;
	bool Compressed;

	int ReadHuffman!()
	{
		int offset = TreeLastOffset;
		for (;;) {
			switch (ReadBit()) {
			case 0:
				offset -= 2;
				if (offset < TreeOffset)
					return -1;
				if ((Content[offset] & 0x81) == 1)
					return Content[offset + 1];
				break;
			case 1:
				int hi = Content[offset];
				int lo = Content[offset + 1];
				if (hi < 0x80)
					return lo;
				offset += (hi - 0x100) << 8 | lo;
				if (offset < TreeOffset)
					return -1;
				break;
			default:
				return -1;
			}
		}
	}

	internal bool Init!()
	{
		if (ContentOffset + 20 > ContentLength || Content[ContentOffset] != 0)
			return false;
		switch (Content[ContentOffset + 3] & 3) {
		case 1:
			Ocs = true;
			break;
		case 2:
			Ocs = false;
			break;
		default:
			return false;
		}
		StartLine = Content[ContentOffset + 4] << 8 | Content[ContentOffset + 5];
		LineCount = Content[ContentOffset + 6] << 8 | Content[ContentOffset + 7];
		int havePaletteChangeLength = LineCount + 31 >> 5 << 2;
		HavePaletteChange = new byte[havePaletteChangeLength];

		switch (Content[ContentOffset + 1]) {
		case 0:
			ContentOffset += 20;
			if (!ReadBytes(HavePaletteChange, 0, havePaletteChangeLength))
				return false;
			Compressed = false;
			break;
		case 1:
			TreeOffset = ContentOffset + 28;
			if (TreeOffset > ContentLength)
				return false;
			int treeLength = RECOIL.Get32BigEndian(Content, ContentOffset + 20);
			if (treeLength < 2 || treeLength > 1022)
				return false;
			ContentOffset = TreeOffset + treeLength;
			TreeLastOffset = ContentOffset - 2;
			for (int i = 0; i < havePaletteChangeLength; i++) {
				int b = ReadHuffman();
				if (b < 0)
					return false;
				HavePaletteChange[i] = b;
			}
			Compressed = true;
			break;
		default:
			return false;
		}
		return true;
	}

	int UnpackByte!()
	{
		return Compressed ? ReadHuffman() : ReadByte();
	}

	void SetOcsColors!(RECOIL! recoil, int paletteOffset, int count)
	{
		while (--count >= 0) {
			int rr = UnpackByte();
			if (rr < 0)
				return; // error
			int gb = UnpackByte();
			if (gb < 0)
				return; // error
			recoil.SetOcsColor(paletteOffset + (rr >> 4), rr, gb);
		}
	}

	internal override void SetLinePalette!(RECOIL! recoil, int y)
	{
		y -= StartLine;
		if (y < 0 || y >= LineCount)
			return;
		if ((HavePaletteChange[y >> 3] >> (~y & 7) & 1) == 0)
			return;
		int count = UnpackByte();
		if (count < 0)
			return; // error
		int count2 = UnpackByte();
		if (count2 < 0)
			return; // error
		if (Ocs) {
			SetOcsColors(recoil, 0, count);
			SetOcsColors(recoil, 16, count2);
		}
		else {
			count = count << 8 | count2;
			while (--count >= 0) {
				if (UnpackByte() != 0)
					return; // error
				int c = UnpackByte();
				if (c < 0 || UnpackByte() < 0)
					return; // error
				int r = UnpackByte();
				if (r < 0)
					return; // error
				int b = UnpackByte();
				if (b < 0)
					return; // error
				int g = UnpackByte();
				if (g < 0)
					return; // error;
				recoil.ContentPalette[c] = r << 16 | g << 8 | b;
			}
		}
	}
}

/// Readable in-memory Run-Length-Encoded stream.
/// This class contains the compression logic.
/// Subclasses must implement `ReadCommand()`
/// and are allowed to override `ReadValue()`.
abstract class RleStream : BitStream
{
	/// Block length.
	internal int RepeatCount = 0;

	/// Value for an RLE block, -1 for a block of literals.
	protected int RepeatValue;

	/// Decodes a block from the stream.
	/// Fills `RepeatCount` with the length of the block.
	/// Sets `RepeatValue` to the RLE value
	/// or -1 if the block consists of `RepeatCount` literals.
	/// Returns `false` on end of stream.
	protected abstract bool ReadCommand!();

	internal virtual int ReadValue!() => ReadByte();

	/// Returns the next uncompressed byte or -1 on error.
	internal int ReadRle!()
	{
		while (RepeatCount == 0) {
			if (!ReadCommand())
				return -1;
		}
		RepeatCount--;
		if (RepeatValue >= 0)
			return RepeatValue;
		return ReadValue();
	}

	/// Uncompresses bytes to `unpacked[unpackedOffset]`,
	/// `unpacked[unpackedOffset + unpackedStride]`,
	/// `unpacked[unpackedOffset + 2 * unpackedStride]`,
	/// ... as long as indexes are smaller than `unpackedEnd`.
	/// Returns `true` on success, `false` on error.
	internal bool Unpack!(byte[]! unpacked, int unpackedOffset, int unpackedStride, int unpackedEnd)
	{
		for (; unpackedOffset < unpackedEnd; unpackedOffset += unpackedStride) {
			int b = ReadRle();
			if (b < 0)
				return false;
			unpacked[unpackedOffset] = b;
		}
		return true;
	}

	/// Uncompresses laiding out bytes vertically column by column,
	/// `unpackedStride` being line width.
	/// Returns `true` on success, `false` on error.
	internal bool UnpackColumns!(byte[]! unpacked, int unpackedOffset, int unpackedStride, int unpackedEnd)
	{
		for (int x = 0; x < unpackedStride; x++) {
			if (!Unpack(unpacked, unpackedOffset + x, unpackedStride, unpackedEnd))
				return false;
		}
		return true;
	}

	/// Uncompresses bytes to `unpacked[unpackedOffset]`, `unpacked[unpackedOffset + 1]`,
	/// `unpacked[unpackedOffset + unpackedStride]`, `unpacked[unpackedOffset + unpackedStride + 1]`,
	/// `unpacked[unpackedOffset + 2 * unpackedStride]`, `unpacked[unpackedOffset + 2 * unpackedStride + 1]`,
	/// ... as long as indexes are smaller than `unpackedEnd`.
	/// Returns `true` on success, `false` on error.
	internal bool UnpackWords!(byte[]! unpacked, int unpackedOffset, int unpackedStride, int unpackedEnd)
	{
		for (; unpackedOffset < unpackedEnd; unpackedOffset += unpackedStride) {
			int b = ReadRle();
			if (b < 0)
				return false;
			unpacked[unpackedOffset] = b;
			b = ReadRle();
			if (b < 0)
				return false;
			unpacked[unpackedOffset + 1] = b;
		}
		return true;
	}

	/// Uncompresses after copying two literal bytes.
	/// Returns `true` on success, `false` on error.
	internal bool UnpackC64!(byte[]! unpacked, int unpackedLength)
	{
		unpacked[0] = Content[0];
		unpacked[1] = Content[1];
		return Unpack(unpacked, 2, 1, unpackedLength);
	}
}

class BldStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		RepeatValue = b;
		if (b == 0 || b == 0xff) {
			b = ReadByte();
			if (b < 0)
				return false;
			RepeatCount = b + 1;
		}
		else
			RepeatCount = 1;
		return true;
	}
}

class DaVinciStream : RleStream
{
	internal override int ReadValue!()
	{
		if (ContentOffset + 3 > ContentLength)
			return -1;
		ContentOffset += 3;
		return Content[ContentOffset - 2] << 16 | Content[ContentOffset - 1] << 8 | Content[ContentOffset - 3];
	}

	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b >= 128) {
			RepeatValue = ReadValue();
			b &= 0x7f;
		}
		else
			RepeatValue = -1;
		RepeatCount = b;
		return true;
	}
}

class BbgStream : RleStream
{
	internal int ValueBits;
	internal int CountBits;

	/// Reads the requested number of bits and returns them
	/// as an unsigned integer with the first bit read as the least significant.
	/// Returns -1 on end of stream.
	internal int ReadBitsReverse!(int count)
	{
		int result = 0;
		for (int i = 0; i < count; i++) {
			switch (ReadBit()) {
			case 0:
				break;
			case 1:
				result |= 1 << i;
				break;
			default:
				return -1;
			}
		}
		return result;
	}

	protected override bool ReadCommand!()
	{
		switch (ReadBit()) {
		case 0:
			RepeatCount = 1;
			break;
		case 1:
			RepeatCount = ReadBitsReverse(CountBits);
			if (RepeatCount <= 0)
				return false;
			break;
		default:
			return false;
		}
		RepeatValue = ReadBitsReverse(ValueBits);
		return true;
	}
}

class MspStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b == 0) {
			RepeatCount = ReadByte();
			RepeatValue = ReadByte();
		}
		else {
			RepeatCount = b;
			RepeatValue = -1;
		}
		return true;
	}
}

class C64KoalaStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b == 0xfe) {
			RepeatValue = ReadByte();
			RepeatCount = ReadByte();
		}
		else {
			RepeatValue = b;
			RepeatCount = 1;
		}
		return true;
	}
}

class GoDotStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b == 0xad) {
			RepeatCount = ReadByte();
			if (RepeatCount == 0)
				RepeatCount = 256;
			RepeatValue = ReadByte();
		}
		else {
			RepeatCount = 1;
			RepeatValue = b;
		}
		return true;
	}
}

class CmpStream : RleStream
{
	internal int Escape;

	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b == Escape) {
			b = ReadByte();
			if (b < 0)
				return false;
			RepeatCount = 1 + b;
			RepeatValue = ReadByte();
		}
		else {
			RepeatCount = 1;
			RepeatValue = b;
		}
		return true;
	}
}

class DrpStream : RleStream
{
	internal int Escape;

	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b == Escape) {
			RepeatCount = ReadByte();
			RepeatValue = ReadByte();
		}
		else {
			RepeatCount = 1;
			RepeatValue = b;
		}
		return true;
	}

	internal static byte[] UnpackFile(byte[] content, int contentLength, string signature, byte[]! unpacked, int unpackedLength)
	{
		if (contentLength > 16 && RECOIL.IsStringAt(content, 2, signature)) {
			DrpStream() rle;
			rle.Content = content;
			rle.ContentOffset = 16;
			rle.ContentLength = contentLength;
			rle.Escape = content[15];
			if (!rle.UnpackC64(unpacked, unpackedLength))
				return null;
			return unpacked;
		}
		if (contentLength != unpackedLength)
			return null;
		return content;
	}
}

class HpmStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b == 0) {
			RepeatValue = ReadByte();
			RepeatCount = ReadByte();
		}
		else {
			RepeatCount = b;
			RepeatValue = -1;
		}
		return true;
	}
}

class PgcStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			RepeatCount = b;
			RepeatValue = -1;
		}
		else {
			RepeatCount = b - 128;
			RepeatValue = ReadByte();
		}
		return true;
	}
}

class ScStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			RepeatCount = b;
			RepeatValue = ReadByte();
		}
		else {
			RepeatCount = b - 128;
			RepeatValue = -1;
		}
		return true;
	}
}

class CciStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			RepeatCount = b + 1;
			RepeatValue = -1;
		}
		else {
			RepeatCount = b - 127;
			RepeatValue = ReadByte();
		}
		return true;
	}

	internal bool UnpackGr15!(byte[]! unpacked, int unpackedOffset)
	{
		ContentOffset += 4;
		RepeatCount = 0;
		for (int x = 0; x < 40; x++) {
			if (!Unpack(unpacked, unpackedOffset + x, 80, 7680))
				return false;
		}
		return true;
	}
}

class PackBitsStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			RepeatCount = b + 1;
			RepeatValue = -1;
		}
		else {
			RepeatCount = 257 - b;
			RepeatValue = ReadValue();
		}
		return true;
	}

	internal bool UnpackBitplaneLines!(byte[]! unpacked, int width, int height, int bitplanes, bool compressed, bool hasMask)
	{
		int bytesPerBitplane = width + 15 >> 4 << 1;
		int bytesPerLine = bitplanes * bytesPerBitplane;
		for (int y = 0; y < height; y++) {
			// reorder bitplane lines to bitplane words
			for (int bitplane = 0; bitplane < bitplanes; bitplane++) {
				for (int w = bitplane << 1; w < bytesPerLine; w += bitplanes << 1) {
					for (int x = 0; x < 2; x++) {
						int b = compressed ? ReadRle() : ReadByte();
						if (b < 0)
							return false;
						unpacked[y * bytesPerLine + w + x] = b;
					}
				}
			}
			if (hasMask) {
				// ignore transparency mask
				for (int x = 0; x < bytesPerBitplane; x++) {
					int b = compressed ? ReadRle() : ReadByte();
					if (b < 0)
						return false;
				}
			}
		}
		return true;
	}
}

class SpcStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			RepeatCount = b + 1;
			RepeatValue = -1;
		}
		else {
			RepeatCount = 258 - b;
			RepeatValue = ReadByte();
		}
		return true;
	}
}

class SpsStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			RepeatCount = b + 3;
			RepeatValue = ReadByte();
		}
		else {
			RepeatCount = b - 127;
			RepeatValue = -1;
		}
		return true;
	}
}

class ArtMaster88Stream : RleStream
{
	int Escape = -1;

	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b == Escape) {
			b = ReadByte();
			if (b < 0)
				return false;
			RepeatCount = b - 1 & 0xff;
			Escape = -1;
		}
		else {
			RepeatCount = 1;
			Escape = RepeatValue = b;
		}
		return true;
	}

	internal bool SkipChunk!()
	{
		if (ContentOffset + 1 >= ContentLength)
			return false;
		int length = Content[ContentOffset] | Content[ContentOffset + 1] << 8;
		if (length < 2)
			return false;
		ContentOffset += length;
		return true;
	}

	internal byte[4][32000] Planes;

	internal bool ReadPlanes!(int planes, int planeLength)
	{
		for (int plane = 0; plane < planes; plane++) {
			if (!Unpack(Planes[plane], 0, 1, planeLength))
				return false;
		}
		return true;
	}
}

class SrStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		switch (b) {
		case -1:
			return false;
		case 0:
			RepeatCount = ReadByte();
			if (RepeatCount == 0)
				RepeatCount = 256;
			RepeatValue = ReadByte();
			return true;
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
		case 14:
		case 15:
			RepeatCount = b;
			RepeatValue = ReadByte();
			return true;
		default:
			RepeatCount = 1;
			RepeatValue = b;
			return true;
		}
	}
}

class PacStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b == Content[4]) {
			b = ReadByte();
			if (b < 0)
				return false;
			RepeatCount = b + 1;
			RepeatValue = Content[5];
		}
		else if (b == Content[6]) {
			RepeatValue = ReadByte();
			if (RepeatValue < 0)
				return false;
			b = ReadByte();
			if (b < 0)
				return false;
			RepeatCount = b + 1;
		}
		else {
			RepeatCount = 1;
			RepeatValue = b;
		}
		return true;
	}
}

class XlpStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		bool rle;
		if (b < 128)
			rle = false;
		else {
			b -= 128;
			rle = true;
		}
		RepeatCount = b;
		if (b >= 0x40) {
			b = ReadByte();
			if (b < 0)
				return false;
			RepeatCount = RepeatCount - 0x40 << 8 | b;
		}
		RepeatValue = rle ? ReadByte() : -1;
		return true;
	}
}

class AmstradStream : RleStream
{
	int BlockLength;

	protected override bool ReadCommand!()
	{
		while (BlockLength <= 0) {
			if (ReadByte() != 'M' || ReadByte() != 'J' || ReadByte() != 'H')
				return false;
			int lo = ReadByte();
			if (lo < 0)
				return false;
			int hi = ReadByte();
			if (hi < 0)
				return false;
			BlockLength = hi << 8 | lo;
		}
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b == 1) {
			RepeatCount = ReadByte();
			if (RepeatCount == 0)
				RepeatCount = 256;
			RepeatValue = ReadByte();
		}
		else {
			RepeatCount = 1;
			RepeatValue = b;
		}
		BlockLength -= RepeatCount;
		return true;
	}

	internal static bool UnpackFile(byte[] content, int contentOffset, int contentLength, byte[]! unpacked, int unpackedLength)
	{
		AmstradStream() rle;
		rle.Content = content;
		rle.ContentOffset = contentOffset;
		rle.ContentLength = contentLength;
		rle.BlockLength = 0;
		return rle.Unpack(unpacked, 0, 1, unpackedLength);
	}
}

class CpiStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (ContentOffset + 1 < ContentLength && Content[ContentOffset] == b) {
			ContentOffset++;
			RepeatCount = 1 + Content[ContentOffset++];
		}
		else
			RepeatCount = 1;
		RepeatValue = b;
		return true;
	}
}

class XeKoalaStream : RleStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		bool rle;
		if (b < 128)
			rle = true;
		else {
			b -= 128;
			rle = false;
		}
		if (b == 0) {
			int hi = ReadByte();
			if (hi < 0)
				return false;
			b = ReadByte();
			if (b < 0)
				return false;
			b |= hi << 8;
		}
		RepeatCount = b;
		RepeatValue = rle ? ReadByte() : -1;
		return true;
	}

	internal byte[7680] Unpacked;

	internal bool UnpackRaw!(int type, int unpackedLength)
	{
		switch (type) {
		case 0:
			if (ContentLength - ContentOffset != unpackedLength)
				return false;
			Content.CopyTo(ContentOffset, Unpacked, 0, unpackedLength);
			return true;
		case 1:
			for (int x = 0; x < 40; x++) {
				for (int unpackedOffset = x; unpackedOffset < 80; unpackedOffset += 40) {
					if (!Unpack(Unpacked, unpackedOffset, 80, unpackedLength))
						return false;
				}
			}
			return true;
		case 2:
			return Unpack(Unpacked, 0, 1, unpackedLength);
		default:
			return false;
		}
	}

	internal bool UnpackWrapped!(int unpackedLength)
	{
		if (ReadByte() != 0xff || ReadByte() != 0x80 || ReadByte() != 0xc9 || ReadByte() != 0xc7)
			return false;
		int offset = ReadByte();
		if (offset < 26 || ReadByte() != 0 || ReadByte() != 1)
			return false;
		int type = ReadByte();
		if (ReadByte() != 0x0e || ReadByte() != 0 || ReadByte() != 40
		 || ReadByte() != 0 || ReadByte() != 192)
			return false;
		ContentOffset += 7;
		if (ReadByte() != 0 || ReadByte() != 0)
			return false;
		ContentOffset += offset - 21;
		return UnpackRaw(type, unpackedLength);
	}
}

class ImgStream : RleStream
{
	int PatternRepeatCount = 0;
	const int Keep = 0x100;

	internal int GetLineRepeatCount!()
	{
		if (RepeatCount == 0
		 && ContentOffset < ContentLength - 4
		 && Content[ContentOffset] == 0
		 && Content[ContentOffset + 1] == 0
		 && Content[ContentOffset + 2] == 0xff) {
			ContentOffset += 4;
			return Content[ContentOffset - 1] + 1;
		}
		return 1;
	}

	protected override bool ReadCommand!()
	{
		if (PatternRepeatCount > 1) {
			PatternRepeatCount--;
			RepeatCount = Content[6] << 8 | Content[7];
			ContentOffset -= RepeatCount;
			return true;
		}
		int b = ReadByte();
		switch (b) {
		case -1:
			return false;
		case 0:
			b = ReadByte();
			if (b < 0)
				return false;
			if (b == 0) {
				b = ReadByte();
				if (b < 0)
					return false;
				RepeatCount = b + 1;
				RepeatValue = Keep;
				return true;
			}
			PatternRepeatCount = b;
			RepeatCount = Content[6] << 8 | Content[7];
			RepeatValue = -1;
			return true;
		case 0x80:
			RepeatCount = ReadByte();
			if (RepeatCount < 0)
				return false;
			if (RepeatCount == 0)
				RepeatCount = 256;
			RepeatValue = -1;
			return true;
		default:
			RepeatCount = b & 0x7f;
			RepeatValue = b >= 0x80 ? 0xff : 0;
			return true;
		}
	}
}

class CaStream : RleStream
{
	int EscapeByte;
	int DefaultValue;

	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b != EscapeByte) {
			RepeatCount = 1;
			RepeatValue = b;
			return true;
		}
		int c = ReadByte();
		if (c < 0)
			return false;
		if (c == EscapeByte) {
			RepeatCount = 1;
			RepeatValue = c;
			return true;
		}
		b = ReadByte();
		if (b < 0)
			return false;
		switch (c) {
		case 0:
			RepeatCount = b + 1;
			RepeatValue = ReadByte();
			break;
		case 1:
			c = ReadByte();
			if (c < 0)
				return false;
			RepeatCount = (b << 8) + c + 1;
			RepeatValue = ReadByte();
			break;
		case 2:
			if (b == 0)
				RepeatCount = 32000; // end decompression
			else {
				c = ReadByte();
				if (c < 0)
					return false;
				RepeatCount = (b << 8) + c + 1;
			}
			RepeatValue = DefaultValue;
			break;
		default:
			RepeatCount = c + 1;
			RepeatValue = b;
			break;
		}
		return true;
	}

	internal bool UnpackCa!(byte[]! unpacked, int unpackedOffset)
	{
		if (ContentOffset > ContentLength - 4)
			return false;
		EscapeByte = Content[ContentOffset];
		DefaultValue = Content[ContentOffset + 1];
		int unpackedStep = Content[ContentOffset + 2] << 8 | Content[ContentOffset + 3];
		if (unpackedStep >= 32000)
			return false;
		RepeatCount = 0;
		if (unpackedStep == 0) {
			RepeatCount = 32000;
			RepeatValue = DefaultValue;
			unpackedStep = 1;
		}
		ContentOffset += 4;
		return UnpackColumns(unpacked, unpackedOffset, unpackedStep, unpackedOffset + 32000);
	}

	internal static bool UnpackDel(byte[] content, int contentLength, byte[]! unpacked, int blocks)
	{
		CaStream() rle;
		rle.Content = content;
		rle.ContentOffset = blocks << 2;
		if (rle.ContentOffset >= contentLength)
			return false;
		for (int block = 0; block < blocks; block++) {
			rle.ContentLength = rle.ContentOffset + RECOIL.Get32BigEndian(content, block << 2);
			if (rle.ContentLength > contentLength || rle.ContentLength < rle.ContentOffset
			 || !rle.UnpackCa(unpacked, block * 32000))
				return false;
			rle.ContentOffset = rle.ContentLength;
		}
		if (blocks == 2) {
			// Actually three blocks, but the length of the third block is implicit.
			rle.ContentLength = contentLength;
			return rle.UnpackCa(unpacked, 64000);
		}
		return true;
	}
}

class RgbStream : RleStream
{
	internal override int ReadValue!() => ReadBits(12);

	protected override bool ReadCommand!()
	{
		int b = ReadBits(4);
		if (b < 0)
			return false;
		bool rle;
		if (b < 8)
			rle = true;
		else {
			b -= 8;
			rle = false;
		}
		if (b == 0) {
			b = ReadBits(4);
			if (b < 0)
				return false;
			b += 7;
		}
		if (rle) {
			RepeatValue = ReadValue();
			b++;
		}
		else
			RepeatValue = -1;
		RepeatCount = b;
		return true;
	}
}

// TNY and PCS use identical control bytes.
abstract class TnyPcsStream : RleStream
{
	protected bool ReadTnyCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			if (b == 0 || b == 1) {
				if (ContentOffset >= ContentLength - 1)
					return false;
				RepeatCount = Content[ContentOffset] << 8 | Content[ContentOffset + 1];
				ContentOffset += 2;
			}
			else
				RepeatCount = b;
			RepeatValue = b == 1 ? -1 : ReadValue();
		}
		else {
			RepeatCount = 256 - b;
			RepeatValue = -1;
		}
		return true;
	}
}

// In TNY values don't mix with control bytes.
class TnyStream : TnyPcsStream
{
	internal int ValueOffset;
	internal int ValueLength;

	protected override bool ReadCommand!() => ReadTnyCommand();

	internal override int ReadValue!()
	{
		if (ValueOffset + 1 >= ValueLength)
			return -1;
		int value = Content[ValueOffset] << 8 | Content[ValueOffset + 1];
		ValueOffset += 2;
		return value;
	}
}

class PcsStream : TnyPcsStream
{
	int CommandCount;
	bool Palette;

	protected override bool ReadCommand!()
	{
		if (CommandCount <= 0)
			return false;
		CommandCount--;
		return ReadTnyCommand();
	}

	internal override int ReadValue!()
	{
		// one byte for bitmap
		if (!Palette)
			return ReadByte();

		// one word for palette
		if (ContentOffset >= ContentLength - 1)
			return -1;
		int value = Content[ContentOffset] << 8 | Content[ContentOffset + 1];
		ContentOffset += 2;
		return value;
	}

	bool StartBlock!()
	{
		if (ContentOffset >= ContentLength - 1)
			return false;
		CommandCount = Content[ContentOffset] << 8 | Content[ContentOffset + 1];
		ContentOffset += 2;
		return true;
	}

	bool EndBlock!()
	{
		// skip garbage
		while (RepeatCount > 0 || CommandCount > 0) {
			if (ReadRle() < 0)
				return false;
		}
		return true;
	}

	const int UnpackedLength = 32000 + (199 * 3 + 1) * 32;

	internal bool UnpackPcs!(byte[]! unpacked)
	{
		// bitmap
		Palette = false;
		if (!StartBlock()
		 || !Unpack(unpacked, 0, 1, 32000)
		 || !EndBlock())
			return false;

		// palettes
		Palette = true;
		if (!StartBlock())
			return false;
		for (int unpackedOffset = 32000; unpackedOffset < UnpackedLength; unpackedOffset += 2) {
			int b = ReadRle();
			if (b < 0)
				return false;
			unpacked[unpackedOffset] = b >> 8;
			unpacked[unpackedOffset + 1] = b & 0xff;
		}
		return EndBlock();
	}
}

// Similar to TNY. Differences:
// 1. Word-sized counts belong to data, not commands.
// 2. Commands 0 and 1 are swapped.
class VdatStream : TnyStream
{
	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			if (b == 0 || b == 1) {
				RepeatCount = ReadValue();
				if (RepeatCount < 0)
					return false;
			}
			else
				RepeatCount = b;
			RepeatValue = b == 0 ? -1 : ReadValue();
		}
		else {
			RepeatCount = 256 - b;
			RepeatValue = -1;
		}
		return true;
	}
}

class HimStream : RleStream
{
	internal override int ReadValue!()
	{
		if (ContentOffset < 18)
			return -1;
		return Content[ContentOffset--];
	}

	protected override bool ReadCommand!()
	{
		int b = ReadValue();
		switch (b) {
		case -1:
			return false;
		case 0:
			RepeatCount = ReadValue();
			if (RepeatCount <= 0)
				return false;
			RepeatValue = ReadValue();
			return true;
		default:
			RepeatCount = b - 1;
			RepeatValue = -1;
			return true;
		}
	}
}

class IcStream : RleStream
{
	bool ReadCount!()
	{
		RepeatCount = 257;
		while (ReadByte() == 1)
			RepeatCount += 256;
		int b = ReadByte();
		if (b < 0)
			return false;
		RepeatCount += b;
		return true;
	}

	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		int escape = Content[0x42];
		if (b != escape) {
			RepeatCount = 1;
			RepeatValue = b;
			return true;
		}
		b = ReadByte();
		if (b == escape) {
			RepeatCount = 1;
			RepeatValue = b;
			return true;
		}
		switch (b) {
		case -1:
			return false;
		case 0:
			b = ReadByte();
			if (b < 0)
				return false;
			RepeatCount = b + 1;
			break;
		case 1:
			if (!ReadCount())
				return false;
			break;
		case 2:
			b = ReadByte();
			switch (b) {
			case -1:
				return false;
			case 0:
				// end of data
				RepeatCount = 32000;
				break;
			case 1:
				if (!ReadCount())
					return false;
				break;
			case 2:
				while (ReadByte() > 0) {
					// ignore
				}
				RepeatCount = 0;
				break;
			default:
				RepeatCount = b + 1;
				break;
			}
			RepeatValue = 0;
			return true;
		default:
			RepeatCount = b + 1;
			break;
		}
		RepeatValue = ReadByte();
		return true;
	}
}

class DeepStream : PackBitsStream
{
	internal int Components = 0;
	int[6] ComponentShift;
	int CurrentByte; // delta compression only
	internal int[]# Line = null; // delta compression only

	internal bool SetDpel!(int chunkOffset, int chunkLength)
	{
		if (chunkLength < 8 // also rules out zero components
		 || Content[chunkOffset + 8] != 0 || Content[chunkOffset + 9] != 0 || Content[chunkOffset + 10] != 0)
			return false;
		Components = Content[chunkOffset + 11];
		if (Components > ComponentShift.Length || chunkLength != Components + 1 << 2)
			return false;
		for (int c = 0; c < Components; c++) {
			int offset = chunkOffset + 12 + c * 4;
			if (Content[offset] != 0 || Content[offset + 2] != 0 || Content[offset + 3] != 8)
				return false;
			int shift;
			switch (Content[offset + 1]) {
			case 1: // red
				shift = 16;
				break;
			case 2: // green
				shift = 8;
				break;
			case 3: // blue
				shift = 0;
				break;
			case 4: // alpha
			case 9: // mask (untested)
			case 10: // zbuffer (untested)
			case 11: // opacity (untested)
			case 17: // density (unknown meaning)
				shift = -1;
				break;
			default:
				return false;
			}
			ComponentShift[c] = shift;
		}
		return true;
	}

	internal override int ReadValue!()
	{
		int rgb = 0;
		for (int c = 0; c < Components; c++) {
			int b = ReadByte();
			if (b < 0)
				return -1;
			int shift = ComponentShift[c];
			if (shift >= 0)
				rgb |= b << shift;
		}
		return rgb;
	}

	int ReadNibble!()
	{
		if (CurrentByte < 0) {
			CurrentByte = ReadByte();
			if (CurrentByte < 0)
				return -1;
			return CurrentByte >> 4;
		}
		int result = CurrentByte & 0xf;
		CurrentByte = -1;
		return result;
	}

	internal bool ReadDeltaLine!(int width, int tvdcOffset)
	{
		if (Line == null)
			Line = new int[width];
		for (int c = 0; c < Components; c++) {
			int count = 0;
			int value = 0;
			CurrentByte = -1;
			for (int x = 0; x < width; x++) {
				if (count == 0) {
					int i = ReadNibble();
					if (i < 0)
						return false;
					int delta = Content[tvdcOffset + i * 2 + 1];
					if (delta == 0) {
						if (Content[tvdcOffset + i * 2] == 0) {
							count = ReadNibble();
							if (count < 0)
								return false;
						}
					}
					else
						value = value + delta & 0xff;
				}
				else
					count--;

				int rgb = c == 0 ? 0 : Line[x];
				int shift = ComponentShift[c];
				if (shift >= 0)
					rgb |= value << shift;
				Line[x] = rgb;
			}
		}
		return true;
	}
}

class PackBytesStream : Stream
{
	int Count = 1;
	int Pattern = 0;

	internal int ReadUnpacked!()
	{
		if (--Count == 0) {
			if (ContentOffset >= ContentLength)
				return -1;
			int b = Content[ContentOffset++];
			Count = (b & 0x3f) + 1;
			if (b >= 0x80)
				Count <<= 2;
			const byte[4] patterns = { 0, 1, 4, 1 };
			Pattern = patterns[b >> 6];
		}
		else if ((Count & Pattern - 1) == 0)
			ContentOffset -= Pattern;
		return ReadByte();
	}
}

class Lz4Stream : Stream
{
	internal byte[]! Unpacked;
	internal int UnpackedOffset;
	internal int UnpackedLength;

	internal bool Copy!(int count)
	{
		if (UnpackedOffset + count > UnpackedLength
		 || !ReadBytes(Unpacked, UnpackedOffset, count))
			return false;
		UnpackedOffset += count;
		return true;
	}

	internal int ReadCount!(int count)
	{
		if (count == 15) {
			int b;
			do {
				b = ReadByte();
				if (b < 0)
					return -1;
				count += b;
			} while (b == 255);
		}
		return count;
	}
}

class Tre1Stream : RleStream
{
	int LastRgb = -1;

	protected override bool ReadCommand!()
	{
		RepeatCount = ReadByte();
		if (RepeatCount <= 0)
			return false;
		if (RepeatCount == 255) {
			if (ContentOffset + 1 >= ContentLength)
				return false;
			RepeatCount = 255 + (Content[ContentOffset] << 8) + Content[ContentOffset + 1];
			ContentOffset += 2;
		}
		// literal, repeat, literal, repeat...
		RepeatValue = LastRgb;
		LastRgb = -1;
		return true;
	}

	internal override int ReadValue!()
	{
		if (ContentOffset + 1 >= ContentLength)
			return -1;
		LastRgb = RECOIL.GetFalconTrueColor(Content, ContentOffset);
		ContentOffset += 2;
		return LastRgb;
	}
}

class Nl3Stream : RleStream
{
	internal override int ReadValue!()
	{
		int e = ReadNl3Char(false);
		if (e < 0x20)
			return -1;
		if (e < 0x7f)
			return e - 0x20;
		if (e < 0xa0)
			return -1;
		if (e < 0xe0)
			return e - (0xa0 - 0x5f);
		if (e == 0xfd) // TODO: test
			return 159;
		if (e == 0xfe) // TODO: test
			return 160;
		return -1;
	}

	protected override bool ReadCommand!()
	{
		int b = ReadValue();
		if (b < 0 || b > 127)
			return false;
		RepeatValue = b & 0x3f;
		if (b < 64)
			RepeatCount = 1;
		else {
			b = ReadValue();
			if (b < 0)
				return false;
			RepeatCount = b + 2;
		}
		return true;
	}
}

class SfdnStream : BitStream
{
	internal bool Unpack!(byte[]! unpacked, int unpackedLength)
	{
		if (ContentLength < 22 + (unpackedLength >> 1) // two or more compressed bits per uncompressed nibble
		 || !RECOIL.IsStringAt(Content, 0, "S101")
		 || (Content[4] | Content[5] << 8) != unpackedLength)
			return false;
		ContentOffset = 22;
		int current = ReadBits(4);
		int hi = -1;
		for (int unpackedOffset = 0;;) {
			if (hi < 0)
				hi = current;
			else {
				unpacked[unpackedOffset++] = hi << 4 | current;
				if (unpackedOffset >= unpackedLength)
					return true;
				hi = -1;
			}
			int code;
			int bit;
			for (code = 0; ; code += 2) {
				bit = ReadBit();
				if (bit == 0)
					break;
				if (bit < 0 || code >= 14)
					return false;
			}
			bit = ReadBit();
			if (bit < 0)
				return false;
			code += bit;
			current = current - Content[6 + code] & 0xf;
		}
	}
}

class G9bStream : BitStream
{
	const int BlockEnd = -2;

	int ReadLength!()
	{
		for (int length = 1; length < 1 << 16;) {
			switch (ReadBit()) {
			case 0:
				return length + 1;
			case 1:
				break;
			default:
				return -1;
			}
			length <<= 1;
			switch (ReadBit()) {
			case 0:
				break;
			case 1:
				length++;
				break;
			default:
				return -1;
			}
		}
		return BlockEnd;
	}

	internal bool Unpack!(byte[]! unpacked, int headerLength, int unpackedLength)
	{
		ContentOffset = headerLength + 3;
		for (int unpackedOffset = headerLength; unpackedOffset < unpackedLength;) {
			int b;
			switch (ReadBit()) {
			case 0:
				b = ReadByte();
				if (b < 0)
					return false;
				unpacked[unpackedOffset++] = b;
				break;
			case 1:
				int length = ReadLength();
				if (length == BlockEnd) {
					ContentOffset += 2; // skip block length
					Bits = 0; // reset bit buffer
					break;
				}
				if (length < 0 || unpackedOffset + length > unpackedLength)
					return false;
				int distance = ReadByte();
				if (distance < 0)
					return false;
				if (distance >= 128) {
					b = ReadBits(4);
					if (b < 0)
						return false;
					distance += b - 1 << 7;
				}
				distance++;
				if (unpackedOffset - distance < headerLength)
					return false;
				do {
					unpacked[unpackedOffset] = unpacked[unpackedOffset - distance];
					unpackedOffset++;
				} while (--length > 0);
				break;
			default:
				return false;
			}
		}
		return true;
	}
}

class MigStream : BitStream
{
	const int MaxUnpackedLength = 108800;

	internal int Unpack!(byte[]! unpacked)
	{
		ContentOffset = 11 + 4;
		for (int unpackedOffset = 0; unpackedOffset < MaxUnpackedLength; ) {
			int c = ReadBit();
			if (c < 0)
				return -1;
			int b = ReadByte();
			if (b < 0)
				return -1;
			if (c == 0)
				unpacked[unpackedOffset++] = b;
			else {
				if (b >= 128) {
					c = ReadBits(4);
					if (c < 0)
						return -1;
					b += c - 1 << 7;
				}
				int distance = b + 1;
				if (unpackedOffset - distance < 0)
					return -1;
				c = -1;
				do {
					b = ReadBit();
					if (b < 0)
						return -1;
					c++;
				} while (b != 0);
				int length = ReadBits(c);
				if (length < 0)
					return -1;
				if (c >= 16) {
					ContentOffset += 4; // skip unpackedBlockLength, packedBlockLength
					if (ContentOffset >= ContentLength)
						return unpackedOffset;
					Bits = 0; // reset bit buffer
				}
				else {
					length += (1 << c) + 1;
					if (unpackedOffset + length > MaxUnpackedLength)
						return -1;
					do {
						unpacked[unpackedOffset] = unpacked[unpackedOffset - distance];
						unpackedOffset++;
					} while (--length > 0);
				}
			}
		}
		return -1;
	}
}

class Ice21Stream
{
	internal byte[] Content;
	internal int ContentOffset;
	internal int ContentStart;
	protected int Bits;

	internal int GetUnpackedLength()
	{
		if (ContentStart + 16 > ContentOffset
		 || !RECOIL.IsStringAt(Content, ContentStart, "Ice!")
		 || RECOIL.Get32BigEndian(Content, ContentStart + 4) != ContentOffset - ContentStart)
			return -1;
		return RECOIL.Get32BigEndian(Content, ContentStart + 8);
	}

	protected int ReadBit!()
	{
		int b = Bits;
		int next = b & 0x7fffffff;
		if (next == 0) {
			ContentOffset -= 4;
			if (ContentOffset < ContentStart)
				return -1;
			b = RECOIL.Get32BigEndian(Content, ContentOffset);
			Bits = (b & 0x7fffffff) << 1 | 1;
		}
		else
			Bits = next << 1;
		return b >> 31 & 1;
	}

	protected int ReadBits!(int count)
	{
		int result = 0;
		while (--count >= 0) {
			int bit = ReadBit();
			if (bit < 0)
				return -1;
			result = result << 1 | bit;
		}
		return result;
	}

	int CountOnes!(int max)
	{
		for (int result = 0; result < max; result++) {
			switch (ReadBit()) {
			case -1:
				return -1;
			case 0:
				return result;
			default:
				break;
			}
		}
		return max;
	}

	int ReadLiteralLength!()
	{
		int o = 1;
		for (int n = 0; ; n++) {
			const byte[] bits = { 1, 2, 2, 3, 8, 15 };
			int c = bits[n];
			int b = ReadBits(c);
			if (b < 0)
				return -1;
			c = (1 << c) - 1;
			if (b < c || n == bits.Length - 1)
				return o + b;
			o += c;
		}
	}

	int ReadEncoded!(int maxCount, byte[] extraBits, int[] offsets)
	{
		int n = CountOnes(maxCount);
		if (n < 0)
			return -1;
		int b = ReadBits(extraBits[n]);
		if (b < 0)
			return -1;
		return offsets[n] + b;
	}

	internal bool Unpack!(byte[]! unpacked, int unpackedStart, int unpackedEnd)
	{
		ContentStart += 12;
		ContentOffset -= 4;
		Bits = RECOIL.Get32BigEndian(Content, ContentOffset);
		for (int unpackedOffset = unpackedEnd; unpackedOffset > unpackedStart; ) {
			int length;
			switch (ReadBit()) {
			case -1:
				return false;
			case 1:
				// literals
				length = ReadLiteralLength();
				if (length > unpackedOffset - unpackedStart)
					length = unpackedOffset - unpackedStart;
				ContentOffset -= length;
				if (ContentOffset < ContentStart)
					return false;
				unpackedOffset -= length;
				Content.CopyTo(ContentOffset, unpacked, unpackedOffset, length);
				if (unpackedOffset == unpackedStart)
					return true;
				break;
			default:
				break;
			}

			// LZ77
			const byte[] lengthExtraBits = { 0, 0, 1, 2, 10 };
			const int[] lengthOffsets = { 0, 1, 2, 4, 8 };
			length = ReadEncoded(4, lengthExtraBits, lengthOffsets);
			int offset;
			switch (length) {
			case -1:
				return false;
			case 0:
				switch (ReadBit()) {
				case -1:
					return false;
				case 0:
					offset = ReadBits(6);
					if (offset < 0)
						return false;
					break;
				default:
					offset = ReadBits(9);
					if (offset < 0)
						return false;
					offset += 64;
					break;
				}
				break;
			default:
				const byte[] offsetExtraBits = { 8, 5, 12 };
				const int[] offsetOffsets = { 32, 0, 288 };
				offset = ReadEncoded(2, offsetExtraBits, offsetOffsets);
				if (offset < 0)
					return false;
				break;
			}
			length += 2;
			offset += length;
			if (unpackedOffset + offset > unpackedEnd)
				return false;
			if (length > unpackedOffset - unpackedStart)
				length = unpackedOffset - unpackedStart;
			unpackedOffset -= length;
			unpacked.CopyTo(unpackedOffset + offset, unpacked, unpackedOffset, length);
		}
		return true;
	}
}

class SpxStream : Ice21Stream
{
	int ReadCount!()
	{
		int b = ReadBits(2);
		if (b < 0)
			return -1;
		return ReadBits((b + 1) << 2);
	}

	internal bool UnpackV2!(byte[]! unpacked, int unpackedLength)
	{
		Bits = 0;
		for (int unpackedOffset = unpackedLength; unpackedOffset > 0; ) {
			int count;
			switch (ReadBit()) {
			case -1:
				return false;
			case 0:
				// literals
				count = ReadCount();
				if (count <= 0)
					return false;
				if (count > unpackedOffset)
					count = unpackedOffset;
				for (int i = 0; i < count; i++) {
					int b = ReadBits(8);
					if (b < 0)
						return false;
					unpacked[--unpackedOffset] = b;
				}
				if (unpackedOffset == 0)
					return true;
				if (count == 0xffff)
					continue;
				break;
			default:
				break;
			}

			// LZ77
			int distance = ReadCount();
			if (distance <= 0 || unpackedOffset + distance > unpackedLength)
				return false;
			count = ReadCount();
			if (count < 0)
				return false;
			count += 3;
			if (count > unpackedOffset)
				count = unpackedOffset;
			do {
				unpackedOffset--;
				unpacked[unpackedOffset] = unpacked[unpackedOffset + distance];
			} while (--count > 0);
		}
		return true;
	}
}

class Q4Stream : RleStream
{
	internal int StartChunk!()
	{
		if (ContentOffset + 6 > ContentLength)
			return -1;
		int chunkLength = Content[ContentOffset] | Content[ContentOffset + 1] << 8;
		ContentOffset += 6;
		ContentLength = ContentOffset + chunkLength;
		return ContentLength;
	}

	int CodeBits;

	int ReadCode!()
	{
		do {
			int value = ReadBits(CodeBits);
			switch (value) {
			case -1:
			case 0:
				return -1;
			case 1:
				break;
			default:
				return value - 2;
			}
		} while (++CodeBits <= 15);
		return -1;
	}

	byte[65536] Unpacked;

	internal bool UnpackQ4!()
	{
		Bits = 0;
		CodeBits = 3;
		int unpackedLength = 0;
		ushort[16384] offsets;
		for (int codes = 17; codes < offsets.Length; codes++) {
			int code = ReadCode();
			if (code < 0 || code >= codes) {
				Content = Unpacked;
				ContentOffset = 0;
				ContentLength = unpackedLength;
				LastRepeatValue = 0;
				return true;
			}

			// LZW
			if (unpackedLength >= Unpacked.Length)
				return false;
			offsets[codes] = unpackedLength;
			if (code <= 16) {
				// literal
				Unpacked[unpackedLength++] = code;
			}
			else {
				// dictionary entry
				int sourceOffset = offsets[code];
				int endOffset = offsets[code + 1];
				if (unpackedLength + endOffset - sourceOffset >= Unpacked.Length)
					return false;
				do
					Unpacked[unpackedLength++] = Unpacked[sourceOffset++];
				while (sourceOffset <= endOffset);
			}
		}
		return false;
	}

	int LastRepeatValue;

	protected override bool ReadCommand!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 16) {
			RepeatCount = 1;
			RepeatValue = b;
			return true;
		}
		b = ReadByte();
		if (b == 0) {
			LastRepeatValue = ReadByte();
			if (LastRepeatValue < 0 || LastRepeatValue >= 16)
				return false;
			b = ReadByte();
		}
		if (b < 0)
			return false;
		RepeatCount = b * 17;
		b = ReadByte();
		if (b < 0)
			return false;
		RepeatCount += b;
		RepeatValue = LastRepeatValue;
		return true;
	}
}

class PiStream : BitStream
{
	internal byte[]# Indexes;
	byte[256 * 256] RecentColors;

	int ReadInt!(int bits, int maxBits)
	{
		for (; bits < maxBits; bits++) {
			int b = ReadBit();
			if (b == 0)
				break;
			if (b < 0)
				return -1;
		}
		return 1 << bits | ReadBits(bits); // ReadBits can return -1
	}

	bool UnpackLiteral!(int indexesOffset, int depth)
	{
		int offset;
		switch (ReadBit()) {
		case 1:
			offset = ReadBit();
			break;
		case 0:
			offset = ReadInt(1, depth - 1);
			break;
		default: // -1
			return false;
		}
		if (offset < 0)
			return false;
		int recentOffset = indexesOffset == 0 ? 0 : Indexes[indexesOffset - 1] << 8;
		offset += recentOffset;
		int c = RecentColors[offset];
		for (; offset > recentOffset; offset--)
			RecentColors[offset] = RecentColors[offset - 1];
		RecentColors[offset] = c;
		Indexes[indexesOffset] = c;
		return true;
	}

	bool UnpackTwoLiterals!(int indexesOffset, int indexesLength, int depth)
	{
		if (!UnpackLiteral(indexesOffset, depth))
			return false;
		return indexesOffset + 1 >= indexesLength
			|| UnpackLiteral(indexesOffset + 1, depth);
	}

	int ReadPosition!()
	{
		int position = ReadBits(2);
		if (position != 3)
			return position;
		position = ReadBit();
		if (position < 0)
			return -1;
		return 3 + position;
	}

	internal bool Unpack!(int width, int height, int depth)
	{
		int colors = 1 << depth;
		for (int i = 0; i < colors; i++)
			for (int j = 0; j < colors; j++)
				RecentColors[i << 8 | j] = i - j & (colors - 1);
		int indexesLength = width * height;
		Indexes = new byte[indexesLength];
		if (!UnpackTwoLiterals(0, indexesLength, depth))
			return false;

		int lastPosition = -1;
		for (int indexesOffset = 0; indexesOffset < indexesLength; ) {
			int position = ReadPosition();
			if (position < 0)
				return false;
			if (position == lastPosition) {
				do {
					if (!UnpackTwoLiterals(indexesOffset, indexesLength, depth))
						return false;
					indexesOffset += 2;
				} while (indexesOffset < indexesLength && ReadBit() == 1);
				lastPosition = -1;
			}
			else {
				int length = ReadInt(0, 23); // 23 is arbitrary, assumes no more than ~16M pixels
				if (length < 0)
					return false;
				lastPosition = position;
				switch (position) {
				case 0:
					position = indexesOffset == 0 ? 0 : indexesOffset - 2;
					position = Indexes[position] == Indexes[position + 1] ? 2 : 4;
					break;
				case 1:
					position = width;
					break;
				case 2:
					position = width << 1;
					break;
				case 3:
					position = width - 1;
					break;
				case 4:
					position = width + 1;
					break;
				default:
					assert false;
				}
				int copyEnd = indexesOffset + (length << 1);
				if (copyEnd > indexesLength)
					copyEnd = indexesLength;
				for (; indexesOffset < copyEnd; indexesOffset++) {
					int sourceOffset = indexesOffset - position;
					if (sourceOffset < 0)
						sourceOffset &= 1;
					Indexes[indexesOffset] = Indexes[sourceOffset];
				}
			}
		}
		return true;
	}
}

// FlashPack 2.1
class A4rStream : Stream
{
	int OuterFlags = 0;
	int InnerFlags = 0;

	int ReadFlag!()
	{
		if ((InnerFlags & 0x7f) == 0) {
			if ((OuterFlags & 0x7f) == 0) {
				if (ContentOffset >= ContentLength)
					return -1;
				OuterFlags = Content[ContentOffset++] << 1 | 1;
			}
			else
				OuterFlags <<= 1;
			if ((OuterFlags & 0x100) == 0)
				InnerFlags = 1;
			else {
				if (ContentOffset >= ContentLength)
					return -1;
				InnerFlags = Content[ContentOffset++] << 1 | 1;
			}
		}
		else
			InnerFlags <<= 1;
		return InnerFlags >> 8 & 1;
	}

	const int MinAddress = 0x4e10;
	const int MaxAddress = 0x79ff;
	const int UnpackedLength = MaxAddress - MinAddress + 1;

	internal byte[UnpackedLength] Unpacked;
	int UnpackedOffset;

	bool CopyByte!()
	{
		int b = ReadByte();
		if (b < 0 || UnpackedOffset < 0 || UnpackedOffset >= UnpackedLength)
			return false;
		Unpacked[UnpackedOffset++] = b;
		return true;
	}

	bool CopyBlock!(int distance, int count)
	{
		if (UnpackedOffset < 0)
			return false;
		int nextOffset = UnpackedOffset + count;
		if (nextOffset > UnpackedLength
		 || !RECOIL.CopyPrevious(Unpacked, UnpackedOffset, distance, count))
			return false;
		UnpackedOffset = nextOffset;
		return true;
	}

	internal bool UnpackA4r!()
	{
		Unpacked.Fill(0);
		UnpackedOffset = -1;
		for (;;) {
			switch (ReadFlag()) {
			case 0:
				// literal byte
				if (!CopyByte())
					return false;
				break;
			case 1:
				int b = ReadByte();
				switch (b) {
				case -1:
					return false;
				case 0:
					// new address, first byte literal
					if (ContentOffset >= ContentLength - 2)
						return false;
					b = ReadByte();
					UnpackedOffset = b + (ReadByte() << 8) + 0x80 - MinAddress;
					if (!CopyByte())
						return false;
					break;
				case 1:
					b = ReadByte();
					switch (b) {
					case -1:
						return false;
					case 0:
						// end of stream
						return true;
					default:
						// RLE
						if (!CopyBlock(1, b + 2))
							return false;
						break;
					}
					break;
				default:
					// 2- or 3-byte LZ77
					if (!CopyBlock(0x80 - (b >> 1), 2 + (b & 1)))
						return false;
					break;
				}
				break;
			default:
				return false;
			}
		}
	}
}

class ZimStream : Stream
{
	byte[1] Flags1;
	internal byte[8] Flags2;

	internal int ReadWord!()
	{
		if (ContentOffset + 1 >= ContentLength)
			return -1;
		int result = Content[ContentOffset] | Content[ContentOffset + 1] << 8;
		ContentOffset += 2;
		return result;
	}

	internal int ReadUnpacked!(byte[] flags, int unpackedOffset) => (flags[unpackedOffset >> 3] >> (~unpackedOffset & 7) & 1) != 0 ? ReadByte() : 0;

	internal bool Unpack!(byte[] flags, byte[]! unpacked, int unpackedLength)
	{
		bool enough = true;
		for (int unpackedOffset = 0; unpackedOffset < unpackedLength; unpackedOffset++) {
			int b = ReadUnpacked(flags, unpackedOffset);
			if (b < 0) {
				enough = false;
				b = 0;
			}
			unpacked[unpackedOffset] = b;
		}
		return enough;
	}

	internal bool UnpackFlags2!()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		Flags1[0] = b;
		return Unpack(Flags1, Flags2, 8);
	}
}

class FanoTree
{
	/// Count[n] == number of codes of bit length n.
	int[16] Count;
	/// Values sorted by code length.
	byte[256] Values;

	internal void Create!(byte[] content, int contentOffset, int codeCount)
	{
		Count.Fill(0);
		for (int code = 0; code < codeCount; code++)
			Count[RECOIL.GetNibble(content, contentOffset, code)]++;
		int[16] positions;
		int position = 0;
		for (int bits = 0; bits < 16; bits++) {
			positions[bits] = position;
			position += Count[bits];
		}
		for (int code = 0; code < codeCount; code++)
			Values[positions[RECOIL.GetNibble(content, contentOffset, code)]++] = code;
	}

	internal int ReadCode(BitStream! bitStream)
	{
		int code = 0;
		int valuesOffset = Count[0];
		for (int bits = 1; bits < 16; bits++) {
			int bit = bitStream.ReadBit();
			if (bit < 0)
				return -1;
			code = code << 1 | bit;
			int count = Count[bits];
			if (code < count)
				return Values[valuesOffset + code];
			code -= count;
			valuesOffset += count;
		}
		return -1;
	}
}

/// Dictionary of `Count` key-value pairs.
/// A key is an integer between zero and `Count-1`. A value is an int.
/// The dictionary always contains exactly `Count` mappings. The values are initially all zeros.
/// The pairs are ordered by their last usage, from Most Recently Used (MRU) to Least Recently Used (LRU).
/// When you add or retrieve a value, it becomes the Most Recently Used.
/// When you add a value, the Least Recently Used is discarded.
class RecentInts
{
	const int Count = 128;
	int[Count] Value = 0;

	// Internally we use a doubly linked ring for ordering keys by their usage.
	byte[Count] Prev;
	byte[Count] Next;
	byte Head = 0; // Most Recently Used key

	RecentInts()
	{
		for (int i = 0; i < Count; i++) {
			Prev[i] = (i + 1) & (Count - 1);
			Next[i] = (i - 1) & (Count - 1);
		}
	}

	/// Store the value.
	/// Will use the Least Recently Used key.
	/// Its previous value is discarded and now it maps to `value`
	/// and becomes the Most Recently Used.
	internal void Add!(int value)
	{
		// make LRU the MRU
		Head = Prev[Head];
		// store MRU value
		Value[Head] = value;
	}

	/// Retrieve a value by key.
	internal int Get!(int key)
	{
		if (key != Head) {
			// disconnect key from the list
			byte prev = Prev[key];
			byte next = Next[key];
			Next[prev] = next;
			Prev[next] = prev;

			// insert key as MRU
			byte tail = Prev[Head];
			Next[tail] = key;
			Prev[key] = tail;
			Prev[Head] = key;
			Next[key] = Head;
			Head = key;
		}
		return Value[key];
	}
}

class BlazingPaddlesBoundingBox
{
	internal int Left;
	internal int Top;
	internal int Right;
	internal int Bottom;

	internal bool Calculate!(byte[] content, int contentLength, int index, int startAddress)
	{
		index <<= 1;
		if (index + 1 >= contentLength)
			return false;
		int contentOffset = content[index] + (content[index + 1] << 8) - startAddress;
		if (contentOffset < 0)
			return false;
		Left = Top = Right = Bottom = 0;
		int x = 0;
		int y = 0;
		while (contentOffset < contentLength) {
			int control = content[contentOffset++];
			if (control == 0x08)
				return true;
			// bits 7-4: length-1
			int len = (control >> 4) + 1;
			// bits 1-0: direction
			switch (control & 3) {
			case 0: // right
				x += len;
				if (Right < x)
					Right = x;
				break;
			case 1: // left
				x -= len;
				if (Left > x)
					Left = x;
				break;
			case 2: // up
				y -= len;
				if (Top > y)
					Top = y;
				break;
			case 3: // down
				y += len;
				if (Bottom < y)
					Bottom = y;
				break;
			default:
				assert false;
			}
		}
		return false;
	}
}

class IcnParser : Stream
{
	bool SkipWhitespaceAndComments!()
	{
		bool got = false;
		while (ContentOffset < ContentLength) {
			switch (Content[ContentOffset]) {
			case ' ':
			case '\t':
			case '\r':
			case '\n':
				ContentOffset++;
				got = true;
				break;
			case '/':
				if (ContentOffset >= ContentLength - 3 || Content[ContentOffset + 1] != '*')
					return false;
				ContentOffset += 3;
				do {
					if (++ContentOffset > ContentLength)
						return false; // error: unclosed comment
				} while (Content[ContentOffset - 2] != '*' || Content[ContentOffset - 1] != '/');
				got = true;
				break;
			default:
				return got;
			}
		}
		return true;
	}

	internal bool Expect!(string s)
	{
		if (!SkipWhitespaceAndComments())
			return false;
		int length = s.Length;
		for (int i = 0; i < length; i++)
			if (ReadByte() != s[i])
				return false;
		return true;
	}

	internal int ParseHex!()
	{
		if (!Expect("0x"))
			return -1;
		return ParseInt(16, 0xffff);
	}

	internal int ParseDefine!(string s)
	{
		if (!Expect("#define") || !Expect(s))
			return -1;
		return ParseHex();
	}
}

// Interpreter of a subset of ZX81 Sinclair BASIC.
// Typical *.p picture program looks like this:
// 10 FAST
// 20 CLS
// 30 CLEAR
// 40 PRINT "<256 characters>";
// 50 PRINT "<256 characters>";
// 60 PRINT "<192 characters>";
// 70 LET A$="<64 characters>"
// 80 LET S=3+PEEK 16400+256*PEEK 16401
// 90 LET D=727+PEEK 16396+256*PEEK 16397
// 100 IF LEN A$<>64 THEN STOP
// 110 FOR F=0 TO 63
// 120 POKE D+F+(F>31),PEEK(S+F)
// 130 NEXT F
// 140 SLOW
// 150 PAUSE 4E4
// FAST disables the display so that the program runs faster. SLOW enables it.
// CLS clears the screen. CLEAR undefines all variables.
// Semicolon at the end of PRINT means "no new line".
// Lines 70-130 fill the bottom two rows which PRINT cannot access.
class PInterpreter : Stream
{
	internal byte[32 * 24] Screen;
	int ScreenOffset;
	bool NewLineWorks;
	int BottomOffset;

	const int LetS = 1; // LET S=3+PEEK 16400+256*PEEK 16401
	const int LetD = 2; // LET D=727+PEEK 16396+256*PEEK 16397
	const int ForF = 4; // FOR F=0 TO 63
	const int PokeD = 8; // POKE D+F+(F>31),PEEK(S+F)
	int BottomCode;

	int ReadNumber!()
	{
		for (;;) {
			switch (ReadByte()) {
			case 0x15: // +
			case 0x16: // -
			case 0x1b: // .
			case 0x1c: // 0
			case 0x1d: // 1
			case 0x1e: // 2
			case 0x1f: // 3
			case 0x20: // 4
			case 0x21: // 5
			case 0x22: // 6
			case 0x23: // 7
			case 0x24: // 8
			case 0x25: // 9
			case 0x2a: // E
				break;
			case 0x7e:
				if (ContentOffset > ContentLength - 5)
					return -1;
				int exp = ReadByte();
				int m0 = ReadByte();
				int m1 = ReadByte();
				ContentOffset += 2;
				if (exp > 0x90 // too big to fit in 16 bits
				 || m0 >= 0x80) // negative
					return -1;
				if (exp <= 0x80) // between 0 and 1
					return 0;
				return ((m0 | 0x80) << 8 | m1) >> (0x90 - exp);
			default:
				return -1;
			}
		}
	}

	int PrintString!(int offset)
	{
		for (;;) {
			if (offset >= ContentLength)
				return -1;
			int c = Content[offset++];
			if (c == 0x0b) // "
				break;
			if (ScreenOffset >= 24 * 32)
				return -1;
			if (c == 0xc0) // escaped "
				c = 0x0b;
			else if ((c & 0x7f) >= 0x40)
				return -1;
			Screen[ScreenOffset++] = c;
			NewLineWorks = (ScreenOffset & 0x1f) != 0;
		}
		return offset;
	}

	bool Print!()
	{
		for (;;) {
			switch (ReadByte()) {
			case 0x0b: // "
				ContentOffset = PrintString(ContentOffset);
				if (ContentOffset < 0)
					return false;
				break;
			case 0xc1: // AT
				int row = ReadNumber();
				if (row < 0 || row > 21 || ReadByte() != 0x1a) // ,
					return false;
				int column = ReadNumber();
				if (column < 0 || column > 31)
					return false;
				ScreenOffset = row << 5 | column;
				NewLineWorks = true;
				break;
			case 0x00: // space
			case 0x19: // ;
				break;
			case 0x76:
				ContentOffset--;
				if (Content[ContentOffset - 1] != 0x19) {
					// new line
					if (NewLineWorks)
						ScreenOffset = (ScreenOffset & ~0x1f) + 32;
					NewLineWorks = true;
				}
				return true;
			default:
				return false;
			}
		}
	}

	bool DPeek!(int expectedX, int expectedAddress)
	{
		return ReadByte() == 0x14 // =
			&& ReadNumber() == expectedX
			&& ReadByte() == 0x15 // +
			&& ReadByte() == 0xd3 // PEEK
			&& ReadNumber() == expectedAddress
			&& ReadByte() == 0x15 // +
			&& ReadNumber() == 256
			&& ReadByte() == 0x17 // *
			&& ReadByte() == 0xd3 // PEEK
			&& ReadNumber() == expectedAddress + 1;
	}

	bool Let!()
	{
		switch (ReadByte()) {
		case 0x26: // A
			if (ReadByte() != 0x0d || ReadByte() != 0x14 || ReadByte() != 0x0b) // $ = "
				return false;
			BottomOffset = ContentOffset;
			for (;;) {
				switch (ReadByte()) {
				case -1:
					return false;
				case 0x0b:
					return true;
				default:
					break;
				}
			}
		case 0x38: // S
			BottomCode |= LetS;
			return DPeek(3, 16400);
		case 0x29: // D
			BottomCode |= LetD;
			return DPeek(727, 16396);
		default:
			return false;
		}
	}

	bool DoIf!()
	{
		return ReadByte() == 0xc6 // LEN
			&& ReadByte() == 0x26 // A
			&& ReadByte() == 0x0d // $
			&& ReadByte() == 0xdd // <>
			&& ReadNumber() == 64
			&& ReadByte() == 0xde // THEN
			&& ReadByte() == 0xe3; // STOP
	}

	bool DoFor!()
	{
		BottomCode |= ForF;
		return ReadByte() == 0x2b // F
			&& ReadByte() == 0x14 // =
			&& ReadNumber() == 0
			&& ReadByte() == 0xdf // TO
			&& ReadNumber() == 63;
	}

	bool Poke!()
	{
		BottomCode |= PokeD;
		return ReadByte() == 0x29 // D
			&& ReadByte() == 0x15 // +
			&& ReadByte() == 0x2b // F
			&& ReadByte() == 0x15 // +
			&& ReadByte() == 0x10 // (
			&& ReadByte() == 0x2b // F
			&& ReadByte() == 0x12 // >
			&& ReadNumber() == 31
			&& ReadByte() == 0x11 // )
			&& ReadByte() == 0x1a // ,
			&& ReadByte() == 0xd3 // PEEK
			&& ReadByte() == 0x10 // (
			&& ReadByte() == 0x38 // S
			&& ReadByte() == 0x15 // +
			&& ReadByte() == 0x2b // F
			&& ReadByte() == 0x11; // )
	}

	bool Next!()
	{
		if (ReadByte() == 0x2b // F
		 && BottomOffset > 0
		 && BottomCode == (LetS | LetD | ForF | PokeD)) {
			ScreenOffset = 22 * 32;
			return PrintString(BottomOffset) >= 0;
		}
		return false;
	}

	internal bool Run!()
	{
		ContentOffset = 0x74;
		Screen.Fill(0);
		ScreenOffset = 0;
		NewLineWorks = true;
		BottomOffset = -1;
		BottomCode = 0;

		for (;;) {
			if (ContentOffset > ContentLength - 8)
				return false;
			if (ReadByte() == 0x76)
				return true; // no more lines
			ContentOffset += 3;
			switch (ReadByte()) {
			case 0xe4: // SLOW
			case 0xe5: // FAST
			case 0xfb: // CLS
			case 0xfd: // CLEAR
				break;
			case 0xe3: // STOP
			case 0xec: // GOTO
			case 0xf2: // PAUSE
				return true;
			case 0xf5: // PRINT
				if (!Print())
					return false;
				break;
			case 0xf1: // LET
				if (!Let())
					return false;
				break;
			case 0xfa: // IF
				if (!DoIf())
					return false;
				break;
			case 0xeb: // FOR
				if (!DoFor())
					return false;
				break;
			case 0xf4: // POKE
				if (!Poke())
					return false;
				break;
			case 0xf3: // NEXT
				if (!Next())
					return false;
				break;
			default:
				return false;
			}
			if (ReadByte() != 0x76)
				return false;
		}
	}
}

abstract class GtiaRenderer
{
	internal byte[4] PlayerHpos;
	internal byte[4] MissileHpos;
	internal byte[4] PlayerSize;
	internal byte[4] MissileSize;
	byte[4] PlayerSizeCounter;
	byte[4] MissileSizeCounter;
	internal byte[4] PlayerGraphics;
	internal int MissileGraphics; // byte
	byte[4] PlayerShiftRegister;
	int MissileShiftRegister; // byte
	internal byte[9] Colors;
	internal int Prior;

	internal void SetPlayerSize!(int i, int size)
	{
		size &= 3;
		PlayerSize[i] = size == 2 ? 1 : size + 1;
	}

	internal static void SetSpriteSizes(byte[]! sizes, int value)
	{
		for (int i = 0; i < 4; i++) {
			int size = value >> (i << 1) & 3;
			sizes[i] = size == 2 ? 1 : size + 1;
		}
	}

	internal void Poke!(int addr, int value)
	{
		switch (addr) {
		case 0x00:
		case 0x01:
		case 0x02:
		case 0x03:
			PlayerHpos[addr] = value;
			break;
		case 0x04:
		case 0x05:
		case 0x06:
		case 0x07:
			MissileHpos[addr - 4] = value;
			break;
		case 0x08:
		case 0x09:
		case 0x0a:
		case 0x0b:
			SetPlayerSize(addr - 8, value);
			break;
		case 0x0c:
			SetSpriteSizes(MissileSize, value);
			break;
		case 0x0d:
		case 0x0e:
		case 0x0f:
		case 0x10:
			PlayerGraphics[addr - 0xd] = value;
			break;
		case 0x11:
			MissileGraphics = value;
			break;
		case 0x12:
		case 0x13:
		case 0x14:
		case 0x15:
		case 0x16:
		case 0x17:
		case 0x18:
		case 0x19:
		case 0x1a:
			Colors[addr - 0x12] = value & 0xfe;
			break;
		case 0x1b:
			Prior = value;
			break;
		default:
			break;
		}
	}

	internal void ProcessSpriteDma!(byte[] content, int missileOffset)
	{
		MissileGraphics = content[missileOffset];
		for (int i = 0; i < 4; i++)
			PlayerGraphics[i] = content[missileOffset + (1 + i << 8)];
	}

	const int P0   = 0x01;
	const int P1   = 0x02;
	const int P01  = P0 | P1;
	const int P2   = 0x04;
	const int P3   = 0x08;
	const int P23  = P2 | P3;
	const int PF0  = 0x10;
	const int PF1  = 0x20;
	const int PF01 = PF0 | PF1;
	const int PF2  = 0x40;
	const int PF3  = 0x80;
	const int PF23 = PF2 | PF3;

	int GetPmg!(int hpos, int objects)
	{
		for (int i = 0; i < 4; i++) {
			if (PlayerHpos[i] == hpos) {
				PlayerShiftRegister[i] |= PlayerGraphics[i];
				PlayerSizeCounter[i] = PlayerSize[i];
			}
			if (MissileHpos[i] == hpos) {
				MissileShiftRegister |= MissileGraphics & 3 << (i << 1);
				MissileSizeCounter[i] = MissileSize[i];
			}
		}

		if ((Prior & 0x10) != 0 && (MissileShiftRegister & 0xaa) != 0)
			objects |= PF3;
		for (int i = 0; i < 4; i++) {
			if ((PlayerShiftRegister[i] & 0x80) != 0
			 || ((Prior & 0x10) == 0 && (MissileShiftRegister & 2 << (i << 1)) != 0))
				objects |= 1 << i;

			if (--PlayerSizeCounter[i] == 0) {
				PlayerShiftRegister[i] = (PlayerShiftRegister[i] << 1) & 0xff;
				PlayerSizeCounter[i] = PlayerSize[i];
			}

			if (--MissileSizeCounter[i] == 0) {
				int mask = 1 << (i << 1);
				MissileShiftRegister = (MissileShiftRegister & ~(mask * 3)) | ((MissileShiftRegister & mask) << 1);
				MissileSizeCounter[i] = MissileSize[i];
			}
		}
		return objects;
	}

	int GetColor(int objects)
	{
		if (objects == 0)
			return Colors[8]; // COLBAK
		int prior = Prior;
		int color = 0;
		if ((objects & P01) != 0) {
			if (((objects & PF01) == 0 || (prior & 0xc) == 0)
			&& ((objects & PF23) == 0 || (prior & 4) == 0)) {
				if ((objects & P0) != 0) {
					color = Colors[0]; // COLPM0
					if ((objects & P1) != 0 && (prior & 0x20) != 0)
						color |= Colors[1]; // COLPM1
				}
				else
					color = Colors[1]; // COLPM1
			}
		}
		else if ((objects & P23) != 0) {
			if (((objects & PF23) == 0 || (prior & 6) == 0)
			 && ((objects & PF01) == 0 || (prior & 1) != 0)) {
				if ((objects & P2) != 0) {
					color = Colors[2]; // COLPM2
					if ((objects & P3) != 0 && (prior & 0x20) != 0)
						color |= Colors[3]; // COLPM3
				}
				else
					color = Colors[3]; // COLPM3
			}
		}
		if ((objects & PF23) != 0
		 && ((objects & P23) == 0 || (prior & 9) == 0)
		 && ((objects & P01) == 0 || (prior & 4) != 0)) {
			// fifth player (PF3) has priority over the other playfields
			return color | Colors[(objects & PF3) != 0 ? 7 : 6]; // COLPF3, COLPF2
		}
		if ((objects & PF01) != 0
		 && ((objects & P23) == 0 || (prior & 1) == 0)
		 && ((objects & P01) == 0 || (prior & 3) == 0)) {
			// PF0 and PF1 are mutually exclusive
			return color | Colors[(objects & PF0) != 0 ? 4 : 5]; // COLPF0, COLPF1
		}
		return color;
	}

	internal void StartLine!(int startHpos)
	{
		PlayerShiftRegister.Fill(0);
		MissileShiftRegister = 0;
		// We need to start processing PMG on the left border.
		// The leftmost PMG we can see is a quad-sized player.
		for (int hpos = startHpos - 31; hpos < startHpos; hpos++)
			GetPmg(hpos, 0);
	}

	internal byte[] Content;
	internal int PlayfieldColumns;

	protected virtual int GetHiresColor(int c)
		=> (c & 0xf0) + (Colors[5] & 0xe);

	/// Fetches playfield data at the given location.
	/// Returns playfield byte, plus bit 8 for character code bit 7 ("inverse").
	protected abstract int GetPlayfieldByte!(int y, int column);

	internal int DrawSpan!(int y, int hpos, int untilHpos, AnticMode anticMode, byte[]! frame, int width)
	{
		int gtiaMode = Prior >> 6;
		for (; hpos < untilHpos; hpos++) {
			int x = hpos;
			int objects = 0;
			int playfield = 0;
			if (gtiaMode == 2) {
				// GTIA 10
				x--; // shifted right half a pixel
				objects = P0; // border is COLPM0
			}

			if (anticMode != AnticMode.Blank) {
				int column = (x >> 2) + (PlayfieldColumns >> 1) - 32;
				if (column >= 0 && column < PlayfieldColumns) {
					// fetch playfield
					playfield = GetPlayfieldByte(y, column);
					bool inverseChar = playfield >= 0x100;
					if (inverseChar && anticMode == AnticMode.HiRes)
						playfield = 0x1ff - playfield; // TODO: bitmap mode
					if (gtiaMode == 0) {
						playfield = playfield >> ((~x & 3) << 1) & 3;
						objects = anticMode == AnticMode.HiRes ? PF2 :
							anticMode == AnticMode.FiveColor && playfield == 3 && inverseChar ? PF3 :
							8 << playfield & 0x70;
					}
					else {
						// GTIA mode
						// TODO: AnticMode.FiveColor
						if ((x & 2) == 0)
							playfield >>= 4;
						playfield &= 0xf;
						if (gtiaMode == 2) {
							const byte[16] gtia10Objects = { P0, P1, P2, P3, PF0, PF1, PF2, PF3, 0, 0, 0, 0, PF0, PF1, PF2, PF3 };
							objects = gtia10Objects[playfield];
						}
					}
				}
			}

			// add sprites, apply priority logic
			objects = GetPmg(hpos, objects);
			int c = GetColor(objects);

			// set pixels, adding hires or GTIA 9/11 pixels if needed
			int frameOffset = y * width + (hpos + (width >> 2) - 128 << 1);
			switch (gtiaMode) {
			case 0:
				if (anticMode != AnticMode.HiRes)
					break;
				frame[frameOffset] = (playfield & 2) == 0 ? c : GetHiresColor(c);
				frame[frameOffset + 1] = (playfield & 1) == 0 ? c : GetHiresColor(c);
				continue; // pixels already written
			case 2: // GTIA 10
				break;
			default:
				if ((objects & (P01 | P23)) != 0)
					break; // players cover GTIA 9/11, even when fifth player is on top
				assert objects == 0 || objects == PF3;
				if (gtiaMode == 1) // GTIA 9
					c |= playfield;
				else if (playfield == 0) // GTIA 11 background
					c &= 0xf0;
				else // GTIA 11
					c |= playfield << 4;
				break;
			}
			frame[frameOffset + 1] = frame[frameOffset] = c;
		}
		return hpos;
	}

	internal void SetG2fColors!(int contentOffset, int contentStride, int count, int gtiaMode)
	{
		const byte[9] normalRegisters = { 8, 4, 5, 6, 7, 0, 1, 2, 3 };
		for (int i = 0; i < count; i++)
			Colors[(gtiaMode & 0xc0) == 0x80 ? i : normalRegisters[i]] = Content[contentOffset + i * contentStride] & 0xfe;
	}
}

class HcmRenderer : GtiaRenderer
{
	protected override int GetPlayfieldByte!(int y, int column)
		=> Content[0x810 + (y << 5) + column];
}

class GedRenderer : GtiaRenderer
{
	protected override int GetPlayfieldByte!(int y, int column)
		=> Content[0xce6 + y * 40 + column];
}

class PgrRenderer : GtiaRenderer
{
	internal int ScreenOffset;

	protected override int GetPlayfieldByte!(int y, int column)
		=> Content[ScreenOffset + column];
}

class MchRenderer : GtiaRenderer
{
	internal bool DliPlus;

	protected override int GetPlayfieldByte!(int y, int column)
	{
		int offset = ((y >> 3) * PlayfieldColumns + column) * 9;
		int shift = DliPlus && (y & 4) != 0 ? 2 : 1;
		return (Content[offset] << shift & 0x100) | Content[offset + 1 + (y & 7)];
	}
}

class G2fRenderer : GtiaRenderer
{
	internal int FontOffset;
	internal int Inverse2Offset;
	internal int VbxeOffset;

	protected override int GetHiresColor(int c)
		=> VbxeOffset >= 0 ? Colors[5] : (c & 0xf0) + (Colors[5] & 0xe);

	protected override int GetPlayfieldByte!(int y, int column)
	{
		if (VbxeOffset >= 0) {
			int colorOffset = VbxeOffset + 3 + ((24 - (PlayfieldColumns >> 1) + column) * 240 + y / Content[VbxeOffset + 2]) * 12 + 2;
			Colors[4] = Content[colorOffset]; // PF0
			Colors[5] = Content[colorOffset + 2]; // PF1
			Colors[6] = Content[colorOffset + 4]; // PF2
		}
		int charOffset = (y >> 3) * PlayfieldColumns + column;
		int ch = Content[3 + charOffset];
		int inverse = Inverse2Offset >= 0 && (y & 4) != 0 ? Content[Inverse2Offset + charOffset] : ch;
		return (inverse & 0x80) << 1 | Content[FontOffset + ((ch & 0x7f) << 3) + (y & 7)];
	}

	internal static bool SetSprite(byte[]! hpos, byte[]! sizes, int i, byte[] content, int spriteOffset)
	{
		spriteOffset += i << 10;
		int value = content[spriteOffset + 1];
		if (value >= 0x80) {
			hpos[i] = 0;
			return true;
		}
		value &= 15;
		switch (value) {
		case 0:
			value = 1;
			break;
		case 1:
		case 2:
		case 4:
			break;
		default:
			return false;
		}
		sizes[i] = value;
		hpos[i] = (0x20 + content[spriteOffset]) & 0xff;
		return true;
	}

}

class InflateStream : Stream
{
	int Bits;

	int ReadBit!()
	{
		if (Bits <= 1) {
			if (ContentOffset >= ContentLength)
				return -1;
			Bits = Content[ContentOffset++] | 0x100;
		}
		int result = Bits & 1;
		Bits >>= 1;
		return result;
	}

	int ReadBits!(int count)
	{
		int result = 0;
		for (int rank = 0; rank < count; rank++) {
			switch (ReadBit()) {
			case -1:
				return -1;
			case 1:
				result |= 1 << rank;
				break;
			default:
				break;
			}
		}
		return result;
	}

	const int PrimarySymbols = 256 + 1 + 29 + 2;
	const int DistanceSymbols = 30;
	const int AllSymbols = PrimarySymbols + DistanceSymbols;
	byte[AllSymbols] SymbolCodeLength;

	const int TreeSize = 16;
	const int PrimaryTree = 0;
	const int DistanceTree = TreeSize;
	int[2 * TreeSize] NBitCodeCount;
	int[2 * TreeSize] NBitCodeOffset;
	short[AllSymbols] CodeToSymbol;

	void BuildHuffmanTrees!()
	{
		NBitCodeCount.Fill(0);
		for (int i = 0; i < AllSymbols; i++)
			NBitCodeCount[SymbolCodeLength[i]]++;
		int offset = 0;
		for (int i = 0; i < 2 * TreeSize; i++) {
			NBitCodeOffset[i] = offset;
			offset += NBitCodeCount[i];
		}
		for (int i = 0; i < AllSymbols; i++)
			CodeToSymbol[NBitCodeOffset[SymbolCodeLength[i]]++] = i;
	}

	int FetchCode!(int tree)
	{
		int code = 0;
		do {
			int bit = ReadBit();
			if (bit < 0)
				return -1;
			code = (code << 1) + bit - NBitCodeCount[++tree];
			if (code < 0)
				return CodeToSymbol[NBitCodeOffset[tree] + code];
		} while ((tree & 0xf) != 0xf);
		return -1;
	}

	int Inflate!(byte[]! unpacked, int unpackedLength)
	{
		int unpackedOffset = 0;
		Bits = 0;

		int lastBlock;
		do {
			lastBlock = ReadBit();
			int count;
			switch (ReadBits(2)) {
			case 0:
				Bits = 0;
				count = ReadBits(16);
				if (ReadBits(16) != (count ^ 0xffff))
					return -1;
				if (count > unpackedLength - unpackedOffset)
					count = unpackedLength - unpackedOffset;
				if (!ReadBytes(unpacked, unpackedOffset, count))
					return -1;
				unpackedOffset += count;
				if (unpackedOffset == unpackedLength)
					return unpackedOffset;
				continue;

			case 1:
				for (int i = 0; i < 144; i++)
					SymbolCodeLength[i] = 8;
				for (int i = 144; i < 256; i++)
					SymbolCodeLength[i] = 9;
				for (int i = 256; i < 280; i++)
					SymbolCodeLength[i] = 7;
				for (int i = 280; i < 288; i++)
					SymbolCodeLength[i] = 8;
				for (int i = 288; i < 288 + DistanceSymbols; i++)
					SymbolCodeLength[i] = DistanceTree + 5;
				break;

			case 2:
				int primaryCodes = 257 + ReadBits(5);
				int codes = PrimarySymbols + 1 + ReadBits(5);
				if (codes > AllSymbols)
					return -1;
				int temporaryCodes = ReadBits(4);
				if (temporaryCodes < 0)
					return -1;
				temporaryCodes += 4;
				SymbolCodeLength.Fill(0);
				for (int i = 0; i < temporaryCodes; i++) {
					int bits = ReadBits(3);
					if (bits < 0)
						return -1;
					const byte[] tempSymbols = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };
					SymbolCodeLength[tempSymbols[i]] = bits;
				}
				BuildHuffmanTrees();
				int length = 0;
				count = 1;
				for (int i = 0; i < codes; i++) {
					if (--count == 0) {
						int symbol = FetchCode(PrimaryTree);
						switch (symbol) {
						case -1:
							return -1;
						case 16:
							count = ReadBits(2);
							if (count < 0)
								return -1;
							count += 3;
							break;
						case 17:
							length = 0;
							count = ReadBits(3);
							if (count < 0)
								return -1;
							count += 3;
							break;
						case 18:
							length = 0;
							count = ReadBits(7);
							if (count < 0)
								return -1;
							count += 11;
							break;
						default:
							length = symbol;
							count = 1;
							break;
						}
					}
					if (i == primaryCodes)
						i = PrimarySymbols;
					SymbolCodeLength[i] = i < PrimarySymbols ? length : DistanceTree + length;
				}
				break;

			default:
				return -1;
			}

			BuildHuffmanTrees();
			for (;;) {
				int symbol = FetchCode(PrimaryTree);
				if (symbol < 0)
					return -1;
				else if (symbol < 256)
					unpacked[unpackedOffset++] = symbol;
				else if (symbol == 256)
					break;
				else {
					switch (symbol) {
					case 257:
					case 258:
					case 259:
					case 260:
					case 261:
					case 262:
					case 263:
					case 264:
						count = symbol - 254;
						break;
					case 285:
						count = 258;
						break;
					case 286:
					case 287:
						return -1;
					default:
						symbol -= 261;
						count = ReadBits(symbol >> 2);
						if (count < 0)
							return -1;
						count += (4 + (symbol & 3) << (symbol >> 2)) + 3;
						break;
					}

					symbol = FetchCode(DistanceTree);
					int distance;
					switch (symbol) {
					case -1:
						return -1;
					case PrimarySymbols:
					case PrimarySymbols + 1:
					case PrimarySymbols + 2:
					case PrimarySymbols + 3:
						distance = symbol - (PrimarySymbols - 1);
						break;
					default:
						symbol -= PrimarySymbols + 2;
						distance = ReadBits(symbol >> 1);
						if (distance < 0)
							return -1;
						distance += (2 + (symbol & 1) << (symbol >> 1)) + 1;
						break;
					}

					if (count > unpackedLength - unpackedOffset)
						count = unpackedLength - unpackedOffset;
					if (!RECOIL.CopyPrevious(unpacked, unpackedOffset, distance, count))
						return -1;
					unpackedOffset += count;
				}
				if (unpackedOffset == unpackedLength)
					return unpackedOffset;
			}
		} while (lastBlock == 0);
		return unpackedOffset;
	}

	internal int Uncompress!(byte[]! unpacked, int unpackedLength)
	{
		// bits 0 to 3: Compression method (must be Z_DEFLATED)
		// bits 4 to 7: Compression info (must be <= 7)
		int b0 = ReadByte();
		if ((b0 & 0x8f) != 8)
			return -1;

		// bits 0 to 4: Check bits
		// bit 5:       Preset dictionary (not supported)
		// bits 6 to 7: Compression level
		int b1 = ReadByte();
		if ((b1 & 0x20) != 0 || (b0 << 8 | b1) % 31 != 0)
			return -1;

		return Inflate(unpacked, unpackedLength);
	}
}

/// Decoder of images in formats native to vintage computers.
/// Decodes file contents passed as a byte array
/// into a 24-bit RGB bitmap.
public class RECOIL
{
	/// RECOIL version - major part.
	public const int VersionMajor = 6;
	/// RECOIL version - minor part.
	public const int VersionMinor = 1;
	/// RECOIL version - micro part.
	public const int VersionMicro = 1;
	/// RECOIL version as a string.
	public const string Version = $"{VersionMajor}.{VersionMinor}.{VersionMicro}";

	/// Years RECOIL was created in.
	public const string Years = "2009-2021";

	/// Short credits for RECOIL.
	public const string Credits = $"Retro Computer Image Library (C) {Years} Piotr Fusik\n";

	/// Short license notice.
	/// Display after the credits.
	public const string Copyright =
		"This program is free software; you can redistribute it and/or modify it " +
		"under the terms of the GNU General Public License as published " +
		"by the Free Software Foundation; either version 2 of the License, " +
		"or (at your option) any later version.";

	/// Constructs a decoder of images.
	/// The decoder can be used for several images, one after another.
	public RECOIL()
	{
		SetNtsc(false);
	}

	/// Maximum length of a supported platform palette file.
	// Largest VPL included with VICE 3.5 is 3112 bytes.
	public const int MaxPlatformPaletteContentLength = 32768;

	/// Maximum number of pixels in a decoded image.
	const int MaxPixelsLength = 128 * 1024 * 1024;

	/// Decoded image width.
	int Width;

	/// Decoded image height.
	int Height;

	/// Decoded image pixels as 0xRRGGBB.
	int[]# Pixels;

	/// Length of the currently allocated `Pixels`.
	int PixelsLength = 0;

	/// Platform and pixel ratio.
	RECOILResolution Resolution;

	/// Number of frames (normally 1; 2 or 3 for flickering pictures).
	int Frames;

	/// `true` if NTSC is preferred over PAL.
	bool Ntsc;

	int[16] C64Palette;

	int[256] Atari8Palette;

	int LeftSkip;

	/// Maximum length of a string returned by `GetPlatform()`.
	public const int MaxPlatformLength = "TRS-80 Color Computer".Length;

	/// Selects the PAL/NTSC video standard for applicable platforms.
	/// Resets all platform palettes loaded with `SetPlatformPalette` to default.
	public void SetNtsc!(
		/// `true` for NTSC, `false` for PAL
		bool ntsc)
	{
		Ntsc = ntsc;

		C64Palette[0] = 0x000000;
		C64Palette[1] = 0xffffff;
		C64Palette[2] = 0x68372b;
		C64Palette[3] = 0x70a4b2;
		C64Palette[4] = 0x6f3d86;
		C64Palette[5] = 0x588d43;
		C64Palette[6] = 0x352879;
		C64Palette[7] = 0xb8c76f;
		C64Palette[8] = 0x6f4f25;
		C64Palette[9] = 0x433900;
		C64Palette[10] = 0x9a6759;
		C64Palette[11] = 0x444444;
		C64Palette[12] = 0x6c6c6c;
		C64Palette[13] = 0x9ad284;
		C64Palette[14] = 0x6c5eb5;
		C64Palette[15] = 0x959595;

		DecodeR8G8B8Colors(Ntsc ? resource<byte[]>("altirrantsc.pal") : resource<byte[]>("altirrapal.pal"), 0, 256, Atari8Palette, 0);
	}

	/// Returns `true` if NTSC video standard is selected.
	public bool IsNtsc() => Ntsc;

	static int PackExt(string ext)
		=> ext.Length == 0 || ext.Length > 4 ? 0
			: ext[0] + (ext.Length >= 2 ? ext[1] << 8 : 0) + (ext.Length >= 3 ? ext[2] << 16 : 0) + (ext.Length >= 4 ? ext[3] << 24 : 0) | 0x20202020;

	static int GetPackedExt(string filename)
	{
		int ext = 0;
		for (int i = filename.Length; --i >= 0; ) {
			int c = filename[i];
			if (c == '.')
				return ext | 0x20202020;
			if (c <= ' ' || c > 'z' || ext >= 1 << 24)
				return 0;
			ext = (ext << 8) + c;
		}
		return 0;
	}

	/// Sets a custom platform palette.
	///
	/// * 768-byte `ACT`/`PAL` file with an Atari 8-bit palette
	/// * `VPL` VICE Palette file with a C64 palette
	///
	/// Returns `true` on success.
	public bool SetPlatformPalette!(
		/// Name of the file to decode. Only the extension is processed, for format recognition.
		string filename,
		/// File contents.
		byte[] content,
		/// File length.
		int contentLength)
	{
		switch (GetPackedExt(filename)) {
		case PackExt("ACT"):
		case PackExt("PAL"):
			if (contentLength != 768)
				return false;
			DecodeR8G8B8Colors(content, 0, 256, Atari8Palette, 0);
			return true;
		case PackExt("VPL"):
			VplStream() vpl;
			vpl.Content = content;
			vpl.ContentOffset = 0;
			vpl.ContentLength = contentLength;
			switch (vpl.Decode()) {
			case 16:
				vpl.CopyTo(C64Palette, 16);
				return true;
			// TODO: C16
			default:
				return false;
			}
		default:
			return false;
		}
	}

	/// Initializes decoded image size and resolution.
	bool SetSize!(int width, int height, RECOILResolution resolution, int frames = 1)
	{
		if (width <= 0 || height <= 0 || height > MaxPixelsLength / width / frames)
			return false;
		Width = width;
		Height = height;
		Resolution = resolution;
		Frames = frames;
		Colors = UnknownColors;
		LeftSkip = 0;
		int pixelsLength = width * height * frames;
		// reuse if enough
		if (PixelsLength < pixelsLength) {
			Pixels = null; // free first
			Pixels = new int[pixelsLength];
			PixelsLength = pixelsLength;
		}
		return true;
	}

	bool SetSizeStOrFalcon!(int width, int height, int bitplanes, bool squarePixels)
	{
		RECOILResolution resolution = RECOILResolution.Falcon1x1;
		switch (bitplanes) {
		case 1:
			if (width <= 640 && height <= 400)
				resolution = RECOILResolution.St1x1;
			break;
		case 2:
			if (!squarePixels && width == 640 && height == 200) {
				height <<= 1;
				resolution = RECOILResolution.Ste1x2;
			}
			break;
		case 4:
			if (width <= 320 && height <= 200)
				resolution = RECOILResolution.Ste1x1;
			break;
		case 8:
			if (!squarePixels && width == 320 && height == 480) {
				width <<= 1;
				resolution = RECOILResolution.Tt2x1;
			}
			break;
		default:
			break;
		}
		return SetSize(width, height, resolution);
	}

	bool SetScaledSize!(int width, int height, RECOILResolution resolution)
	{
		switch (resolution) {
		case RECOILResolution.Amiga2x1:
		case RECOILResolution.Falcon2x1:
		case RECOILResolution.Msx22x1i:
		case RECOILResolution.Msx2Plus2x1i:
			width <<= 1;
			break;
		case RECOILResolution.Amiga4x1:
			width <<= 2;
			break;
		case RECOILResolution.Amiga8x1:
			width <<= 3;
			break;
		case RECOILResolution.Amiga1x2:
		case RECOILResolution.AmigaDctv1x2:
		case RECOILResolution.St1x2:
		case RECOILResolution.Ste1x2:
		case RECOILResolution.Msx21x2:
		case RECOILResolution.Pc801x2:
		case RECOILResolution.Pc881x2:
			height <<= 1;
			break;
		case RECOILResolution.Amiga1x4:
			height <<= 2;
			break;
		default:
			break;
		}
		return SetSize(width, height, resolution);
	}

	void SetScaledPixel!(int x, int y, int rgb)
	{
		int offset = y * Width;
		switch (Resolution) {
		case RECOILResolution.Amiga2x1:
		case RECOILResolution.AmigaHame2x1:
		case RECOILResolution.Tt2x1:
		case RECOILResolution.Falcon2x1:
		case RECOILResolution.Msx22x1i:
		case RECOILResolution.Msx2Plus2x1i:
			offset += x << 1;
			Pixels[offset + 1] = Pixels[offset] = rgb;
			break;
		case RECOILResolution.Amiga4x1:
			offset += x << 2;
			Pixels[offset + 3] = Pixels[offset + 2] = Pixels[offset + 1] = Pixels[offset] = rgb;
			break;
		case RECOILResolution.Amiga8x1:
			offset += x << 3;
			for (x = 0; x < 8; x++)
				Pixels[offset + x] = rgb;
			break;
		case RECOILResolution.Amiga1x2:
		case RECOILResolution.AmigaDctv1x2:
		case RECOILResolution.AppleIIGS1x2:
		case RECOILResolution.St1x2:
		case RECOILResolution.Ste1x2:
		case RECOILResolution.Pc801x2:
		case RECOILResolution.Pc881x2:
		case RECOILResolution.Msx21x2:
		case RECOILResolution.SamCoupe1x2:
		case RECOILResolution.Trs1x2:
			offset = (offset << 1) + x;
			Pixels[offset + Width] = Pixels[offset] = rgb;
			break;
		case RECOILResolution.Amiga1x4:
			offset = (offset << 2) + x;
			Pixels[offset + Width * 3] = Pixels[offset + Width * 2] = Pixels[offset + Width] = Pixels[offset] = rgb;
			break;
		default:
			Pixels[offset + x] = rgb;
			break;
		}
	}

	/// Reads a 32-bit big endian integer from a byte array.
	internal static int Get32BigEndian(byte[] content, int contentOffset)
	{
		return content[contentOffset] << 24
			| content[contentOffset + 1] << 16
			| content[contentOffset + 2] << 8
			| content[contentOffset + 3];
	}

	/// Reads a 32-bit little endian integer from a byte array.
	internal static int Get32LittleEndian(byte[] content, int contentOffset)
	{
		return content[contentOffset]
			| content[contentOffset + 1] << 8
			| content[contentOffset + 2] << 16
			| content[contentOffset + 3] << 24;
	}

	internal static int GetNibble(byte[] content, int contentOffset, int index)
	{
		int b = content[contentOffset + (index >> 1)];
		return (index & 1) == 0 ? b >> 4 : b & 0xf;
	}

	internal static bool IsStringAt(byte[] content, int contentOffset, string s)
	{
		int length = s.Length;
		for (int i = 0; i < length; i++)
			if (content[contentOffset + i] != s[i])
				return false;
		return true;
	}

	internal static bool CopyPrevious(byte[]! unpacked, int unpackedOffset, int distance, int count)
	{
		if (distance > unpackedOffset)
			return false;
		do {
			unpacked[unpackedOffset] = unpacked[unpackedOffset - distance];
			unpackedOffset++;
		} while (--count > 0);
		return true;
	}

	bool ApplyBlend!()
	{
		int pixelsLength = Width * Height;
		for (int i = 0; i < pixelsLength; i++) {
			int rgb1 = Pixels[i];
			int rgb2 = Pixels[pixelsLength + i];
			// This clever formula just computes the byte-by-byte averages.
			Pixels[i] = (rgb1 & rgb2) + ((rgb1 ^ rgb2) >> 1 & 0x7f7f7f);
		}
		return true;
	}

	/// Reads a companion file to the specified byte array.
	/// Implement this method in a subclass to enable support for multi-file images.
	/// Returns the number of bytes read (up to `contentLength`) or -1 on error.
	protected virtual int ReadFile(
		/// Name of the file to read.
		string filename,
		/// Out: target for the file contents.
		byte[]! content,
		/// Maximum number of bytes to read.
		int contentLength) => -1;

	int ReadCompanionFile(string baseFilename, string upperExt, string lowerExt, byte[]! content, int contentLength)
	{
		int i = baseFilename.Length;
		bool lower = false;
		for (;;) {
			int c = baseFilename[--i];
			if (c >= 'a')
				lower = true;
			else if (c == '.')
				break;
		}
		string() filename = baseFilename.Substring(0, i + 1);
		filename += lower ? lowerExt : upperExt;
		return ReadFile(filename, content, contentLength);
	}

	bool DecodeBru!(byte[] content, int contentLength)
	{
		if (contentLength != 64)
			return false;
		SetSize(8, 8, RECOILResolution.St1x1);
		for (int i = 0; i < 64; i++) {
			switch (content[i]) {
			case 0:
				Pixels[i] = 0x000000;
				break;
			case 1:
				Pixels[i] = 0xffffff;
				break;
			default:
				return false;
			}
		}
		return true;
	}

	/// RGB palette decoded from the image file.
	internal int[256] ContentPalette;

	void DecodeBytes!(byte[] content, int contentOffset)
	{
		int width = GetOriginalWidth();
		int height = GetOriginalHeight();
		for (int y = 0; y < height; y++)
			for (int x = 0; x < width; x++)
				SetScaledPixel(x, y, ContentPalette[content[contentOffset + y * width + x]]);
	}

	void DecodeNibbles!(byte[] content, int contentOffset, int contentStride)
	{
		int width = GetOriginalWidth();
		int height = GetOriginalHeight();
		for (int y = 0; y < height; y++)
			for (int x = 0; x < width; x++)
				SetScaledPixel(x, y, ContentPalette[GetNibble(content, contentOffset + y * contentStride, x)]);
	}

	static int GetR8G8B8Color(byte[] content, int contentOffset)
		=> content[contentOffset] << 16 | content[contentOffset + 1] << 8 | content[contentOffset + 2];

	static void DecodeR8G8B8Colors(byte[] content, int contentOffset, int count, int[]! destination, int destinationOffset)
	{
		for (int i = 0; i < count; i++)
			destination[destinationOffset + i] = GetR8G8B8Color(content, contentOffset + i * 3);
	}

	static int GetB5G5R5Color(int c)
	{
		// XBBBBBGG GGGRRRRR
		c = (c & 0x1f) << 19 | (c & 0x3e0) << 6 | (c >> 7 & 0xf8);
		// RRRRR000 GGGGG000 BBBBB000
		return c | (c >> 5 & 0x070707);
	}

	static int GetR5G5B5Color(int c)
	{
		// 0RRRRRGG GGGBBBBB
		c = (c & 0x7c00) << 9 | (c & 0x3e0) << 6 | (c & 0x1f) << 3;
		// RRRRR000 GGGGG000 BBBBB000
		return c | (c >> 5 & 0x070707);
	}

	static int GetG6R5B5Color(int c)
	{
		// GGGGGGRR RRRBBBBB
		c = (c & 0x3e0) << 14 | (c & 0xfc00) | (c & 0x1f) << 3;
		// RRRRR000 GGGGGG00 BBBBB000
		return c | (c >> 5 & 0x070007) | (c >> 6 & 0x000300);
	}

	static int Get729Color(int c)
	{
		int r = c / 81;
		int g = c / 9 % 9;
		int b = c % 9;
		return r * 255 >> 3 << 16 | g * 255 >> 3 << 8 | b * 255 >> 3;
	}

	internal static int GetFalconTrueColor(byte[] content, int contentOffset)
	{
		int rg = content[contentOffset]; // RRRRRGGG
		int gb = content[contentOffset + 1]; // GGGBBBBB
		int rgb = (rg & 0xf8) << 16 | (rg & 7) << 13 | (gb & 0xe0) << 5 | (gb & 0x1f) << 3;
		// RRRRR000 GGGGGG00 BBBBB000
		rgb |= (rgb >> 5 & 0x070007) | (rgb >> 6 & 0x000300);
		return rgb;
	}

	static int GetBitplanePixel(byte[] content, int contentOffset, int x, int bitplanes, int bytesPerBitplane)
	{
		int bit = ~x & 7;
		int c = 0;
		for (int bitplane = bitplanes; --bitplane >= 0; )
			c = c << 1 | (content[contentOffset + bitplane * bytesPerBitplane] >> bit & 1);
		return c;
	}

	bool DecodeAmigaPlanar!(byte[] content, int contentOffset, int width, int height, RECOILResolution resolution, int bitplanes, int[] palette)
	{
		if (!SetScaledSize(width, height, resolution))
			return false;
		int bytesPerLine = width + 15 >> 4 << 1;
		int bitplaneLength = height * bytesPerLine;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				int c = GetBitplanePixel(content, contentOffset + y * bytesPerLine + (x >> 3), x, bitplanes, bitplaneLength);
				SetScaledPixel(x, y, palette[c]);
			}
		}
		return true;
	}

	static int GetBitplaneWordsPixel(byte[] content, int contentOffset, int x, int bitplanes)
		=> GetBitplanePixel(content, contentOffset + (x >> 3 & ~1) * bitplanes + (x >> 3 & 1), x, bitplanes, 2);

	/// Decodes Atari ST/Falcon interleaved bitplanes.
	/// Each 16 pixels are encoded in N consecutive 16-bit words.
	void DecodeBitplanes!(byte[] content, int contentOffset, int contentStride, int bitplanes, int pixelsOffset, int width, int height)
	{
		while (--height >= 0) {
			for (int x = 0; x < width; x++) {
				int c = GetBitplaneWordsPixel(content, contentOffset, x, bitplanes);
				Pixels[pixelsOffset + x] = ContentPalette[c];
			}
			contentOffset += contentStride;
			pixelsOffset += Width;
		}
	}

	void DecodeScaledBitplanes!(byte[] content, int contentOffset, int width, int height, int bitplanes, bool ehb, MultiPalette! multiPalette)
	{
		int contentStride = (width + 15 >> 4 << 1) * bitplanes;
		for (int y = 0; y < height; y++) {
			if (multiPalette != null)
				multiPalette.SetLinePalette(this, y);
			if (ehb) {
				for (int c = 0; c < 32; c++)
					ContentPalette[32 + c] = ContentPalette[c] >> 1 & 0x7f7f7f;
			}
			for (int x = 0; x < width; x++) {
				int c = GetBitplaneWordsPixel(content, contentOffset, x, bitplanes);
				SetScaledPixel(x, y, ContentPalette[c]);
			}
			contentOffset += contentStride;
		}
	}

	bool DecodeMono!(byte[] content, int contentOffset, int contentLength, bool wordAlign)
	{
		int contentStride = Width + 7 >> 3;
		if (wordAlign)
			contentStride += contentStride & 1;
		if (contentLength != contentOffset + contentStride * Height)
			return false;
		DecodeBitplanes(content, contentOffset, contentStride, 1, 0, Width, Height);
		return true;
	}

	bool DecodeBlackAndWhite!(byte[] content, int contentOffset, int contentLength, bool wordAlign, int backgroundColor)
	{
		ContentPalette[0] = backgroundColor;
		ContentPalette[1] = backgroundColor ^ 0xffffff;
		return DecodeMono(content, contentOffset, contentLength, wordAlign);
	}

	bool DecodeRleBlackAndWhite!(RleStream! rle, int backgroundColor)
	{
		int width = GetOriginalWidth();
		int height = GetOriginalHeight();
		for (int y = 0; y < height; y++) {
			int b = 0;
			for (int x = 0; x < width; x++) {
				if ((x & 7) == 0) {
					b = rle.ReadRle();
					if (b < 0)
						return false;
				}
				SetScaledPixel(x, y, (b >> (~x & 7) & 1) == 0 ? backgroundColor : backgroundColor ^ 0xffffff);
			}
		}
		return true;
	}

	void DecodeBlackAndWhiteFont!(byte[] content, int contentOffset, int contentLength, int fontHeight)
	{
		for (int y = 0; y < Height; y++) {
			for (int x = 0; x < 256; x++) {
				int row = y % fontHeight;
				int offset = contentOffset + ((y - row) << 5) + (x >> 3) * fontHeight + row;
				int c;
				if (offset < contentLength) {
					c = content[offset] >> (~x & 7) & 1;
					if (c != 0)
						c = 0xffffff;
				}
				else
					c = 0;
				Pixels[(y << 8) + x] = c;
			}
		}
	}

	// Atari Portfolio formats.

	bool DecodePgf!(byte[] content, int contentLength)
	{
		SetSize(240, 64, RECOILResolution.Portfolio1x1);
		return DecodeBlackAndWhite(content, 0, contentLength, false, 0xffffff);
	}

	bool DecodePgc!(byte[] content, int contentLength)
	{
		if (contentLength < 33
		 || content[0] != 'P' || content[1] != 'G' || content[2] != 1)
			return false;
		SetSize(240, 64, RECOILResolution.Portfolio1x1);
		PgcStream() rle;
		rle.Content = content;
		rle.ContentOffset = 3;
		rle.ContentLength = contentLength;
		return DecodeRleBlackAndWhite(rle, 0xffffff);
	}

	// Psion Series 3 formats.

	bool DecodePsion3Pic!(byte[] content, int contentLength)
	{
		if (contentLength < 22
		 || content[0] != 'P' || content[1] != 'I' || content[2] != 'C'
		 || content[3] != 0xdc || content[4] != '0' || content[5] != '0'
		 || (content[6] == 0 && content[7] == 0))
			return false;
		int width = content[10] | content[11] << 8;
		int height = content[12] | content[13] << 8;
		int bitmapLength = content[14] | content[15] << 8;
		int stride = width + 15 >> 4 << 1;
		if (bitmapLength != height * stride)
			return false;
		int bitmapOffset = 20 + RECOIL.Get32LittleEndian(content, 16);
		if (bitmapOffset < 20 || contentLength < bitmapOffset + bitmapLength)
			return false;
		if (!SetSize(width, height, RECOILResolution.Psion31x1))
			return false;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				// low bit first
				Pixels[y * width + x] = (content[bitmapOffset + (x >> 3)] >> (x & 7) & 1) == 0 ? 0xffffff : 0;
			}
			bitmapOffset += stride;
		}
		return true;
	}

	// TRS-80 formats.

	bool DecodeTrsHr!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 19200:
		case 19328: // 128 garbage bytes
		case 19456: // 256 garbage bytes
			break;
		default:
			return false;
		}
		SetSize(640, 480, RECOILResolution.Trs1x2);
		for (int y = 0; y < 240; y++) {
			for (int x = 0; x < 640; x++) {
				int c = content[y * 80 + (x >> 3)] >> (~x & 7) & 1;
				if (c != 0)
					c = 0xffffff;
				int pixelsOffset = y * 1280 + x;
				Pixels[pixelsOffset + 640] = Pixels[pixelsOffset] = c;
			}
		}
		return true;
	}

	bool DecodeTrsShr!(byte[] content, int contentLength)
	{
		SetSize(640, 480, RECOILResolution.Trs1x2);
		PgcStream() rle;
		rle.Content = content;
		rle.ContentOffset = 0;
		rle.ContentLength = contentLength;
		return DecodeRleBlackAndWhite(rle, 0);
	}

	bool DecodeRle!(byte[] content, int contentLength)
	{
		if (contentLength < 520
		 || content[0] != 0x1b || content[1] != 0x47 || content[2] != 0x48)
			return false;
		SetSize(256, 192, RECOILResolution.Trs1x1);
		int count = 0;
		int contentOffset = 3;
		int c = 0xffffff;
		for (int pixelsOffset = 0; pixelsOffset < 256 * 192; pixelsOffset++) {
			while (count == 0) {
				if (contentOffset >= contentLength)
					return false;
				count = content[contentOffset++];
				if (count < 0x20 || count > 0x7f) {
					if (pixelsOffset == 256 * 192 - 1) {
						// last pixel is often missing
						Pixels[pixelsOffset] = c;
						return true;
					}
					return false;
				}
				c ^= 0xffffff;
				count -= 0x20;
			}
			Pixels[pixelsOffset] = c;
			count--;
		}
		return true;
	}

	// TRS-80 Color Computer formats.

	bool DecodeClp!(byte[] content, int contentLength)
	{
		if (contentLength != 306 || content[305] != 0x64)
			return false;
		for (int i = 0; i < 25; i++) {
			const byte[25] header = {
				0x00, 0x00, 0x00, 0x03, 0x01, 0x5e, 0x00, 0x00,
				0x20, 0x00, 0x20, 0x01, 0x01, 0x2c, 0x00, 0x0a,
				0x00, 0x38, 0x00, 0x20, 0x00, 0x38, 0x00, 0x20,
				0x05 };
			if (content[i] != header[i])
				return false;
		}
		SetSize(40, 56, RECOILResolution.Coco1x1);
		return DecodeBlackAndWhite(content, 25, 305, false, 0xffffff);
	}

	bool DecodeCocoMax!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 6154:
		case 6155:
		case 6272:
		case 7168:
			break;
		default:
			return false;
		}
		if (content[0] != 0 || content[1] != 0x18 || content[2] > 1 || content[3] != 0x0e || content[4] != 0)
			return false;
		SetSize(256, 192, RECOILResolution.Coco1x1);
		return DecodeBlackAndWhite(content, 5, 5 + 6144, false, 0);
	}

	bool DecodeP11!(byte[] content, int contentLength)
	{
		if ((contentLength != 3083 && contentLength != 3243)
		 || content[0] != 0 || content[1] != 0x0c || content[3] != 0x0e || content[4] != 0)
			return false;
		SetSize(256, 192, RECOILResolution.Coco2x2);
		for (int y = 0; y < 192; y++) {
			for (int x = 0; x < 256; x++) {
				const int[4] palette = { 0x07ff00, 0xffff00, 0x3b08ff, 0xcc003b };
				int c = content[5 + ((y & ~1) << 4) + (x >> 3)] >> (~x & 6) & 3;
				Pixels[(y << 8) + x] = palette[c];
			}
		}
		return true;
	}

	// Apple Macintosh formats.

	bool DecodeMac!(byte[] content, int contentLength)
	{
		if (contentLength < 512)
			return false;
		int contentOffset = IsStringAt(content, 0x41, "PNTG") ? 128 : 0;
		if (content[contentOffset] != 0 || content[contentOffset + 1] != 0 || content[contentOffset + 2] != 0 || content[contentOffset + 3] > 3)
			return false;
		SetSize(576, 720, RECOILResolution.Macintosh1x1);
		PackBitsStream() rle;
		rle.Content = content;
		rle.ContentOffset = contentOffset + 512;
		rle.ContentLength = contentLength;
		return DecodeRleBlackAndWhite(rle, 0xffffff);
	}

	// PlayStation formats.

	static void DecodePlayStation(byte[] content, int contentOffset, int[]! pixels, int pixelsLength)
	{
		for (int i = 0; i < pixelsLength; i++)
			pixels[i] = GetB5G5R5Color(content[contentOffset + (i << 1)] | content[contentOffset + (i << 1) + 1] << 8);
	}

	int DecodeTimPalette!(byte[] content, int contentLength, int colors)
	{
		if ((content[16] | content[17] << 8) != colors)
			return -1;
		int paletteCount = content[18] | content[19] << 8;
		if (paletteCount == 0)
			return -1;
		int bitmapOffset = 20 + (paletteCount * colors << 1);
		if (Get32LittleEndian(content, 8) != bitmapOffset - 8
		 || contentLength < bitmapOffset + 12)
			return -1;
		int width = (content[bitmapOffset + 8] | content[bitmapOffset + 9] << 8) << 1;
		int height = content[bitmapOffset + 10] | content[bitmapOffset + 11] << 8;
		if (contentLength < bitmapOffset + 12 + width * height)
			return -1;
		if (colors == 16)
			width <<= 1;
		if (!SetSize(width, height, RECOILResolution.PlayStation1x1))
			return -1;
		DecodePlayStation(content, 20, ContentPalette, colors);
		return bitmapOffset + 12;
	}

	bool DecodeTim!(byte[] content, int contentLength)
	{
		if (contentLength < 20 || Get32LittleEndian(content, 0) != 16)
			return false;
		int pixelsLength;
		int bitmapOffset;
		switch (content[4] & 0xf) {
		case 2: // 16bpp
			int width = content[16] | content[17] << 8;
			int height = content[18] | content[19] << 8;
			pixelsLength = width * height;
			if (contentLength < 20 + (pixelsLength << 1)
			 || !SetSize(width, height, RECOILResolution.PlayStation1x1))
				return false;
			DecodePlayStation(content, 20, Pixels, pixelsLength);
			return true;
		case 8: // 4bpp
			bitmapOffset = DecodeTimPalette(content, contentLength, 16);
			if (bitmapOffset < 0)
				return false;
			pixelsLength = Width * Height;
			for (int i = 0; i < pixelsLength; i++) {
				int b = content[bitmapOffset + (i >> 1)];
				Pixels[i] = ContentPalette[(i & 1) == 0 ? b & 0xf : b >> 4];
			}
			return true;
		case 9: // 8bpp
			bitmapOffset = DecodeTimPalette(content, contentLength, 256);
			if (bitmapOffset < 0)
				return false;
			DecodeBytes(content, bitmapOffset);
			return true;
		default:
			return false;
		}
	}

	// BBC micro formats.

	const int[16] BbcPalette = {
		0x000000,
		0xff0000,
		0x00ff00,
		0xffff00,
		0x0000ff,
		0xff00ff,
		0x00ffff,
		0xffffff,
		// Colors 8-15 are flashing with the negative color
		// (e.g. color 9 = color 1 alternated with color 6).
		// We don't support flashing here and just make colors 8-15 identical to 0-7.
		0x000000,
		0xff0000,
		0x00ff00,
		0xffff00,
		0x0000ff,
		0xff00ff,
		0x00ffff,
		0xffffff
	};

	const int[4] BbcPalette2Bit = {
		0x000000,
		0xff0000,
		0xffff00,
		0xffffff
	};

	const int[2] BbcPalette1Bit = {
		0x000000,
		0xffffff
	};

	bool DecodeBb0!(byte[] content, int contentLength, int[] palette)
	{
		if (contentLength != 20480)
			return false;
		SetSize(640, 512, RECOILResolution.Bbc1x2);
		for (int y = 0; y < 256; y++) {
			for (int x = 0; x < 640; x++) {
				int c = content[(y & ~7) * 80 + (x & ~7) + (y & 7)] >> (~x & 7) & 1;
				int pixelsOffset = y * 1280 + x;
				Pixels[pixelsOffset + 640] = Pixels[pixelsOffset] = palette[c];
			}
		}
		return true;
	}

	bool DecodeBb1!(byte[] content, int contentLength, int[] palette)
	{
		if (contentLength != 20480)
			return false;
		SetSize(320, 256, RECOILResolution.Bbc1x1);
		for (int y = 0; y < 256; y++) {
			for (int x = 0; x < 320; x++) {
				int c = content[(y & ~7) * 80 + ((x & ~3) << 1) + (y & 7)] >> (~x & 3);
				Pixels[y * 320 + x] = palette[(c >> 3 & 2) + (c & 1)];
			}
		}
		return true;
	}

	bool DecodeBb2!(byte[] content, int contentLength, int[] palette)
	{
		if (contentLength != 20480)
			return false;
		SetSize(320, 256, RECOILResolution.Bbc2x1);
		for (int y = 0; y < 256; y++) {
			for (int x = 0; x < 160; x++) {
				int c = content[(y & ~7) * 80 + ((x & ~1) << 2) + (y & 7)] >> (~x & 1);
				int pixelsOffset = (y * 160 + x) << 1;
				Pixels[pixelsOffset + 1] = Pixels[pixelsOffset] = palette[(c >> 3 & 8) + (c >> 2 & 4) + (c >> 1 & 2) + (c & 1)];
			}
		}
		return true;
	}

	bool DecodeBb4!(byte[] content, int contentLength, int[] palette)
	{
		if (contentLength != 10240)
			return false;
		SetSize(320, 256, RECOILResolution.Bbc1x1);
		for (int y = 0; y < 256; y++) {
			for (int x = 0; x < 320; x++) {
				int c = content[(y & ~7) * 40 + (x & ~7) + (y & 7)] >> (~x & 7) & 1;
				Pixels[y * 320 + x] = palette[c];
			}
		}
		return true;
	}

	bool DecodeBb5!(byte[] content, int contentLength, int[] palette)
	{
		if (contentLength != 10240)
			return false;
		SetSize(320, 256, RECOILResolution.Bbc2x1);
		for (int y = 0; y < 256; y++) {
			for (int x = 0; x < 160; x++) {
				int c = content[(y & ~7) * 40 + ((x & ~3) << 1) + (y & 7)] >> (~x & 3);
				int pixelsOffset = (y * 160 + x) << 1;
				Pixels[pixelsOffset + 1] = Pixels[pixelsOffset] = palette[(c >> 3 & 2) + (c & 1)];
			}
		}
		return true;
	}

	bool DecodeBbg!(byte[] content, int contentLength)
	{
		BbgStream() rle;
		rle.Content = content;
		rle.ContentOffset = 0;
		rle.ContentLength = contentLength;
		rle.ValueBits = rle.ReadBitsReverse(8);
		if (rle.ValueBits < 1 || rle.ValueBits > 8)
			return false;
		int mode = rle.ReadBitsReverse(8);
		int unpackedLength;
		switch (mode) {
		case 0:
		case 1:
		case 2:
			unpackedLength = 20480;
			break;
		case 4:
		case 5:
			unpackedLength = 10240;
			break;
		default:
			return false;
		}
		for (int i = 15; i >= 0; i--) {
			int c = rle.ReadBitsReverse(4);
			if (c < 0)
				return false;
			ContentPalette[i] = BbcPalette[c];
		}
		int unpackedStep = rle.ReadBitsReverse(8);
		if (unpackedStep <= 0)
			return false;
		rle.CountBits = rle.ReadBitsReverse(8);
		if (rle.CountBits < 1 || rle.CountBits > 8)
			return false;

		byte[20480] unpacked;
		for (int x = unpackedStep - 1; x >= 0; x--) {
			if (!rle.Unpack(unpacked, x, unpackedStep, unpackedLength))
				return false;
		}

		switch (mode) {
		case 0:
			return DecodeBb0(unpacked, unpackedLength, ContentPalette);
		case 1:
			return DecodeBb1(unpacked, unpackedLength, ContentPalette);
		case 2:
			return DecodeBb2(unpacked, unpackedLength, ContentPalette);
		case 4:
			return DecodeBb4(unpacked, unpackedLength, ContentPalette);
		case 5:
			return DecodeBb5(unpacked, unpackedLength, ContentPalette);
		default:
			return false;
		}
	}

	// Oric formats.

	static int GetOricHeader(byte[] content, int contentLength)
	{
		if (contentLength < 26
		 || content[0] != 0x16 || content[1] != 0x16 || content[2] != 0x16 || content[3] != 0x24
		 || content[4] != 0x00 || content[5] != 0x00 || content[6] != 0x80 || content[7] != 0x00
		 || content[12] != 0x00)
			return 0;
		int contentOffset = 13;
		while (content[contentOffset++] != 0) {
			if (contentOffset >= 0x1a)
				return 0;
		}
		return contentOffset;
	}

	bool DecodeChs!(byte[] content, int contentLength)
	{
		int contentOffset = GetOricHeader(content, contentLength);
		switch (contentLength - contentOffset) {
		case 768:
		case 769:
			break;
		default:
			return false;
		}

		SetSize(256, 24, RECOILResolution.Oric1x1);
		DecodeBlackAndWhiteFont(content, contentOffset, contentLength, 8);
		return true;
	}

	bool DecodeHrs!(byte[] content, int contentLength)
	{
		int contentOffset = GetOricHeader(content, contentLength);
		if (contentOffset + 8000 != contentLength)
			return false;

		SetSize(240, 200, RECOILResolution.Oric1x1);
		for (int y = 0; y < 200; y++) {
			int paper = 0;
			int ink = 7;
			for (int col = 0; col < 40; col++) {
				int offset = y * 40 + col;
				int b = content[contentOffset + offset];
				int inverse = b >= 0x80 ? 7 : 0;
				switch (b & 0x78) {
				case 0x00:
					ink = b & 7;
					b = 0;
					break;
				case 0x08:
				case 0x18:
					b = 0;
					break;
				case 0x10:
					paper = b & 7;
					b = 0;
					break;
				default:
					break;
				}
				for (int x = 0; x < 6; x++)
					Pixels[offset * 6 + x] = BbcPalette[((b >> (5 - x) & 1) == 0 ? paper : ink) ^ inverse];
			}
		}
		return true;
	}

	// Amstrad CPC formats.

	static int GetAmstradHeader(byte[] content, int contentLength)
	{
		if (contentLength < 128
		 || (content[0x18] | content[0x19] << 8) != contentLength - 128
		 || content[0x40] != content[0x18] || content[0x41] != content[0x19] || content[0x42] != 0)
			return 0;
		int sum = 0;
		for (int i = 0; i < 67; i++)
			sum += content[i];
		if ((content[0x43] | content[0x44] << 8) != sum)
			return 0;
		return 128;
	}

	bool DecodeAmstradFnt!(byte[] content, int contentLength)
	{
		int contentOffset = GetAmstradHeader(content, contentLength);
		if (contentLength != contentOffset + 768
		 && (contentLength != 896 || contentOffset != 0))
			return false;
		SetSize(256, 24, RECOILResolution.Amstrad1x1);
		DecodeBlackAndWhiteFont(content, contentOffset, contentLength, 8);
		return true;
	}

	bool DecodeAmstradMode2!(byte[] content, int contentOffset, int width, int height)
	{
		SetSize(width, height << 1, RECOILResolution.Amstrad1x2);
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				int offset = (y * width << 1) + x;
				int c = content[contentOffset + ((y & 7) << 11) + ((y >> 3) * width + x >> 3)] >> (~x & 7) & 1;
				Pixels[offset + width] = Pixels[offset] = ContentPalette[c];
			}
		}
		return true;
	}

	bool DecodeHgb!(byte[] content, int contentLength)
	{
		int contentOffset = GetAmstradHeader(content, contentLength);
		if (contentLength != contentOffset + 16384)
			return false;
		ContentPalette[0] = 0;
		ContentPalette[1] = 0xffffff;
		return DecodeAmstradMode2(content, contentOffset, 512, 256);
	}

	const int[32] AmstradPalette = {
		0x808080,
		0x808080,
		0x00ff80,
		0xffff80,
		0x000080,
		0xff0080,
		0x008080,
		0xff8080,
		0xff0080,
		0xffff80,
		0xffff00,
		0xffffff,
		0xff0000,
		0xff00ff,
		0xff8000,
		0xff80ff,
		0x000080,
		0x00ff80,
		0x00ff00,
		0x00ffff,
		0x000000,
		0x0000ff,
		0x008000,
		0x0080ff,
		0x800080,
		0x80ff80,
		0x80ff00,
		0x80ffff,
		0x800000,
		0x8000ff,
		0x808000,
		0x8080ff
	};

	int SetAmstradPalette!(string filename)
	{
		byte[128 + 239 + 1] pal;
		int palLength = ReadCompanionFile(filename, "PAL", "pal", pal, pal.Length);
		int palOffset = GetAmstradHeader(pal, palLength);
		if (palLength != palOffset + 239)
			return -1;
		for (int i = 0; i < 16; i++) {
			int c = pal[palOffset + 3 + i * 12];
			if (c < 0x40 || c > 0x5f)
				return -1;
			ContentPalette[i] = AmstradPalette[c - 0x40];
		}
		return pal[palOffset];
	}

	void DecodeAmstradMode0Line!(byte[] content, int lineOffset, int y)
	{
		int skip = Resolution == RECOILResolution.Amstrad1x1 ? (y ^ (y >= Height ? 1 : 0)) & 1 : 0;
		for (int x = 0; x < Width; x++) {
			int i = x + skip;
			int b = i >= Width ? 0 : content[lineOffset + (i >> 2)];
			// 0b00221133
			if ((i & 2) == 0)
				b >>= 1;
			// 0bX0X2X1X3 -> 0b3210
			Pixels[y * Width + x] = ContentPalette[((b & 1) << 3) + (b >> 2 & 4) + (b >> 1 & 2) + (b >> 6 & 1)];
		}
	}

	void DecodeAmstradMode1Line!(byte[] content, int lineOffset, int y)
	{
		for (int x = 0; x < Width; x++) {
			int b = content[lineOffset + (x >> 2)] >> (~x & 3);
			Pixels[y * Width + x] = ContentPalette[((b & 1) << 1) + (b >> 4 & 1)];
		}
	}

	bool DecodeAmstradScr!(string filename, byte[] content, int contentLength)
	{
		byte[16384] unpacked;
		int contentOffset = GetAmstradHeader(content, contentLength);
		switch (contentLength - contentOffset) {
		case 16336:
		case 16384:
			break;
		default:
			if (!AmstradStream.UnpackFile(content, contentOffset, contentLength, unpacked, unpacked.Length))
				return false;
			content = unpacked;
			contentOffset = 0;
			break;
		}

		switch (SetAmstradPalette(filename)) {
		case 0:
			SetSize(320, 200, RECOILResolution.Amstrad2x1);
			for (int y = 0; y < 200; y++)
				DecodeAmstradMode0Line(content, contentOffset + ((y & 7) << 11) + (y >> 3) * 80, y);
			return true;
		case 1:
			SetSize(320, 200, RECOILResolution.Amstrad1x1);
			for (int y = 0; y < 200; y++)
				DecodeAmstradMode1Line(content, contentOffset + ((y & 7) << 11) + (y >> 3) * 80, y);
			return true;
		case 2:
			return DecodeAmstradMode2(content, contentOffset, 640, 200);
		default:
			return false;
		}
	}

	bool DecodeWin!(string filename, byte[] content, int contentLength)
	{
		if (contentLength < 6)
			return false;
		int width = content[contentLength - 4] | content[contentLength - 3] << 8;
		if (width == 0 || width > 640)
			return false;
		int height = content[contentLength - 2];
		if (height == 0 || height > 200)
			return false;
		int bytesPerLine = width + 7 >> 3;
		byte[16000] unpacked;
		int contentOffset = GetAmstradHeader(content, contentLength);
		if (contentLength != contentOffset + bytesPerLine * height + 5) {
			if (!AmstradStream.UnpackFile(content, contentOffset, contentLength, unpacked, bytesPerLine * height))
				return false;
			content = unpacked;
			contentOffset = 0;
		}

		if (SetAmstradPalette(filename) != 0) // TODO: other modes
			return false;

		width >>= 1;
		SetSize(width, height, RECOILResolution.Amstrad2x1);
		for (int y = 0; y < height; y++)
			DecodeAmstradMode0Line(content, contentOffset + y * bytesPerLine, y);
		return true;
	}

	bool DecodeCm5!(string filename, byte[] content, int contentLength)
	{
		if (contentLength != 2049)
			return false;
		byte[18432 + 1] gfx;
		if (ReadCompanionFile(filename, "GFX", "gfx", gfx, gfx.Length) != 18432)
			return false;
		SetSize(288, 256, RECOILResolution.Amstrad1x1);
		for (int y = 0; y < 256; y++) {
			for (int x = 0; x < 288; x++) {
				int c;
				switch (gfx[y * 72 + (x >> 2)] >> (~x & 3) & 0x11) {
				case 0x00:
					c = 3 + (y << 3) + x / 48;
					break;
				case 0x01:
					c = 1 + (y << 3);
					break;
				case 0x10:
					c = 2 + (y << 3);
					break;
				default:
					c = 0;
					break;
				}
				c = content[c];
				if (c < 0x40 || c > 0x5f)
					return false;
				Pixels[y * 288 + x] = AmstradPalette[c - 0x40];
			}
		}
		return true;
	}

	bool DecodeSgx!(byte[] content, int contentLength)
	{
		int width = 0;
		int height = 0;
		int chunkLeft = 0;
		int rowHeight = 0;
		for (int contentOffset = 0; contentOffset + 3 < contentLength; ) {
			int chunkStride = content[contentOffset];
			if (chunkStride == 0)
				break;
			if (chunkStride == 255) {
				// next row
				if (width == 0)
					width = chunkLeft; // first row
				else if (chunkLeft != width)
					return false; // rows must be of same width
				chunkLeft = 0;
				contentOffset += 3;
			}
			else {
				int chunkWidth;
				int chunkHeight;
				if (chunkStride <= 63) {
					chunkWidth = content[contentOffset + 1];
					if (chunkWidth + 3 >> 2 != chunkStride)
						return false;
					chunkHeight = content[contentOffset + 2];
					contentOffset += 3;
				}
				else if (chunkStride == 64) {
					if (contentOffset + 8 >= contentLength
					 || content[contentOffset + 1] != 5) // TODO: 4-color
						return false;
					chunkStride = content[contentOffset + 2] | content[contentOffset + 3] << 8;
					chunkWidth = content[contentOffset + 4] | content[contentOffset + 5] << 8;
					if (chunkWidth + 1 >> 1 != chunkStride)
						return false;
					chunkHeight = content[contentOffset + 6] | content[contentOffset + 7] << 8;
					contentOffset += 8;
				}
				else
					return false;
				if (chunkLeft == 0)
					height += rowHeight = chunkHeight; // first chunk in row
				else if (chunkHeight != rowHeight)
					return false; // chunks in row must be of same height
				chunkLeft += chunkWidth;
				contentOffset += chunkHeight * chunkStride;
				if (contentOffset > contentLength)
					return false;
			}
		}
		if (width == 0)
			width = chunkLeft;
		else if (chunkLeft != width)
			return false;
		if (!SetSize(width, height, RECOILResolution.Amstrad1x1))
			return false;

		chunkLeft = 0;
		int chunkTop = 0;
		rowHeight = 0;
		for (int contentOffset = 0; contentOffset + 3 < contentLength; ) {
			int chunkStride = content[contentOffset];
			if (chunkStride == 0)
				break;
			if (chunkStride == 255) {
				// next row
				chunkLeft = 0;
				chunkTop += rowHeight;
				contentOffset += 3;
			}
			else {
				int chunkWidth;
				if (chunkStride <= 63) {
					// 4 colors
					chunkWidth = content[contentOffset + 1];
					rowHeight = content[contentOffset + 2];
					contentOffset += 3;
					for (int y = 0; y < rowHeight; y++) {
						for (int x = 0; x < chunkWidth; x++) {
							int b = content[contentOffset + (x >> 2)] >> (~x & 3);
							const int[4] palette4 = { 0xffffff, 0xaaaaaa, 0x000000, 0x555555 };
							Pixels[(chunkTop + y) * width + chunkLeft + x] = palette4[(b >> 3 & 2) + (b & 1)];
						}
						contentOffset += chunkStride;
					}
				}
				else {
					// 16 colors
					chunkStride = content[contentOffset + 2] | content[contentOffset + 3] << 8;
					chunkWidth = content[contentOffset + 4] | content[contentOffset + 5] << 8;
					rowHeight = content[contentOffset + 6] | content[contentOffset + 7] << 8;
					contentOffset += 8;
					for (int y = 0; y < rowHeight; y++) {
						for (int x = 0; x < chunkWidth; x++) {
							int c = GetNibble(content, contentOffset, x);
							const int[16] palette16 = {
								0xffff80,
								0x000000,
								0xff8000,
								0x800000,
								0x00ffff,
								0x000080,
								0x8080ff,
								0x0000ff,
								0xffffff,
								0x008000,
								0x00ff00,
								0xff00ff,
								0xffff00,
								0x808080,
								0xff8080,
								0xff0000
							};
							Pixels[(chunkTop + y) * width + chunkLeft + x] = palette16[c];
						}
						contentOffset += chunkStride;
					}
				}
				chunkLeft += chunkWidth;
			}
		}
		return true;
	}

	bool SetAmstradFirmwarePalette!(byte[] content, int contentOffset, int count)
	{
		for (int i = 0; i < count; i++) {
			int c = content[contentOffset + i];
			if (c > 26)
				return false;
			const byte[3] triLevel = { 0, 0x80, 0xff };
			ContentPalette[i] = triLevel[c / 3 % 3] << 16 | triLevel[c / 9] << 8 | triLevel[c % 3];
		}
		return true;
	}

	bool SetAmstradFirmwarePalette16!(byte[] content)
		=> content[5] == 1 && SetAmstradFirmwarePalette(content, 6, 16);

	bool DecodePphFrame!(string filename, string upperExt, string lowerExt, byte[]! bitmap, byte[] pph, int yOffset)
	{
		int bitmapStride = Width >> 2;
		int bitmapLength = Height * bitmapStride;
		if (ReadCompanionFile(filename, upperExt, lowerExt, bitmap, bitmapLength + 1) != bitmapLength)
			return false;
		if (pph[0] == 5) {
			// mode B1
			int paletteOffset = 6;
			int paletteLines = 0;
			for (int y = 0; y < Height; y++) {
				if (paletteLines == 0) {
					if (!SetAmstradFirmwarePalette(pph, paletteOffset, 4))
						return false;
					paletteOffset += 4;
					if (paletteOffset < (1 + pph[5]) * 5) {
						paletteLines = pph[paletteOffset++];
						if (paletteLines == 0)
							return false;
					}
					else
						paletteLines = 272; // last palette
				}
				DecodeAmstradMode1Line(bitmap, y * bitmapStride, yOffset + y);
				paletteLines--;
			}
		}
		else {
			// mode R, B0
			for (int y = 0; y < Height; y++)
				DecodeAmstradMode0Line(bitmap, y * bitmapStride, yOffset + y);
		}
		return true;
	}

	bool DecodePph!(string filename, byte[] content, int contentLength)
	{
		if (contentLength < 10)
			return false;
		RECOILResolution resolution;
		switch (content[0]) {
		case 3: // mode R
			if (contentLength != 22 || !SetAmstradFirmwarePalette16(content))
				return false;
			resolution = RECOILResolution.Amstrad1x1;
			break;
		case 4: // mode B0
			if (contentLength != 22 || !SetAmstradFirmwarePalette16(content))
				return false;
			resolution = RECOILResolution.Amstrad2x1;
			break;
		case 5: // mode B1
			if (contentLength != (1 + content[5]) * 5)
				return false;
			resolution = RECOILResolution.Amstrad1x1;
			break;
		default:
			return false;
		}
		int width = content[1] | content[2] << 8;
		if (width == 0 || width > 384 || (width & 3) != 0)
			return false;
		int height = content[3] | content[4] << 8;
		if (height == 0 || height > 272)
			return false;
		SetSize(width, height, resolution, 2);
		byte[96 * 272 + 1] bitmap;
		return DecodePphFrame(filename, "ODD", "odd", bitmap, content, 0)
			&& DecodePphFrame(filename, "EVE", "eve", bitmap, content, height)
			&& ApplyBlend();
	}

	// ZX81 formats.

	bool DecodeZx81!(byte[] screen)
	{
		SetSize(256, 192, RECOILResolution.Zx811x1);
		byte[] font = resource<byte[]>("zx81.fnt");
		for (int y = 0; y < 192; y++) {
			for (int x = 0; x < 256; x++) {
				int c = screen[y >> 3 << 5 | x >> 3];
				int b = font[(c & 0x3f) << 3 | (y & 7)] >> (~x & 7) & 1;
				Pixels[y << 8 | x] = b == c >> 7 ? 0xffffff : 0;
			}
		}
		return true;
	}

	bool DecodeZx81Raw!(byte[] content, int contentLength)
	{
		if (contentLength != 792)
			return false;
		byte[32 * 24] screen;
		for (int y = 0; y < 24; y++) {
			if (content[y * 33 + 32] != 0x76)
				return false;
			content.CopyTo(y * 33, screen, y * 32, 32);
		}
		return DecodeZx81(screen);
	}

	bool DecodeZp1!(byte[] content, int contentLength)
	{
		byte[32 * 24] screen;
		Stream() s;
		s.Content = content;
		s.ContentOffset = 0;
		s.ContentLength = contentLength;
		for (int i = 0; i < screen.Length; i++) {
			int hi = s.ReadHexDigit();
			if (hi < 0)
				return false;
			int lo = s.ReadHexDigit();
			if (lo < 0)
				return false;
			screen[i] = hi << 4 | lo;
		}
		return DecodeZx81(screen);
	}

	bool DecodeP!(byte[] content, int contentLength)
	{
		PInterpreter() interp;
		interp.Content = content;
		interp.ContentLength = contentLength;
		return interp.Run() && DecodeZx81(interp.Screen);
	}

	// ZX Spectrum formats.

	static int GetZxColor(int c)
		=> (c >> 1 & 1) * 0xff0000 | (c >> 2 & 1) * 0x00ff00 | (c & 1) * 0x0000ff;

	void SetZx!(RECOILResolution resolution, int frames = 1)
	{
		SetSize(256, 192, resolution, frames);
		// The original ZX Spectrum palette has 16 entries: 8 normal + 8 bright.
		// Here we layout them as ULAplus 64-entry palette
		// so that we can share code in DecodeZx.
		for (int i = 0; i < 64; i++) {
			int rgb = GetZxColor(i);
			if ((i & 0x10) == 0) // not bright
				rgb &= 0xcdcdcd;
			ContentPalette[i] = rgb;
		}
	}

	static int GetG3R3B2Color(int c)
	{
		// 0bGGGRRRBB -> 0bRRRRRRRRGGGGGGGGBBBBBBBB
		return (c & 0x1c) * 0x49 >> 3 << 16
			| (c >> 5) * 0x49 >> 1 << 8
			| (c & 3) * 0x55;
	}

	void SetUlaPlus!(byte[] content, int paletteOffset)
	{
		SetSize(256, 192, RECOILResolution.SpectrumUlaPlus1x1);
		for (int i = 0; i < 64; i++)
			ContentPalette[i] = GetG3R3B2Color(content[paletteOffset + i]);
	}

	const int ZxBitmapCheckerboard = -3;
	const int ZxBitmapHlr = -2;
	const int ZxBitmapLinear = -1;

	const int ZxAttributesNone = -3;
	const int ZxAttributesMg1 = -2;
	const int ZxAttributesTimex = -1;
	const int ZxAttributes8x1 = 0;
	const int ZxAttributes8x2 = 1;
	const int ZxAttributes8x4 = 2;
	const int ZxAttributes8x8 = 3;

	static int GetZxLineOffset(int y) => ((y & 0xc0) << 5) + ((y & 7) << 8) + ((y & 0x38) << 2);

	void DecodeZx!(byte[] content, int bitmapOffset, int attributesOffset, int attributesMode, int pixelsOffset)
	{
		for (int y = 0; y < 192; y++) {
			for (int x = 0; x < 256; x++) {
				int col = x >> 3;
				int c;
				switch (bitmapOffset) {
				case ZxBitmapCheckerboard:
					c = x ^ y;
					break;
				case ZxBitmapHlr:
					c = content[0x54 + (y & 7)] >> (~x & 7);
					break;
				case ZxBitmapLinear:
					c = content[y << 5 | col] >> (~x & 7);
					break;
				default:
					// x=CCCCCBBB, y=AARRRLLL -> o=AALLLRRRCCCCC
					c = content[bitmapOffset + GetZxLineOffset(y) + col] >> (~x & 7);
					break;
				}
				c &= 1;
				if (attributesMode == ZxAttributesNone) {
					// black and white
					if (c != 0)
						c = 0xffffff;
				}
				else {
					int a;
					switch (attributesMode) {
					case ZxAttributesMg1:
						// MG1 file format:
						// 0x0000 hdr
						// 0x0100 scr1
						// 0x1900 scr2
						// 0x3100 att1 8x1, 16 columns (8..23) * 192 rows
						// 0x3d00 att2 8x1, 16 columns (8..23) * 192 rows
						// 0x4900 att1 8x8, 16 columns (0..7,24..31) * 24 rows
						// 0x4a80 att2 8x8, 16 columns (0..7,24..31) * 24 rows
						if (col < 8)
							a = attributesOffset + (y >> 3 << 4);
						else if (col < 24)
							a = (attributesOffset == 0x4900 ? 0x3100 - 8 : 0x3d00 - 8) + (y << 4);
						else
							a = attributesOffset + (y >> 3 << 4) - 16;
						break;
					case ZxAttributesTimex:
						a = attributesOffset + GetZxLineOffset(y);
						break;
					default:
						// linear 8x1, 8x2, 8x4, 8x8
						a = attributesOffset + (y >> attributesMode << 5);
						break;
					}
					a = content[a + col];
					c = ContentPalette[(a >> 2 & 0x30) | (c == 0 ? 8 | (a >> 3 & 7) : a & 7)];
				}
				Pixels[pixelsOffset + (y << 8) + x] = c;
			}
		}
	}

	void DecodeTimexHires!(byte[] content, int contentOffset, int pixelsOffset)
	{
		int inkColor = GetZxColor(content[contentOffset + 0x3000] >> 3);
		for (int y = 0; y < 192; y++) {
			for (int x = 0; x < 512; x++) {
				int c = content[contentOffset + (x & 8) * 768 + GetZxLineOffset(y) + (x >> 4)] >> (~x & 7) & 1;
				int offset = pixelsOffset + (y << 10) + x;
				Pixels[offset + 512] = Pixels[offset] = c == 0 ? inkColor ^ 0xffffff : inkColor;
			}
		}
	}

	bool DecodeHrg!(byte[] content, int contentLength)
	{
		if (contentLength != 24578)
			return false;
		SetSize(512, 384, RECOILResolution.Timex1x2, 2);
		DecodeTimexHires(content, 0, 0);
		DecodeTimexHires(content, 0x3001, 384 * 512);
		return ApplyBlend();
	}

	bool DecodeZxIfl!(byte[] content, int contentLength)
	{
		if (contentLength != 9216)
			return false;
		SetZx(RECOILResolution.Spectrum1x1);
		DecodeZx(content, 0, 0x1800, ZxAttributes8x2, 0);
		return true;
	}

	bool DecodeMcMlt!(byte[] content, int contentLength, int bitmapOffset)
	{
		if (contentLength != 12288)
			return false;
		SetZx(RECOILResolution.Spectrum1x1);
		DecodeZx(content, bitmapOffset, 0x1800, ZxAttributes8x1, 0);
		return true;
	}

	bool DecodeZxImg!(byte[] content, int contentLength)
	{
		if (contentLength != 13824)
			return false;
		SetZx(RECOILResolution.Spectrum1x1, 2);
		DecodeZx(content, 0, 0x1800, ZxAttributes8x8, 0);
		DecodeZx(content, 0x1b00, 0x3300, ZxAttributes8x8, 256 * 192);
		return ApplyBlend();
	}

	bool DecodeMg!(byte[] content, int contentLength)
	{
		if (contentLength < 14080
		 || content[0] != 'M' || content[1] != 'G' || content[2] != 'H'
		 || content[3] != 1)
			return false;
		int attributesMode;
		// this should match filename extension, but let's rely on file content
		switch (content[4]) {
		case 1:
			if (contentLength != 19456)
				return false;
			SetZx(RECOILResolution.Spectrum1x1, 2);
			DecodeZx(content, 0x100, 0x4900, ZxAttributesMg1, 0);
			DecodeZx(content, 0x1900, 0x4a80, ZxAttributesMg1, 256 * 192);
			return ApplyBlend();
		case 2:
			attributesMode = ZxAttributes8x2;
			break;
		case 4:
			attributesMode = ZxAttributes8x4;
			break;
		case 8:
			attributesMode = ZxAttributes8x8;
			break;
		default:
			return false;
		}
		if (contentLength != 256 + 2 * 6144 + (2 * 6144 >> attributesMode))
			return false;
		SetZx(RECOILResolution.Spectrum1x1, 2);
		DecodeZx(content, 0x100, 0x3100, attributesMode, 0);
		DecodeZx(content, 0x1900, 0x3100 + (6144 >> attributesMode), attributesMode, 256 * 192);
		return ApplyBlend();
	}

	bool DecodeAtr!(byte[] content, int contentLength)
	{
		if (contentLength != 768)
			return false;
		SetZx(RECOILResolution.Spectrum1x1);
		DecodeZx(content, ZxBitmapCheckerboard, 0, ZxAttributes8x8, 0);
		return true;
	}

	bool DecodeHlr!(byte[] content, int contentLength)
	{
		// The 84-byte "header" contains code to display the picture. Here we check just a few bytes
		if (contentLength != 1628 || content[0] != 0x76 || content[1] != 0xaf || content[2] != 0xd3 || content[3] != 0xfe
		 || content[4] != 0x21 || content[5] != 0x00 || content[6] != 0x58)
			return false;
		SetZx(RECOILResolution.Spectrum1x1, 2);
		DecodeZx(content, ZxBitmapHlr, 0x5c, ZxAttributes8x8, 0);
		DecodeZx(content, ZxBitmapHlr, 0x35c, ZxAttributes8x8, 256 * 192);
		return ApplyBlend();
	}

	bool DecodeStl!(byte[] content, int contentLength)
	{
		if (contentLength != 3072)
			return false;
		SetSize(256, 192, RECOILResolution.Spectrum4x4, 2);
		for (int f = 0; f < 2; f++) {
			for (int y = 0; y < 192; y++) {
				for (int x = 0; x < 256; x++) {
					int b = content[(y & ~3) << 4 | (x >> 2 & ~3) | f << 1 | (x >> 3 & 1)];
					int rgb = GetZxColor((x & 4) == 0 ? b >> 3 : b);
					if ((b & 0x40) == 0)
						rgb &= 0xcdcdcd;
					Pixels[f * 192 + y << 8 | x] = rgb;
				}
			}
		}
		return ApplyBlend();
	}

	bool DecodeZxRgb3!(byte[] content, int contentLength, byte[] frameComponents)
	{
		if (contentLength != 18432)
			return false;
		SetSize(256, 192, RECOILResolution.Spectrum1x1);
		Frames = 3;
		for (int y = 0; y < 192; y++) {
			for (int x = 0; x < 256; x++) {
				int offset = GetZxLineOffset(y) + (x >> 3);
				int c = 0;
				for (int frame = 0; frame < 3; frame++) {
					if ((content[frame * 0x1800 + offset] >> (~x & 7) & 1) != 0)
						c |= 0xff << frameComponents[frame]; // probably too bright, but 0x55 seems too dark?
				}
				Pixels[(y << 8) + x] = c;
			}
		}
		return true;
	}

	bool DecodeZxRgb!(byte[] content, int contentLength)
	{
		const byte[3] frameComponents = { 16, 8, 0 }; // R, G, B
		return DecodeZxRgb3(content, contentLength, frameComponents);
	}

	bool Decode3!(byte[] content, int contentLength)
	{
		const byte[3] frameComponents = { 0, 16, 8 }; // B, R, G
		return DecodeZxRgb3(content, contentLength, frameComponents);
	}

	bool DecodeCh8!(byte[] content, int contentLength)
	{
		int height;
		switch (contentLength) {
		case 768:
			height = 24;
			break;
		case 2048:
			height = 64;
			break;
		default:
			return false;
		}
		SetSize(256, height, RECOILResolution.Spectrum1x1);
		DecodeBlackAndWhiteFont(content, 0, contentLength, 8);
		return true;
	}

	bool DecodeZxp!(byte[] content, int contentLength)
	{
		if (contentLength < 51889 - 219 || !IsStringAt(content, 0, "ZX-Paintbrush "))
			return false;
		int contentOffset = 14;
		if (IsStringAt(content, 14, "extended "))
			contentOffset = 23;
		if (!IsStringAt(content, contentOffset, "image"))
			return false;
		ZxpStream() s;
		s.Content = content;
		s.ContentOffset = contentOffset + 5;
		s.ContentLength = contentLength;
		if (s.ReadChar() != '\n' || s.ReadChar() != '\n')
			return false;

		byte[12288] scr;
		for (int y = 0; y < 192; y++) {
			int b = 0;
			for (int x = 0; x < 256; x++) {
				int bit = ~x & 7;
				switch (s.ReadChar()) {
				case '*':
				case '0':
					break;
				case '1':
					b |= 1 << bit;
					break;
				default:
					return false;
				}
				if (bit == 0) {
					scr[(y << 5) | (x >> 3)] = b;
					b = 0;
				}
			}
			if (s.ReadChar() != '\n')
				return false;
		}
		if (s.ReadChar() != '\n')
			return false;

		for (int y = 0; y < 192; y++) {
			if (y == 24 && s.IsEof()) {
				SetZx(RECOILResolution.Spectrum1x1);
				DecodeZx(scr, ZxBitmapLinear, 0x1800, ZxAttributes8x8, 0);
				return true;
			}
			for (int x = 0; x < 32; x++) {
				int hi = s.ReadHexDigit();
				if (hi < 0)
					return false;
				int lo = s.ReadHexDigit();
				if (lo < 0)
					return false;
				scr[0x1800 + (y << 5) + x] = (hi << 4) + lo;
				if (s.ReadChar() != (x < 31 ? ' ' : '\n'))
					return false;
			}
		}

		if (!s.IsEof())
			return false;
		SetZx(RECOILResolution.Spectrum1x1);
		DecodeZx(scr, ZxBitmapLinear, 0x1800, ZxAttributes8x1, 0);
		return true;
	}

	bool DecodeBsc!(byte[] content, int contentLength)
	{
		int borderOffset;
		switch (contentLength) {
		case 11136: // BSC
			borderOffset = 0x1b00;
			break;
		case 11904: // BMC4
			borderOffset = 0x1e00;
			break;
		default:
			return false;
		}
		SetSize(384, 304, RECOILResolution.Spectrum1x1);
		for (int y = 0; y < 304; y++) {
			int c = 0;
			for (int x = 0; x < 384; x++) {
				if (y >= 64 && y < 256 && x >= 64 && x < 320) {
					int bY = y - 64;
					int col = (x >> 3) - 8;
					int a = 0x1800 + (bY >> 3 << 5) + col;
					if (contentLength == 11904 && (bY & 4) != 0)
						a += 0x300;
					c = a = content[a];
					if ((content[GetZxLineOffset(bY) + col] >> (~x & 7) & 1) == 0)
						c >>= 3;
					c = GetZxColor(c);
					if ((a & 0x40) == 0)
						c &= 0xcdcdcd;
				}
				else if ((x & 7) == 0) {
					c = content[borderOffset];
					if ((x & 8) != 0) {
						borderOffset++;
						c >>= 3;
					}
					c = GetZxColor(c) & 0xcdcdcd;
				}
				Pixels[y * 384 + x] = c;
			}
		}
		return true;
	}

	bool DecodeChrd!(byte[] content, int contentLength)
	{
		if (contentLength < 15 || !IsStringAt(content, 0, "chr$"))
			return false;
		int columns = content[4];
		int rows = content[5];
		int bytesPerCell = content[6];
		int cells = rows * columns;
		int frames;
		switch (bytesPerCell) {
		case 9:
			frames = 1;
			break;
		case 18:
			frames = 2;
			break;
		default:
			return false;
		}
		if (contentLength != 7 + cells * bytesPerCell
		 || !SetSize(columns << 3, rows << 3, RECOILResolution.Spectrum1x1, frames))
			return false;
		int contentOffset = 7;
		for (int row = 0; row < rows; row++) {
			for (int column = 0; column < columns; column++) {
				for (int frame = 0; frame < frames; frame++) {
					int a = content[contentOffset + 8];
					for (int y = 0; y < 8; y++) {
						for (int x = 0; x < 8; x++) {
							int c = content[contentOffset + y] >> (7 - x) & 1;
							c = GetZxColor(c == 0 ? a >> 3 : a);
							if ((a & 0x40) == 0)
								c &= 0xcdcdcd;
							Pixels[(((frame * rows + row << 3) + y) * columns + column << 3) + x] = c;
						}
					}
					contentOffset += 9;
				}
			}
		}
		if (frames == 2)
			ApplyBlend();
		return true;
	}

	static int GetBspBitmapPixel(byte[] content, int bitmapOffset, int x, int y)
	{
		int col = x >> 3;
		int a = content[bitmapOffset + 0x1800 + (y >> 3 << 5) + col];
		int c = a;
		if ((content[bitmapOffset + GetZxLineOffset(y) + col] >> (~x & 7) & 1) == 0)
			c >>= 3;
		c = GetZxColor(c);
		if ((a & 0x40) == 0)
			c &= 0xcdcdcd;
		return c;
	}

	bool DecodeBspFrame!(int pixelsOffset, byte[] content, int contentLength, int bitmapOffset, int borderOffset)
	{
		for (int y = 0; y < Height; y++) {
			int c = 0;
			int b = 1;
			for (int x = 0; x < Width; x++) {
				if (borderOffset < 0)
					c = GetBspBitmapPixel(content, bitmapOffset, x, y);
				else if (x >= 64 && x < 320 && y >= 64 && y < 256) {
					c = GetBspBitmapPixel(content, bitmapOffset, x - 64, y - 64);
					b = 1;
				}
				else if (b > 0) {
					if (--b == 0) {
						if (borderOffset >= contentLength)
							return false;
						b = content[borderOffset++];
						c = GetZxColor(b) & 0xcdcdcd;
						b >>= 3;
						switch (b) {
						case 0:
							break;
						case 1:
							if (borderOffset >= contentLength)
								return false;
							b = content[borderOffset++];
							break;
						case 2:
							b = 12;
							break;
						default:
							b += 13;
							break;
						}
						b <<= 1;
					}
				}
				Pixels[pixelsOffset + y * Width + x] = c;
			}
		}
		return true;
	}

	bool DecodeBsp!(byte[] content, int contentLength)
	{
		if (contentLength < 6982)
			return false;
		if ((content[3] & 0x40) == 0) {
			if (content[3] < 0x80) {
				SetSize(256, 192, RECOILResolution.Spectrum1x1);
				return DecodeBspFrame(0, content, contentLength, 0x46, -1);
			}
			return contentLength == 13894
				&& SetSize(256, 192, RECOILResolution.Spectrum1x1, 2)
				&& DecodeBspFrame(0, content, contentLength, 0x46, -1)
				&& DecodeBspFrame(256 * 192, content, contentLength, 0x1b46, -1)
				&& ApplyBlend();
		}
		if (content[3] < 0x80) {
			SetSize(384, 304, RECOILResolution.Spectrum1x1);
			return DecodeBspFrame(0, content, contentLength, 0x46, 0x1b46);
		}
		SetSize(384, 304, RECOILResolution.Spectrum1x1, 2);
		return DecodeBspFrame(0, content, contentLength, 0x48, 0x3648)
			&& DecodeBspFrame(384 * 304, content, contentLength, 0x1b48, content[0x46] | content[0x47] << 8)
			&& ApplyBlend();
	}

	bool DecodeNxi!(byte[] content, int contentLength)
	{
		if (contentLength != 49664)
			return false;
		for (int i = 0; i < 256; i++) {
			int c = content[i << 1];
			ContentPalette[i] = (c >> 5) * 0x49 >> 1 << 16
				| (c >> 2 & 7) * 0x49 >> 1 << 8
				| ((c & 3) << 1 | (content[(i << 1) + 1] & 1)) * 0x49 >> 1;
		}
		SetSize(256, 192, RECOILResolution.SpectrumNext1x1);
		DecodeBytes(content, 512);
		return true;
	}

	bool DecodeSxg!(byte[] content, int contentLength)
	{
		if (contentLength < 19 || content[0] != 0x7f
		 || content[1] != 'S' || content[2] != 'X' || content[3] != 'G' || content[6] != 0)
			return false;
		int width = content[8] | content[9] << 8;
		int height = content[10] | content[11] << 8;
		if (!SetSize(width, height, RECOILResolution.ZxEvolution1x1))
			return false;

		int paletteOffset = 14 + content[12] + (content[13] << 8);
		int bitmapOffset = 16 + content[14] + (content[15] << 8);
		int paletteLength = bitmapOffset - paletteOffset;
		if ((paletteLength & 1) != 0 || paletteLength > 256 * 2)
			return false;
		ContentPalette.Fill(0);
		int colors = paletteLength >> 1;
		for (int i = 0; i < colors; i++) {
			int offset = paletteOffset + (i << 1);
			int c = content[offset] | content[offset + 1] << 8;
			if (c < 0x8000) {
				// 25 levels per component
				int r = c >> 10;
				int g = c >> 5 & 0x1f;
				int b = c & 0x1f;
				if (r > 24 || g > 24 || b > 24)
					return false;
				c = r * 255 / 24 << 16 | g * 255 / 24 << 8 | b * 255 / 24;
			}
			else
				c = GetR5G5B5Color(c);
			ContentPalette[i] = c;
		}

		switch (content[7]) {
		case 1:
			if ((width & 1) != 0
			 || contentLength != bitmapOffset + (width >> 1) * height)
				return false;
			DecodeNibbles(content, bitmapOffset, width >> 1);
			return true;
		case 2:
			if (contentLength != bitmapOffset + width * height)
				return false;
			DecodeBytes(content, bitmapOffset);
			return true;
		default:
			return false;
		}
	}

	// MSX formats.

	void SetMsx1Palette!()
	{
		// TMS9928/9929 Palette calculated with the standard video convertion
		// formulas, but with the saturation set to 50%, to match the output
		// of many European models and the Sharp HB-8000.
		// The palette shown in Wikipedia is roughly the same as this,
		// but with some tweaking.
		// By Fabio R. Schmidlin <sd-snatcher@sourceforge.net>
		ContentPalette[ 0] = 0x000800;
		ContentPalette[ 1] = 0x000400;
		ContentPalette[ 2] = 0x3abb43;
		ContentPalette[ 3] = 0x70d377;
		ContentPalette[ 4] = 0x5459d7;
		ContentPalette[ 5] = 0x7b7be8;
		ContentPalette[ 6] = 0xb3634b;
		ContentPalette[ 7] = 0x61dfe7;
		ContentPalette[ 8] = 0xd46a53;
		ContentPalette[ 9] = 0xf88e77;
		ContentPalette[10] = 0xc7c759;
		ContentPalette[11] = 0xd9d481;
		ContentPalette[12] = 0x36a53b;
		ContentPalette[13] = 0xb06bae;
		ContentPalette[14] = 0xc7d0c5;
		ContentPalette[15] = 0xfafff8;
	}

	const byte[32] Msx2DefaultPalette = {
		0x00, 0,
		0x00, 0,
		0x11, 6,
		0x33, 7,
		0x17, 1,
		0x27, 3,
		0x51, 1,
		0x27, 6,
		0x71, 1,
		0x73, 3,
		0x61, 6,
		0x64, 6,
		0x11, 4,
		0x65, 2,
		0x55, 5,
		0x77, 7
	};

	static int GetMsxHeader(byte[] content)
	{
		if (content[1] != 0 || content[2] != 0 || content[5] != 0 || content[6] != 0)
			return -1;
		return content[3] | content[4] << 8;
	}

	static bool IsMsxPalette(byte[] content, int contentOffset)
	{
		int ored = 0;
		for (int i = 0; i < 16; i++) {
			// 0xRB 0x0G, 3 bits per component
			int rb = content[contentOffset + (i << 1)];
			int g = content[contentOffset + (i << 1) + 1];
			if ((rb & 0x88) != 0 || (g & 0xf8) != 0)
				return false;
			ored |= rb | g;
		}
		return ored != 0;
	}

	void SetMsxPalette!(byte[] content, int contentOffset, int colors)
	{
		for (int i = 0; i < colors; i++) {
			// 0xRB 0x0G, 3 bits per component
			int rb = content[contentOffset + (i << 1)];
			int g = content[contentOffset + (i << 1) + 1];
			int rgb = (rb & 0x70) << 12 | (rb & 7) | (g & 7) << 8;
			ContentPalette[i] = rgb << 5 | rgb << 2 | (rgb >> 1 & 0x030303);
		}
	}

	void SetMsx2Palette!(byte[] content, int contentOffset, int contentLength)
	{
		if (contentLength >= contentOffset + 32)
			SetMsxPalette(content, contentOffset, 16);
		else
			SetMsxPalette(Msx2DefaultPalette, 0, 16);
	}

	void DecodeSc2Sc4!(byte[] content, int contentOffset, RECOILResolution resolution)
	{
		SetSize(256, 192, resolution);
		for (int y = 0; y < 192; y++) {
			int fontOffset = contentOffset + ((y &0xc0) << 5) + (y & 7);
			for (int x = 0; x < 256; x++) {
				int b = fontOffset + (content[contentOffset + 0x1800 + ((y & ~7) << 2) + (x >> 3)] << 3);
				int c = content[0x2000 + b];
				Pixels[(y << 8) + x] = ContentPalette[(content[b] >> (~x & 7) & 1) == 0 ? c & 0xf : c >> 4];
			}
		}
	}

	void DecodeMsxSprites!(byte[] content, int mode, int attributesOffset, int patternsOffset)
	{
		int height = mode <= 4 ? 192 : 212;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < 256; x++) {
				int color = 0;
				bool enableOr = false;
				int spritesPerLine = mode >= 4 ? 8 : 4;
				for (int sprite = 0; sprite < 32; sprite++) {
					int attributeOffset = attributesOffset + (sprite << 2);
					int spriteY = content[attributeOffset];
					if (spriteY == (mode >= 4 ? 216 : 208))
						break;
					int row = y - spriteY - 1 & 0xff;
					if (row >= 16)
						continue;
					if (--spritesPerLine < 0)
						break;
					int c = content[mode >= 4 ? attributesOffset - 0x200 + (sprite << 4) + row : attributeOffset + 3];
					if (mode < 4 || (c & 0x40) == 0) {
						if (color != 0)
							break; // got sprite previously, paint it
						enableOr = true;
					}
					else if (!enableOr)
						continue;
					int column = x - content[attributeOffset + 1];
					if (c >= 0x80)
						column += 32;
					if (column < 0 || column >= 16)
						continue;
					int pattern = patternsOffset + ((content[attributeOffset + 2] & 0xfc) << 3) + row;
					if ((content[pattern + ((column & 8) << 1)] >> (~column & 7) & 1) == 0)
						continue;
					color |= c;
					if (mode >= 4)
						color |= 0x10; // 0x10 is arbitrary to make c==0 not transparent
				}
				if (color != 0) {
					int offset;
					switch (mode) {
					case 6:
						offset = (y << 10) + (x << 1);
						Pixels[offset + 512] = Pixels[offset] = ContentPalette[color >> 2 & 3];
						Pixels[offset + 513] = Pixels[offset + 1] = ContentPalette[color & 3];
						break;
					case 7:
						offset = (y << 10) + (x << 1);
						Pixels[offset + 513] = Pixels[offset + 512] = Pixels[offset + 1] = Pixels[offset] = ContentPalette[color & 0xf];
						break;
					default:
						Pixels[(y << 8) + x] = ContentPalette[color & 0xf];
						break;
					}
				}
			}
		}
	}

	bool DecodeSc2!(byte[] content, int contentLength)
	{
		if (contentLength < 14343 || content[0] != 0xfe || GetMsxHeader(content) < 0x37ff)
			return false;
		if (IsMsxPalette(content, 0x1b87)) {
			SetMsxPalette(content, 0x1b87, 16);
			DecodeSc2Sc4(content, 7, RECOILResolution.Msx21x1);
		}
		else {
			SetMsx1Palette();
			DecodeSc2Sc4(content, 7, RECOILResolution.Msx11x1);
		}
		if (contentLength == 16391)
			DecodeMsxSprites(content, 2, 0x1b07, 0x3807);
		return true;
	}

	void DecodeSc3Screen!(byte[] content, int contentOffset, bool isLong)
	{
		SetSize(256, 192, RECOILResolution.Msx14x4);
		for (int y = 0; y < 192; y++) {
			for (int x = 0; x < 256; x++) {
				int c = isLong ? content[0x807 + ((y & ~7) << 2) + (x >> 3)] : (y & 0xe0) + (x >> 3);
				c = content[contentOffset + (c << 3) + (y >> 2 & 7)] >> (~x & 4) & 0xf;
				Pixels[(y << 8) + x] = ContentPalette[c];
			}
		}
	}

	bool DecodeSc3!(byte[] content, int contentLength)
	{
		if (contentLength < 1543 || content[0] != 0xfe || GetMsxHeader(content) < 0x5ff)
			return false;
		if (contentLength >= 0x2047 && IsMsxPalette(content, 0x2027))
			SetMsxPalette(content, 0x2027, 16);
		else
			SetMsx1Palette();
		DecodeSc3Screen(content, 7, contentLength >= 0xb07);
		if (contentLength == 16391)
			DecodeMsxSprites(content, 3, 0x1b07, 0x3807);
		return true;
	}

	bool DecodeSc4!(byte[] content, int contentLength)
	{
		if (contentLength < 14343 || content[0] != 0xfe || GetMsxHeader(content) < 0x37ff)
			return false;
		if (IsMsxPalette(content, 0x1b87))
			SetMsxPalette(content, 0x1b87, 16);
		else
			SetMsxPalette(Msx2DefaultPalette, 0, 16);
		DecodeSc2Sc4(content, 7, RECOILResolution.Msx21x1);
		if (contentLength >= 16391)
			DecodeMsxSprites(content, 4, 0x1e07, 0x3807);
		return true;
	}

	int GetMsx128Height(byte[] content, int contentLength)
	{
		if (contentLength < 135 || content[0] != 0xfe)
			return -1;
		int header = GetMsxHeader(content);
		if (header < 127)
			return -1;
		int height = (header + 1) >> 7;
		if (contentLength < 7 + (height << 7))
			return -1;
		return height < 212 ? height : 212;
	}

	void DecodeMsxScreen!(byte[] content, int contentOffset, byte[] interlace, int height, int mode, int interlaceMask)
	{
		if (interlaceMask != 0) {
			SetSize(512, height << 1, mode >= 10 ? RECOILResolution.Msx2Plus2x1i :
				mode >> 1 == 3 ? RECOILResolution.Msx21x1i :
				RECOILResolution.Msx22x1i);
			Frames = 2;
		}
		else if (mode >> 1 == 3)
			SetSize(512, height << 1, RECOILResolution.Msx21x2);
		else
			SetSize(256, height, mode >= 10 ? RECOILResolution.Msx2Plus1x1 : RECOILResolution.Msx21x1);

		for (int y = 0; y < Height; y++) {
			byte[] screen = (y & interlaceMask) == 0 ? content : interlace;
			int screenOffset = (y & interlaceMask) == 0 || content != interlace ? contentOffset : contentOffset + (mode <= 6 ? 0x6a07 : 0xd407);
			for (int x = 0; x < Width; x++) {
				int rgb = 0;
				switch (mode) {
				case 5:
					rgb = ContentPalette[GetNibble(screen, screenOffset + (y >> interlaceMask << 7), x >> interlaceMask)];
					break;
				case 6:
					rgb = ContentPalette[screen[screenOffset + (y >> 1 << 7) + (x >> 2)] >> ((~x & 3) << 1) & 3];
					break;
				case 7:
					rgb = ContentPalette[GetNibble(screen, screenOffset + (y >> 1 << 8), x)];
					break;
				case 8:
					rgb = ContentPalette[screen[screenOffset + (y >> interlaceMask << 8) + (x >> interlaceMask)]];
					break;
				case 10:
					rgb = DecodeMsxYjk(screen, screenOffset + (y >> interlaceMask << 8), x >> interlaceMask, true);
					break;
				case 12:
					rgb = DecodeMsxYjk(screen, screenOffset + (y >> interlaceMask << 8), x >> interlaceMask, false);
					break;
				default:
					assert false;
				}
				Pixels[y * Width + x] = rgb;
			}
		}
	}

	bool DecodeMsxSc!(string filename, byte[] content, int contentOffset, string upperExt, string lowerExt, int height, int mode)
	{
		if (filename != null) {
			byte[54279] interlace;
			int interlaceLength = 7 + (height << (mode <= 6 ? 7 : 8));
			if (ReadCompanionFile(filename, upperExt, lowerExt, interlace, interlaceLength) == interlaceLength
			 && interlace[0] == 0xfe
			 && GetMsxHeader(interlace) >= interlaceLength - 8) {
				DecodeMsxScreen(content, contentOffset, interlace, height, mode, 1);
				return true;
			}
		}

		DecodeMsxScreen(content, contentOffset, null, height, mode, 0);
		return false;
	}

	bool DecodeSc5!(string filename, byte[] content, int contentLength)
	{
		int height = GetMsx128Height(content, contentLength);
		if (height <= 0)
			return false;
		SetMsx2Palette(content, 0x7687, contentLength);
		if (!DecodeMsxSc(filename, content, 7, "S15", "s15", height, 5)
		 && contentLength == 32775)
			DecodeMsxSprites(content, 5, 0x7607, 0x7807);
		return true;
	}

	void SetMsxCompanionPalette!(string filename, string upperExt, string lowerExt)
	{
		byte[32] palette;
		SetMsxPalette(ReadCompanionFile(filename, upperExt, lowerExt, palette, 32) == 32 ? palette : Msx2DefaultPalette, 0, 16);
	}

	bool DecodeSr5!(string filename, byte[] content, int contentLength)
	{
		int height = GetMsx128Height(content, contentLength);
		if (height <= 0)
			return false;
		SetMsxCompanionPalette(filename, "PL5", "pl5");
		SetSize(256, height, RECOILResolution.Msx21x1);
		DecodeNibbles(content, 7, 128);
		return true;
	}

	bool DecodeMsx6!(byte[] content, int contentOffset)
	{
		int height = GetOriginalHeight();
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < Width; x++) {
				int offset = y * Width + x;
				int b = content[contentOffset + (offset >> 2)];
				SetScaledPixel(x, y, ContentPalette[b >> ((~offset & 3) << 1) & 3]);
			}
		}
		return true;
	}

	void SetMsx6DefaultPalette!()
	{
		ContentPalette[0] = 0x000000;
		ContentPalette[1] = 0x249224; // from index 12
		ContentPalette[2] = 0x24db24;
		ContentPalette[3] = 0x6dff6d;
	}

	bool DecodeSc6!(string filename, byte[] content, int contentLength)
	{
		int height = GetMsx128Height(content, contentLength);
		if (height <= 0)
			return false;
		if (contentLength >= 30351)
			SetMsxPalette(content, 0x7687, 4);
		else
			SetMsx6DefaultPalette();
		if (!DecodeMsxSc(filename, content, 7, "S16", "s16", height, 6)
		 && contentLength == 32775)
			DecodeMsxSprites(content, 6, 0x7607, 0x7807);
		return true;
	}

	void SetMsx6Palette!(string filename)
	{
		byte[8] palette;
		if (ReadCompanionFile(filename, "PL6", "pl6", palette, 8) == 8)
			SetMsxPalette(palette, 0, 4);
		else
			SetMsx6DefaultPalette();
	}

	bool DecodeSr6!(string filename, byte[] content, int contentLength)
	{
		int height = GetMsx128Height(content, contentLength);
		if (height <= 0)
			return false;
		SetSize(512, height << 1, RECOILResolution.Msx21x2);
		SetMsx6Palette(filename);
		return DecodeMsx6(content, 7);
	}

	bool DecodeGl6!(string filename, byte[] content, int contentLength)
	{
		if (contentLength < 5)
			return false;
		int width = content[0] | content[1] << 8;
		int height = content[2] | content[3] << 8;
		if (contentLength < 4 + (width * height + 3 >> 2)
		 || !SetSize(width, height << 1, RECOILResolution.Msx21x2))
			return false;
		if (filename != null)
			SetMsx6Palette(filename); // GL6
		else {
			// STP
			ContentPalette[0] = 0xffffff;
			ContentPalette[1] = 0;
			ContentPalette[3] = ContentPalette[2] = 0; // reserved for program GUI
		}
		return DecodeMsx6(content, 4);
	}

	static byte[] UnpackSr(byte[] content, int contentLength, byte[]! unpacked)
	{
		if (contentLength < 7)
			return null;
		switch (content[0]) {
		case 0xfe:
			if (contentLength < 54279 || GetMsxHeader(content) < 0xd3ff)
				return null;
			return content;
		case 0xfd:
			if (7 + GetMsxHeader(content) != contentLength)
				return null;
			SrStream() rle;
			rle.Content = content;
			rle.ContentOffset = 7;
			rle.ContentLength = contentLength;
			rle.Unpack(unpacked, 7, 1, 54279); // ignore decompression errors because some SR7 are truncated
			return unpacked;
		default:
			return null;
		}
	}

	bool DecodeSc7!(string filename, byte[] content, int contentLength)
	{
		if (contentLength < 54279 || content[0] != 0xfe || GetMsxHeader(content) < 0xd3ff)
			return false;
		SetMsx2Palette(content, 0xfa87, contentLength);
		if (!DecodeMsxSc(filename, content, 7, "S17", "s17", 212, 7)
		 && contentLength == 64167)
			DecodeMsxSprites(content, 7, 0xfa07, 0xf007);
		return true;
	}

	bool DecodeSri!(string filename, byte[] content, int contentLength)
	{
		if (contentLength != 108544)
			return false;
		SetMsxCompanionPalette(filename, "PL7", "pl7");
		SetSize(512, 424, RECOILResolution.Msx21x1i);
		Frames = 2;
		DecodeNibbles(content, 0, 256);
		return true;
	}

	bool DecodeSr7!(string filename, byte[] content, int contentLength)
	{
		byte[54279] unpacked = 0;
		content = UnpackSr(content, contentLength, unpacked);
		if (content == null)
			return false;
		SetMsxCompanionPalette(filename, "PL7", "pl7");
		SetSize(512, 212 * 2, RECOILResolution.Msx21x2);
		DecodeNibbles(content, 7, 256);
		return true;
	}

	bool DecodeGl16!(string filename, byte[] content, int contentLength,
		RECOILResolution resolution, string upperExt, string lowerExt)
	{
		if (contentLength < 5)
			return false;
		int width = content[0] | content[1] << 8;
		int height = content[2] | content[3] << 8;
		if (contentLength < 4 + (width * height + 1 >> 1)
		 || !SetScaledSize(width, height, resolution))
			return false;
		SetMsxCompanionPalette(filename, upperExt, lowerExt);
		// no line padding
		for (int y = 0; y < height; y++)
			for (int x = 0; x < width; x++)
				SetScaledPixel(x, y, ContentPalette[GetNibble(content, 4, y * width + x)]);
		return true;
	}

	bool DecodeGl5!(string filename, byte[] content, int contentLength)
		=> DecodeGl16(filename, content, contentLength, RECOILResolution.Msx21x1, "PL5", "pl5");

	bool DecodeGl7!(string filename, byte[] content, int contentLength)
		=> DecodeGl16(filename, content, contentLength, RECOILResolution.Msx21x2, "PL7", "pl7");

	void SetSc8Palette!()
	{
		for (int c = 0; c < 256; c++) {
			// 0bGGGRRRBB -> 0xRRGGBB
			const byte[4] blues = { 0, 2, 4, 7 };
			int rgb = (c & 0x1c) << 14 | (c & 0xe0) << 3 | blues[c & 3];
			ContentPalette[c] = rgb << 5 | rgb << 2 | (rgb >> 1 & 0x030303);
		}
	}

	bool DecodeSc8!(string filename, byte[] content, int contentLength)
	{
		byte[54279] unpacked = 0;
		content = UnpackSr(content, contentLength, unpacked);
		if (content == null)
			return false;
		SetSc8Palette();
		if (!DecodeMsxSc(filename, content, 7, "S18", "s18", 212, 8)
		 && contentLength == 64167) {
			const byte[32] spritePalette = {
				0x00, 0,
				0x02, 0,
				0x30, 0,
				0x32, 0,
				0x00, 3,
				0x02, 3,
				0x30, 3,
				0x32, 3,
				0x72, 4,
				0x07, 0,
				0x70, 0,
				0x77, 0,
				0x00, 7,
				0x07, 7,
				0x70, 7,
				0x77, 7
			};
			SetMsxPalette(spritePalette, 0, 16);
			DecodeMsxSprites(content, 8, 0xfa07, 0xf007);
		}
		return true;
	}

	bool DecodeGl8!(byte[] content, int contentLength)
	{
		if (contentLength < 5)
			return false;
		int width = content[0] | content[1] << 8;
		int height = content[2] | content[3] << 8;
		if (contentLength != 4 + width * height
		 || !SetSize(width, height, RECOILResolution.Msx21x1))
			return false;
		SetSc8Palette();
		DecodeBytes(content, 4);
		return true;
	}

	bool DecodePct!(byte[] content, int contentLength)
	{
		if (contentLength < 384
		 || (!IsStringAt(content, 0, "DYNAMIC") && !IsStringAt(content, 0, "E U R O"))
		 || !IsStringAt(content, 7, " PUBLISHER "))
			return false;
		int height;
		int contentOffset;
		if (IsStringAt(content, 18, "SCREEN")) {
			height = 704;
			contentOffset = 0x180;
		}
		else if (IsStringAt(content, 18, "FONT")) {
			height = 160;
			contentOffset = 0x200;
		}
		else
			return false;
		SetSize(512, height << 1, RECOILResolution.Msx21x2);
		CciStream() rle;
		rle.Content = content;
		rle.ContentOffset = contentOffset;
		rle.ContentLength = contentLength;
		for (int y = 0; y < height; y++) {
			int b = 0;
			for (int x = 0; x < 512; x++) {
				if ((x & 7) == 0) {
					b = rle.ReadRle();
					if (b < 0)
						return false;
				}
				int offset = (y << 10) + x;
				// low nibble first
				Pixels[offset + 512] = Pixels[offset] =
					(b >> ((x ^ 3) & 7) & 1) == 0 ? 0xffffff : 0;
			}
		}
		return true;
	}

	bool DecodeDdGraph!(string filename, byte[] content, int contentLength)
	{
		if (contentLength < 4)
			return false;
		int width = content[0];
		if (width == 0 || width > 128)
			return false;
		int height = content[1];
		if (height == 0 || height > 212)
			return false;
		int verbatimLines = content[2];
		if (verbatimLines == 0 || verbatimLines > height)
			return false;
		ZimStream() stream;
		stream.Content = content;
		stream.ContentOffset = 3;
		stream.ContentLength = contentLength;
		int flagsOffset = 64;
		byte[212 * 128] unpacked;
		int unpackedOffset = 0;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				if (flagsOffset >= 64) {
					if (!stream.UnpackFlags2())
						return false;
					flagsOffset = 0;
				}
				int b = stream.ReadUnpacked(stream.Flags2, flagsOffset++);
				if (b < 0)
					return false;
				if (y >= verbatimLines)
					b ^= unpacked[unpackedOffset - width];
				unpacked[unpackedOffset++] = b;
			}
		}
		if (stream.ContentOffset != stream.ContentLength)
			return false;
		SetMsxCompanionPalette(filename, "PL5", "pl5");
		SetSize(width << 1, height, RECOILResolution.Msx21x1);
		DecodeNibbles(unpacked, 0, width);
		return true;
	}

	int DecodeMsxYjk(byte[] content, int contentOffset, int x, bool usePalette)
	{
		int y = content[contentOffset + x] >> 3;
		if (usePalette && (y & 1) != 0)
			return ContentPalette[y >> 1];
		int rgb;
		if ((x | 3) >= Width) {
			// missing color information
			// not sure if correct, but at least avoids buffer overflow
			rgb = y * 0x010101;
		}
		else {
			x = contentOffset + (x & ~3);
			int k = (content[x] & 7) | (content[x + 1] & 7) << 3;
			int j = (content[x + 2] & 7) | (content[x + 3] & 7) << 3;
			// to 6-bit signed
			k -= (k & 0x20) << 1;
			j -= (j & 0x20) << 1;
			// YJK to RGB
			int r = y + j;
			if (r < 0)
				r = 0;
			else if (r > 31)
				r = 31;
			int g = y + k;
			if (g < 0)
				g = 0;
			else if (g > 31)
				g = 31;
			int b = (((5 * y - k) >> 1) - j) >> 1;
			if (b < 0)
				b = 0;
			else if (b > 31)
				b = 31;
			rgb = r << 16 | g << 8 | b;
		}
		// 5-bit RGB to 8-bit RGB
		return rgb << 3 | (rgb >> 2 & 0x070707);
	}

	void DecodeMsxYjkScreen!(byte[] content, int contentOffset, bool usePalette)
	{
		int width = GetOriginalWidth();
		for (int y = 0; y < Height; y++)
			for (int x = 0; x < width; x++)
				SetScaledPixel(x, y, DecodeMsxYjk(content, contentOffset + y * width, x, usePalette));
	}

	void DecodeSccSca!(string filename, byte[] content, int contentLength, int height, bool usePalette)
	{
		if (!DecodeMsxSc(filename, content, 7, usePalette ? "S1A" : "S1C", usePalette ? "s1a" : "s1c", height, usePalette ? 10 : 12)
		 && contentLength == 64167
		 && content[0] == 0xfe) {
			SetMsxPalette(content, 0xfa87, 16); // wasn't set for SCC
			DecodeMsxSprites(content, 12, 0xfa07, 0xf007);
		}
	}

	bool DecodeScc!(string filename, byte[] content, int contentLength)
	{
		int height;
		if (contentLength >= 49159 && content[0] == 0xfe && GetMsxHeader(content) == 0xbfff)
			height = 192;
		else {
			byte[54279] unpacked = 0;
			content = UnpackSr(content, contentLength, unpacked);
			if (content == null)
				return false;
			height = 212;
		}
		DecodeSccSca(filename, content, contentLength, height, false);
		return true;
	}

	bool DecodeSca!(string filename, byte[] content, int contentLength)
	{
		if (contentLength < 64167 || content[0] != 0xfe || GetMsxHeader(content) < 0xd3ff)
			return false;
		SetMsxPalette(content, 0xfa87, 16);
		DecodeSccSca(filename, content, contentLength, 212, true);
		return true;
	}

	bool DecodeGlYjk!(string filename, byte[] content, int contentLength)
	{
		if (contentLength < 8)
			return false;
		int width = content[0] | content[1] << 8;
		int height = content[2] | content[3] << 8;
		if (contentLength != 4 + width * height
		 || !SetSize(width, height, RECOILResolution.Msx2Plus1x1))
			return false;
		if (filename != null)
			SetMsxCompanionPalette(filename, "PLA", "pla");
		DecodeMsxYjkScreen(content, 4, filename != null);
		return true;
	}

	bool SetG9bPalette!(byte[] content, int colors)
	{
		for (int c = 0; c < colors; c++) {
			int offset = 16 + c * 3;
			int rgb = content[offset] << 16 | content[offset + 1] << 8 | content[offset + 2];
			if ((rgb & 0xe0e0e0) != 0)
				return false;
			ContentPalette[c] = rgb << 3 | (rgb >> 2 & 0x070707);
		}
		return true;
	}

	const int G9bYuv = 0;

	void DecodeG9bUnpacked!(byte[] content, int depth)
	{
		int pixelsLength;
		switch (depth) {
		case 4:
			DecodeNibbles(content, 16 + 16 * 3, Width + 1 >> 1);
			break;

		case 8:
			DecodeBytes(content, 16 + 64 * 3);
			break;

		case G9bYuv:
			pixelsLength = Width * Height;
			for (int i = 0; i < pixelsLength; i++) {
				int y = content[16 + i] >> 3;
				int x = 16 + (i & ~3);
				int v = (content[x] & 7) | (content[x + 1] & 7) << 3;
				int u = (content[x + 2] & 7) | (content[x + 3] & 7) << 3;
				// to 6-bit signed
				u -= (u & 0x20) << 1;
				v -= (v & 0x20) << 1;
				// YUV to RGB
				int r = y + u;
				if (r < 0)
					r = 0;
				else if (r > 31)
					r = 31;
				int g = (((5 * y - v) >> 1) - u) >> 1;
				if (g < 0)
					g = 0;
				else if (g > 31)
					g = 31;
				int b = y + v;
				if (b < 0)
					b = 0;
				else if (b > 31)
					b = 31;
				int rgb = r << 16 | g << 8 | b;
				// 5-bit RGB to 8-bit RGB
				Pixels[i] = rgb << 3 | (rgb >> 2 & 0x070707);
			}
			break;

		case 16:
			pixelsLength = Width * Height;
			for (int i = 0; i < pixelsLength; i++) {
				int c = content[16 + (i << 1)] | content[17 + (i << 1)] << 8;
				// XGGGGGRR RRRBBBBB
				int rgb = (c & 0x3e0) << 14 | (c & 0x7c00) << 1 | (c & 0x1f) << 3;
				Pixels[i] = rgb | (rgb >> 5 & 0x070707);
			}
			break;

		default:
			assert false;
		}
	}

	bool DecodeG9b!(byte[] content, int contentLength)
	{
		if (contentLength < 17
		 || content[0] != 'G' || content[1] != '9' || content[2] != 'B'
		 || content[3] != 11 || content[4] != 0)
			return false;
		int depth = content[5];
		int headerLength = 16 + content[7] * 3;
		int width = content[8] | content[9] << 8;
		int height = content[10] | content[11] << 8;
		if (contentLength <= headerLength
		 || !SetSize(width, height, RECOILResolution.MsxV99901x1))
			return false;
		int unpackedLength = headerLength + (width * depth + 7 >> 3) * height;
		switch (depth) {
		// TODO: case 2:
		case 4:
			if (content[7] != 16
			 || !SetG9bPalette(content, 16))
				return false;
			break;
		case 8:
			// TODO: fixed palette, YJK
			switch (content[7]) {
			case 0:
				if (content[6] != 0xc0
				 || (width & 3) != 0)
					return false;
				depth = G9bYuv;
				break;
			case 64:
				if (!SetG9bPalette(content, 64))
					return false;
				// colors 64-255 are not expected
				ContentPalette.Fill(0, 64, 192);
				break;
			default:
				return false;
			}
			break;
		case 16:
			break;
		default:
			return false;
		}
		switch (content[12]) {
		case 0:
			if (contentLength != unpackedLength)
				return false;
			DecodeG9bUnpacked(content, depth);
			return true;
		case 1:
			byte[]# unpacked = new byte[unpackedLength];
			G9bStream() s;
			s.Content = content;
			s.ContentLength = contentLength;
			bool ok = s.Unpack(unpacked, headerLength, unpackedLength);
			if (ok)
				DecodeG9bUnpacked(unpacked, depth);
			return ok;
		default:
			return false;
		}
	}

	static int GetMigMode(int reg0, int reg1, int reg19, int length)
		=> (reg0 & 0x0e) | (reg1 & 0x18) << 1 | (reg19 & 0x18) << 3 | length << 8;

	bool DecodeMig!(byte[] content, int contentLength)
	{
		if (contentLength < 16
		 || !IsStringAt(content, 0, "MSXMIG")
		 || Get32LittleEndian(content, 6) != contentLength - 6)
			return false;
		byte[MigStream.MaxUnpackedLength] unpacked;
		MigStream() s;
		s.Content = content;
		s.ContentLength = contentLength;
		int unpackedLength = s.Unpack(unpacked);

		int colors = 0;
		byte[256] registers = 0;
		for (int unpackedOffset = 0; unpackedOffset < unpackedLength; ) {
			switch (unpacked[unpackedOffset]) {
			case 0: // registers
				if (unpackedOffset + 1 >= unpackedLength)
					return false;
				int c = unpacked[unpackedOffset + 1];
				if (unpackedOffset + 2 + c * 3 > unpackedLength)
					return false;
				for (int i = 0; i < c; i++) {
					int offset = unpackedOffset + 2 + i * 3;
					int r = unpacked[offset];
					int m = unpacked[offset + 2];
					registers[r] = (registers[r] & ~m) | (unpacked[offset + 1] & m);
				}
				unpackedOffset += 2 + c * 3;
				break;

			case 1: // palette
				if (unpackedOffset + 2 >= unpackedLength
				 || unpacked[unpackedOffset + 1] != 0)
					return false;
				colors = unpacked[unpackedOffset + 2];
				if (unpackedOffset + 3 + (colors << 1) > unpackedLength)
					return false;
				SetMsxPalette(unpacked, unpackedOffset + 3, colors);
				unpackedOffset += 3 + (colors << 1);
				break;

			case 2: // bitmap
				if (unpackedOffset + 7 >= unpackedLength
				 || unpacked[unpackedOffset + 1] != 0 || unpacked[unpackedOffset + 2] != 0 || unpacked[unpackedOffset + 3] != 0
				 || unpacked[unpackedOffset + 4] != 0 || unpacked[unpackedOffset + 6] != 0)
					return false;
				int length = unpacked[unpackedOffset + 5];
				unpackedOffset += 7;
				int interlaceMask;
				switch (registers[9] & 0x0c) {
				case 0x00:
					if (unpackedOffset + (length << 8) + 1 != unpackedLength)
						return false;
					interlaceMask = 0;
					break;
				case 0x0c:
					if (unpackedOffset + (length << 9) + 7 + 1 != unpackedLength
					 || unpacked[unpackedOffset + (length << 8)] != 2
					 || unpacked[unpackedOffset + (length << 8) + 1] != 0
					 || unpacked[unpackedOffset + (length << 8) + 4] != 0 || unpacked[unpackedOffset + (length << 8) + 5] != length || unpacked[unpackedOffset + (length << 8) + 6] != 0)
						return false;
					interlaceMask = 1;
					break;
				default:
					return false;
				}
				int mode;
				switch (GetMigMode(registers[0], registers[1], registers[0x19], length)) {
				case GetMigMode(0x02, 0x00, 0x00, 0x38):
					// screen 2
					if (colors < 16 || interlaceMask != 0)
						return false;
					DecodeSc2Sc4(unpacked, unpackedOffset, RECOILResolution.Msx21x1);
					return true;
				case GetMigMode(0x00, 0x08, 0x00, 0x06):
					// screen 3
					if (colors < 16 || interlaceMask != 0)
						return false;
					DecodeSc3Screen(unpacked, unpackedOffset, false);
					return true;
				case GetMigMode(0x06, 0x00, 0x00, 0x6a):
					// screen 5
					if (colors < 16)
						return false;
					mode = 5;
					break;
				case GetMigMode(0x08, 0x00, 0x00, 0x6a):
					// screen 6
					if (colors < 4)
						return false;
					mode = 6;
					break;
				case GetMigMode(0x0a, 0x00, 0x00, 0xd4):
					// screen 7
					if (colors < 16)
						return false;
					mode = 7;
					break;
				case GetMigMode(0x0e, 0x00, 0x00, 0xd4):
					// screen 8
					SetSc8Palette();
					mode = 8;
					break;
				case GetMigMode(0x0e, 0x00, 0x18, 0xd4):
					// screen 10
					if (colors < 16)
						return false;
					mode = 10;
					break;
				case GetMigMode(0x0e, 0x00, 0x08, 0xd4):
					// screen 12
					mode = 12;
					break;
				default:
					return false;
				}
				DecodeMsxScreen(unpacked, unpackedOffset, unpacked, 212, mode, interlaceMask);
				return true;
			default:
				return false;
			}
		}
		return false;
	}

	// Apple II formats.

	bool DecodeHgr!(byte[] content, int contentLength)
	{
		if (contentLength < 8184)
			return false;
		SetSize(280, 192, RECOILResolution.AppleII1x1);
		for (int y = 0; y < 192; y++) {
			int lineOffset = (y & 7) << 10 | (y & 0x38) << 4 | (y >> 6) * 40;
			for (int x = 0; x < 280; x++) {
				int c = content[lineOffset + x / 7] >> (x % 7) & 1;
				if (c != 0)
					c = 0xffffff;
				Pixels[y * 280 + x] = c;
			}
		}
		return true;
	}

	bool DecodeAppleIIDhr!(byte[] content, int contentLength)
	{
		if (contentLength != 16384)
			return false;
		SetSize(560, 384, RECOILResolution.AppleIIe1x2);
		for (int y = 0; y < 192; y++) {
			int lineOffset = (y & 7) << 10 | (y & 0x38) << 4 | (y >> 6) * 40;
			for (int x = 0; x < 560; x++) {
				int b = x / 7;
				int c = content[((b & 1) << 13) + lineOffset + (b >> 1)] >> (x % 7) & 1;
				if (c != 0)
					c = 0xffffff;
				int pixelsOffset = y * (560 * 2) + x;
				Pixels[pixelsOffset + 560] = Pixels[pixelsOffset] = c;
			}
		}
		return true;
	}

	void SetAppleIIGSPalette!(byte[] content, int contentOffset, int reverse)
	{
		for (int c = 0; c < 16; c++) {
			int offset = contentOffset + ((c ^ reverse) << 1);
			int gb = content[offset];
			int r = content[offset + 1] & 0xf;
			int g = gb >> 4;
			int b = gb & 0xf;
			int rgb = r << 16 | g << 8 | b;
			rgb |= rgb << 4;
			ContentPalette[c] = rgb;
		}
	}

	void DecodeShrLine!(byte[] content, int y)
	{
		for (int x = 0; x < 320; x++)
			Pixels[y * 320 + x] = ContentPalette[GetNibble(content, y * 160, x)];
	}

	bool DecodeAppleIIShr!(byte[] content, int contentLength)
	{
		if (contentLength != 32768)
			return false;
		SetSize(320, 200, RECOILResolution.AppleIIGS1x1);
		for (int y = 0; y < 200; y++) {
			SetAppleIIGSPalette(content, 0x7e00 + ((content[0x7d00 + y] & 0xf) << 5), 0);
			DecodeShrLine(content, y);
		}
		return true;
	}

	bool DecodeSh3!(byte[] content, int contentLength)
	{
		if (contentLength != 38400)
			return false;
		SetSize(320, 200, RECOILResolution.AppleIIGS1x1);
		for (int y = 0; y < 200; y++) {
			SetAppleIIGSPalette(content, 0x7d00 + (y << 5), 0xf);
			DecodeShrLine(content, y);
		}
		return true;
	}

	void DrawSprByte!(int x1, int y, int b)
	{
		for (int x = 0; x < 8; x++) {
			if ((b >> (7 - x) & 1) != 0)
				Pixels[y * SprStream.Width + x1 + x] = 0xffffff;
		}
	}

	bool DecodeAppleSpr!(byte[] content, int contentLength)
	{
		SetSize(SprStream.Width, SprStream.Height, RECOILResolution.AppleII1x1);
		Pixels.Fill(0, 0, SprStream.Width * SprStream.Height);
		SprStream() s;
		s.Content = content;
		s.ContentOffset = 0;
		s.ContentLength = contentLength;
		for (;;) {
			int cols = s.ReadSprInt();
			if (cols < 0)
				return false;
			int rows = s.ReadSprInt();
			if (rows < 0)
				return false;
			int order = s.ReadSprInt();
			if (order < 0)
				return false;
			int x = s.ReadSprInt();
			if (x < 0)
				return false;
			int y = s.ReadSprInt();
			if (y < 0)
				return false;
			if (rows == 0)
				break;
			if (cols == 0 || x + (cols << 3) > SprStream.Width || y + rows > SprStream.Height)
				return false;
			if (order == 2) {
				for (int col = 0; col < cols; col++) {
					for (int row = 0; row < rows; row++) {
						int b = s.ReadSprInt();
						if (b < 0)
							return false;
						DrawSprByte(x + (col << 3), y + row, b);
					}
				}
			}
			else {
				for (int row = 0; row < rows; row++) {
					for (int col = 0; col < cols; col++) {
						int b = s.ReadSprInt();
						if (b < 0)
							return false;
						DrawSprByte(x + (col << 3), y + row, b);
					}
				}
			}
		}
		return true;
	}

	bool DecodePackBytes!(PackBytesStream! stream, int pixelsOffset, int unpackedBytes)
	{
		for (int x = 0; x < unpackedBytes; x++) {
			int b = stream.ReadUnpacked();
			if (b < 0)
				return false;
			if (Resolution == RECOILResolution.AppleIIGS1x2) {
				int offset = (pixelsOffset << 1) + (x << 2);
				Pixels[offset + Width] = Pixels[offset] = ContentPalette[8 + (b >> 6)];
				Pixels[offset + Width + 1] = Pixels[offset + 1] = ContentPalette[12 + (b >> 4 & 3)];
				Pixels[offset + Width + 2] = Pixels[offset + 2] = ContentPalette[(b >> 2 & 3)];
				Pixels[offset + Width + 3] = Pixels[offset + 3] = ContentPalette[4 + (b & 3)];
			}
			else {
				Pixels[pixelsOffset + (x << 1)] = ContentPalette[b >> 4];
				Pixels[pixelsOffset + (x << 1) + 1] = ContentPalette[b & 0xf];
			}
		}
		return true;
	}

	bool DecodePaintworks!(byte[] content, int contentLength)
	{
		if (contentLength < 0x222 + 160 * 396 / 128)
			return false;
		SetSize(320, 396, RECOILResolution.AppleIIGS1x1);
		SetAppleIIGSPalette(content, 0, 0);
		PackBytesStream() stream;
		stream.Content = content;
		stream.ContentOffset = 0x222;
		stream.ContentLength = contentLength;
		return DecodePackBytes(stream, 0, 160 * 396);
	}

	bool Decode3201!(byte[] content, int contentLength)
	{
		if (contentLength < 6404 + 160 * 200 / 128
		 || content[0] != 0xc1 || content[1] != 0xd0 || content[2] != 0xd0 || content[3] != 0)
			return false;
		SetSize(320, 200, RECOILResolution.AppleIIGS1x1);
		PackBytesStream() stream;
		stream.Content = content;
		stream.ContentOffset = 0x1904;
		stream.ContentLength = contentLength;
		for (int y = 0; y < 200; y++) {
			SetAppleIIGSPalette(content, 4 + (y << 5), 0xf);
			if (!DecodePackBytes(stream, y * 320, 160))
				return false;
		}
		return true;
	}

	bool DecodeApfShr!(byte[] content, int contentLength)
	{
		if (contentLength < 1249 || content[4] != 4 || !IsStringAt(content, 5, "MAIN")
		 || content[14] != 0)
			return false;
		int paletteCount = content[13];
		if (paletteCount > 16)
			return false;
		int dirOffset = 0x11 + (paletteCount << 5);
		if (dirOffset >= contentLength)
			return false;
		int mode = content[9] & 0xf0;
		int width = content[11] | content[12] << 8;
		int height = content[dirOffset - 2] | content[dirOffset - 1] << 8;
		int bytesPerLine;
		switch (mode) {
		case 0:
			if ((width & 1) != 0
			 || !SetSize(width, height, RECOILResolution.AppleIIGS1x1))
				return false;
			bytesPerLine = width >> 1;
			break;
		case 0x80:
			if ((width & 3) != 0
			 || !SetSize(width, height << 1, RECOILResolution.AppleIIGS1x2))
				return false;
			bytesPerLine = width >> 2;
			break;
		default:
			return false;
		}
		int multipalOffset = -1;
		int contentOffset = 0;
		if (height == 200) {
			for (int chunkLength = Get32LittleEndian(content, 0);;) {
				if (chunkLength <= 0)
					return false;
				contentOffset += chunkLength;
				if (contentOffset < 0 || contentOffset + 6415 > contentLength)
					break;
				chunkLength = Get32LittleEndian(content, contentOffset);
				if (chunkLength == 6415 && content[contentOffset + 4] == 8
				 && IsStringAt(content, contentOffset + 5, "MULTIPAL")
				 && content[contentOffset + 13] == 200 && content[contentOffset + 14] == 0) {
					multipalOffset = contentOffset + 15;
					break;
				}
			}
		}
		contentOffset = dirOffset + (height << 2);
		if (contentOffset >= contentLength)
			return false;
		PackBytesStream() stream;
		stream.Content = content;
		stream.ContentOffset = contentOffset;
		stream.ContentLength = contentLength;
		for (int y = 0; y < height; y++) {
			if (multipalOffset >= 0)
				SetAppleIIGSPalette(content, multipalOffset + (y << 5), 0);
			else {
				int lineMode = content[dirOffset + (y << 2) + 2];
				int palette = lineMode & 0xf;
				if ((lineMode & 0xf0) != mode || palette >= paletteCount || content[dirOffset + (y << 2) + 3] != 0)
					return false;
				SetAppleIIGSPalette(content, 0xf + (palette << 5), 0);
			}
			if (!DecodePackBytes(stream, y * width, bytesPerLine))
				return false;
		}
		return true;
	}

	// SAM Coupe formats.

	static int GetSamCoupeColor(int c)
	{
		int rgb = 0;
		if ((c & 1) != 0)
			rgb |= 0x000049; // B1
		if ((c & 2) != 0)
			rgb |= 0x490000; // R1
		if ((c & 4) != 0)
			rgb |= 0x004900; // G1
		if ((c & 8) != 0)
			rgb |= 0x242424; // BRIGHT
		if ((c & 0x10) != 0)
			rgb |= 0x000092; // B2
		if ((c & 0x20) != 0)
			rgb |= 0x920000; // R2
		if ((c & 0x40) != 0)
			rgb |= 0x009200; // G2
		return rgb;
	}

	void SetSamCoupePalette!(byte[] content, int colors)
	{
		for (int i = 0; i < colors; i++)
			ContentPalette[i] = GetSamCoupeColor(content[0x6000 + i]);
	}

	void DecodeSamCoupeMode4!(byte[] content)
	{
		SetSamCoupePalette(content, 16);
		SetSize(256, 192, RECOILResolution.SamCoupe1x1);
		DecodeNibbles(content, 0, 128);
	}

	bool DecodeScs4!(byte[] content, int contentLength)
	{
		if (contentLength != 24617 || content[24616] != 0xff)
			return false;
		DecodeSamCoupeMode4(content);
		return true;
	}

	void SetSamCoupeAttrPalette!(byte[] content, int contentOffset)
	{
		for (int i = 0; i < 64; i++)
			ContentPalette[i] = GetSamCoupeColor(content[contentOffset + (i >> 1 & 8) + (i & 7)]);
	}

	bool DecodeSsx!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 6928:
			SetSamCoupeAttrPalette(content, 0x1b00);
			SetSize(256, 192, RECOILResolution.SamCoupe1x1);
			DecodeZx(content, 0, 0x1800, ZxAttributes8x8, 0);
			return true;
		case 12304:
			SetSamCoupeAttrPalette(content, 0x3000);
			SetSize(256, 192, RECOILResolution.SamCoupe1x1);
			DecodeZx(content, ZxBitmapLinear, 0x1800, ZxAttributes8x1, 0);
			return true;
		case 24580:
			SetSamCoupePalette(content, 4);
			SetSize(512, 384, RECOILResolution.SamCoupe1x2);
			for (int y = 0; y < 192; y++) {
				for (int x = 0; x < 512; x++) {
					int c = content[y << 7 | x >> 2] >> ((~x & 3) << 1) & 3;
					Pixels[(y << 10) + x + 512] = Pixels[(y << 10) + x] = ContentPalette[c];
				}
			}
			return true;
		case 24592:
			DecodeSamCoupeMode4(content);
			return true;
		case 98304:
			for (int c = 0; c < 128; c++)
				ContentPalette[c] = GetSamCoupeColor(c);
			SetSize(512, 384, RECOILResolution.SamCoupe1x2);
			DecodeBytes(content, 0);
			return true;
		default:
			return false;
		}
	}

	// Sharp X68000 formats.

	static int GetX68KColor(int color)
	{
		// GGGGGRRR RRBBBBBI -> RRRRRI00 GGGGGI00 BBBBBI00
		int rgb = (color & 0x07c0) << 13 | (color & 0xf800) | (color & 0x3e) << 2;
		if ((color & 1) != 0)
			rgb |= 0x040404;
		return rgb | (rgb >> 6 & 0x030303);
	}

	bool DecodeX68KPicChain!(BitStream! stream, int pixelsOffset, int color)
	{
		for (;;) {
			switch (stream.ReadBits(2)) {
			case 0:
				switch (stream.ReadBit()) {
				case 0:
					return true;
				case 1:
					break;
				default:
					return false;
				}
				switch (stream.ReadBit()) {
				case 0:
					pixelsOffset -= 2;
					break;
				case 1:
					pixelsOffset += 2;
					break;
				default:
					return false;
				}
				break;

			case 1:
				pixelsOffset--;
				break;
			case 2:
				break;
			case 3:
				pixelsOffset++;
				break;
			default:
				return false;
			}

			pixelsOffset += Width;
			if (pixelsOffset >= Width * Height)
				return false;
			Pixels[pixelsOffset] = color;
		}
	}

	bool DecodeX68KPicScreen!(X68KPicStream! stream, int pixelsLength, int platform, int depth)
	{
		for (int pixelsOffset = 0; pixelsOffset < pixelsLength; pixelsOffset++)
			Pixels[pixelsOffset] = -1;
		RecentInts() colors;
		int color = 0;
		for (int pixelsOffset = -1; ;) {
			int length = stream.ReadLength();
			if (length < 0)
				return false;
			while (--length > 0) {
				int got = Pixels[++pixelsOffset];
				if (got < 0)
					Pixels[pixelsOffset] = color;
				else
					color = got;
				if (pixelsOffset >= pixelsLength - 1)
					return true;
			}

			if (depth <= 8) {
				color = stream.ReadBits(depth);
				if (color < 0)
					return false;
				color = ContentPalette[color];
			}
			else {
				switch (stream.ReadBit()) {
				case 0:
					color = stream.ReadBits(depth);
					if (color < 0)
						return false;
					switch (platform) {
					case 0:
						if (depth == 15)
							color <<= 1;
						color = GetX68KColor(color);
						break;
					case 0x11:
						color = GetG6R5B5Color(color);
						break;
					default:
						break;
					}
					colors.Add(color);
					break;
				case 1:
					color = stream.ReadBits(7);
					if (color < 0)
						return false;
					color = colors.Get(color);
					break;
				default:
					return false;
				}
			}
			Pixels[++pixelsOffset] = color;
			if (pixelsOffset >= pixelsLength - 1)
				return true;

			switch (stream.ReadBit()) {
			case 0:
				break;
			case 1:
				if (!DecodeX68KPicChain(stream, pixelsOffset, color))
					return false;
				break;
			default:
				return false;
			}
		}
	}

	bool DecodeX68KPic!(byte[] content, int contentLength)
	{
		if (contentLength < 14 || content[0] != 'P' || content[1] != 'I' || content[2] != 'C')
			return false;
		RECOILResolution resolution = IsStringAt(content, 3, "/MM/") ? RECOILResolution.Msx21x1 : RECOILResolution.X68K1x1;
		X68KPicStream() stream;
		stream.Content = content;
		stream.ContentOffset = 3;
		stream.ContentLength = contentLength;
		for (;;) {
			int b = stream.ReadByte();
			if (b < 0)
				return false;
			if (b == 0x1a)
				break;
			if (b == '/'
			 && resolution == RECOILResolution.Msx21x1
			 && stream.ContentOffset + 4 < contentLength
			 && content[stream.ContentOffset] == 'M'
			 && content[stream.ContentOffset + 1] == 'S') {
				b = content[stream.ContentOffset + 2];
				if (b >= 'A' && b <= 'C')
					resolution = RECOILResolution.Msx2Plus1x1;
			}
		}
		if (!stream.SkipUntilByte(0))
			return false;
		int platform = stream.ReadBits(16);
		int depth = stream.ReadBits(16);
		int width = stream.ReadBits(16);
		int height = stream.ReadBits(16);
		int pixelsLength = width * height;
		switch (platform) {
		case 0:
			if (!SetSize(width, height, resolution))
				return false;
			break;
		case 0x11:
			return depth == 16
				&& SetSize(width, height, RECOILResolution.Pc88Va1x1)
				&& DecodeX68KPicScreen(stream, pixelsLength, 0x11, 16);
		case 0x21:
			if (depth != 16
			 || !SetSize(width, height << 1, RECOILResolution.Pc88Va1x1)
			 || !DecodeX68KPicScreen(stream, pixelsLength, 0x21, 16))
				return false;
			for (int offset = pixelsLength - 1; offset >= 0; offset--) {
				int color = Pixels[offset];
				Pixels[(offset << 1) + 1] = GetG3R3B2Color(color >> 8);
				Pixels[offset << 1] = GetG3R3B2Color(color & 0xff);
			}
			return true;
		case 2:
			if (!SetSize(width, height, RECOILResolution.FmTowns1x1))
				return false;
			stream.ContentOffset += 6;
			break;
		case 0x1f:
			if (!SetSize(width, height, RECOILResolution.X68K1x1))
				return false;
			stream.ContentOffset += 6;
			break;
		default:
			return false;
		}

		switch (depth) {
		case 4:
		case 8:
			for (int c = 0; c < 1 << depth; c++) {
				int color = stream.ReadBits(16);
				if (color < 0)
					return false;
				ContentPalette[c] = GetX68KColor(color);
			}
			break;
		case 15:
		case 16:
			break;
		default:
			return false;
		}
		return DecodeX68KPicScreen(stream, pixelsLength, 0, depth);
	}

	// NEC PC-88 formats.

	void SetPc88EightPixels!(int column, int y, int b)
	{
		for (int x = 0; x < 8; x++) {
			int offset = y * 1280 + column + x;
			Pixels[offset + 640] = Pixels[offset] = (b >> (7 - x) & 0x010101) * 0xff;
		}
	}

	bool DecodeDaVinci!(byte[] content, int contentLength)
	{
		if ((contentLength & 0xff) != 0)
			return false;
		SetSize(640, 400, RECOILResolution.Pc881x2);
		DaVinciStream() rle;
		rle.Content = content;
		rle.ContentOffset = 0;
		rle.ContentLength = contentLength;
		for (int y = 0; y < 200; y++) {
			for (int column = 0; column < 640; column += 8) {
				int b = rle.ReadRle();
				if (b < 0)
					return false;
				SetPc88EightPixels(column, y, b);
			}
		}
		return rle.RepeatCount == 0 && contentLength - rle.ContentOffset < 256;
	}

	bool DecodeArtMaster88!(byte[] content, int contentLength)
	{
		if (contentLength < 42
		 || !IsStringAt(content, 0, "SS_SIF    0.0")
		 || content[0x13] != 'B' || content[0x14] != 'R' || content[0x15] != 'G'
		 || content[0x18] != 0x80 || content[0x19] != 2) // TODO: width != 640
			return false;
		ArtMaster88Stream() rle;
		rle.Content = content;
		rle.ContentOffset = 0x28;
		rle.ContentLength = contentLength;
		if (content[0x10] == 'I' && !rle.SkipChunk())
			return false;
		switch (content[0x1a] | content[0x1b] << 8) {
		case 200:
			SetSize(640, 400, RECOILResolution.Pc881x2);
			if (content[0x12] == 'B' && !rle.SkipChunk())
				return false;
			if (!rle.ReadPlanes(3, 16000))
				return false;
			for (int y = 0; y < 200; y++) {
				for (int column = 0; column < 80; column++) {
					int offset = y * 80 + column;
					SetPc88EightPixels(column << 3, y, rle.Planes[1][offset] << 16 | rle.Planes[2][offset] << 8 | rle.Planes[0][offset]);
				}
			}
			break;
		case 400:
			SetSize(640, 400, RECOILResolution.Pc981x1);
			if (content[0x11] != 'R' || rle.ContentOffset + 0x62 >= contentLength
			 || content[rle.ContentOffset] != 0x62 || content[rle.ContentOffset + 1] != 0)
				return false;
			for (int c = 0; c < 16; c++) {
				int offset = rle.ContentOffset + 2 + c * 6;
				int rgb = content[offset] << 16 | content[offset + 2] << 8 | content[offset + 4];
				if ((rgb & 0xf0f0f0) != 0
				 || content[offset + 1] != 0 || content[offset + 3] != 0 || content[offset + 5] != 0)
					return false;
				ContentPalette[c] = rgb * 0x11;
			}
			rle.ContentOffset += 0x62;
			if (content[0x12] == 'B' && !rle.SkipChunk())
				return false;
			if (!rle.ReadPlanes(4, 32000))
				return false;
			for (int y = 0; y < 400; y++) {
				for (int column = 0; column < 80; column++) {
					int offset = y * 80 + column;
					for (int x = 0; x < 8; x++) {
						int c = 0;
						for (int plane = 0; plane < 4; plane++)
							c |= (rle.Planes[plane][offset] >> (7 - x) & 1) << plane;
						Pixels[y * 640 + (column << 3) + x] = ContentPalette[c];
					}
				}
			}
			break;
		default:
			return false;
		}
		return true;
	}

	// NEC PC-98 formats.

	bool DecodeEbd!(byte[] content, int contentLength)
	{
		if (contentLength < 368 || contentLength % 320 != 48)
			return false;
		for (int c = 0; c < 16; c++) {
			int rgb = content[c * 3] << 16 | content[c * 3 + 1] << 8 | content[c * 3 + 2];
			if ((((rgb >> 4) ^ rgb) & 0x0f0f0f) != 0) {
				if ((rgb & 0xf0f0f0) != 0)
					return false;
				rgb *= 0x11;
			}
			ContentPalette[c] = rgb;
		}
		return DecodeAmigaPlanar(content, 48, 640, contentLength / 320, RECOILResolution.Pc981x1, 4, ContentPalette);
	}

	bool DecodeNl3!(byte[] content, int contentLength)
	{
		Nl3Stream() stream;
		stream.Content = content;
		// XXX: https://emk.name/2015/04/ml1.html contains additional code in nl3.js
		// to skip some initial bytes and use alternative decoding table for some images.
		// This is not necessary for the test files I have.
		stream.ContentOffset = 0;
		stream.ContentLength = contentLength;
		for (int i = 0; i < 64; i++) {
			int c = stream.ReadValue();
			if (c < 0 || c > 127)
				return false;
			c |= stream.ReadValue() << 7;
			if (c < 0 || c >= 9 * 9 * 9)
				return false;
			ContentPalette[i] = Get729Color(c);
		}
		SetSize(160, 100, RECOILResolution.Pc981x1);
		for (int x = 0; x < 160; x++) {
			for (int y = 0; y < 100; y++) {
				int b = stream.ReadRle();
				if (b < 0)
					return false;
				Pixels[y * 160 + x] = ContentPalette[b];
			}
		}
		return true;
	}

	bool DecodeMl1Chain!(X68KPicStream! stream, int pixelsOffset, int rgb)
	{
		for (;;) {
			switch (stream.ReadBit()) {
			case 0:
				break;
			case 1:
				switch (stream.ReadBits(2)) {
				case 0:
					pixelsOffset++;
					break;
				case 1:
					pixelsOffset--;
					break;
				case 2:
					return true;
				case 3:
					switch (stream.ReadBit()) {
					case 0:
						pixelsOffset += 2;
						break;
					case 1:
						pixelsOffset -= 2;
						break;
					default:
						return false;
					}
					break;
				default:
					return false;
				}
				break;
			default:
				return false;
			}
			pixelsOffset += Width;
			if (pixelsOffset < 0 || pixelsOffset >= Width * Height)
				return false;
			Pixels[pixelsOffset] = rgb;
		}
	}

	const int Ml1SingleImage = -1;

	int DecodeMl1Mx1!(X68KPicStream! stream, int imageOffset)
	{
		if (stream.ReadBits(32) != 0x3130301a
		 || stream.ReadBits(32) < 0
		 || stream.ReadBits(16) < 0)
			return -1;
		int left = stream.ReadBits(16);
		int top = stream.ReadBits(16);
		int width = stream.ReadBits(16) - left + 1;
		int height = stream.ReadBits(16) - top + 1;
		for (int i = 0; i < 78 * 8; i++) {
			if (stream.ReadBit() < 0)
				return -1;
		}
		int mode = stream.ReadBits(2);
		int lastColor;
		switch (mode) {
		case 0:
			lastColor = 127;
			break;
		case 1:
		case 2:
			lastColor = stream.ReadBits(7);
			break;
		default:
			return -1;
		}

		if (imageOffset == Ml1SingleImage) {
			if (!SetSize(width, height, RECOILResolution.Pc981x1))
				return -1;
			imageOffset = 0;
		}

		ContentPalette.Fill(0);
		for (int i = 0; i <= lastColor; i++) {
			int j = 0;
			if (mode > 0)
				j = stream.ReadBits(7);
			int c = stream.ReadBits(10);
			if (c < 0 || c >= 9 * 9 * 9)
				return -1;
			ContentPalette[mode == 1 ? j : i] = Get729Color(c);
		}

		const int clean = 1;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++)
				Pixels[imageOffset + y * Width + x] = clean;
		}

		int distance = 1;
		int rgb = 0;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				int pixelsOffset = imageOffset + y * Width + x;
				if (--distance > 0) {
					int old = Pixels[pixelsOffset];
					if (old == clean)
						Pixels[pixelsOffset] = rgb;
					else
						rgb = old;
				}
				else {
					distance = stream.ReadLength();
					if (distance < 0)
						return -1;
					int c = mode == 2 ? stream.ReadLength() - 1 : stream.ReadBits(7);
					if (c < 0 || c >= 128)
						return -1;
					rgb = ContentPalette[c];
					switch (stream.ReadBit()) {
					case 0:
						break;
					case 1:
						if (!DecodeMl1Chain(stream, pixelsOffset, rgb))
							return -1;
						break;
					default:
						return -1;
					}
					Pixels[pixelsOffset] = rgb;
				}
			}
		}
		return distance == 1 && stream.ReadLength() == width * height + 1 ? height : -1;
	}

	bool DecodeMl1!(byte[] content, int contentLength)
	{
		X68KPicStream() stream;
		stream.Content = content;
		stream.ContentOffset = 0;
		stream.ContentLength = contentLength;
		return DecodeMl1Mx1(stream, Ml1SingleImage) > 0;
	}

	bool DecodeMx1Tiles!(Mx1Stream! stream, int width, int height, int shift)
	{
		if (!SetSize(width << shift, height << shift, RECOILResolution.Pc981x1))
			return false;
		for (int y = 0; y < Height; y += height) {
			for (int x = 0; x < Width; x += width) {
				if (!stream.FindImage() || DecodeMl1Mx1(stream, y * Width + x) < 0)
					return false;
			}
		}
		return true;
	}

	bool DecodeMx1!(byte[] content, int contentLength)
	{
		Mx1Stream() stream;
		stream.Content = content;
		stream.ContentOffset = 0;
		stream.ContentLength = contentLength;
		if (!stream.FindImage() || DecodeMl1Mx1(stream, Ml1SingleImage) < 0)
			return false;
		if (!stream.FindImage())
			return true;

		int sameSizeImages = 1;
		int width = Width;
		int height = Height;
		do {
			if (DecodeMl1Mx1(stream, Ml1SingleImage) < 0)
				return false;
			if (sameSizeImages > 0 && Width == width && Height == height)
				sameSizeImages++;
			else {
				if (width < Width)
					width = Width;
				if (sameSizeImages > 0) {
					height *= sameSizeImages;
					sameSizeImages = 0;
				}
				height += Height;
			}
		} while (stream.FindImage());

		stream.ContentOffset = 0;
		switch (sameSizeImages) {
		case 4:
			return DecodeMx1Tiles(stream, width, height, 1);
		case 16:
			return DecodeMx1Tiles(stream, width, height, 2);
		case 0:
			break;
		default:
			height *= sameSizeImages;
			break;
		}

		if (!SetSize(width, height, RECOILResolution.Pc981x1))
			return false;
		Pixels.Fill(0, 0, width * height);
		int imageOffset = 0;
		while (stream.FindImage())
			imageOffset += DecodeMl1Mx1(stream, imageOffset) * width;
		return true;
	}

	bool DecodeZim!(byte[] content, int contentLength)
	{
		if (contentLength < 700 || !IsStringAt(content, 0, "FORMAT-A"))
			return false;
		int contentOffset = 0x200 + ((content[0x1fa] | content[0x1fb] << 8) << 1);
		if (contentOffset + 26 > contentLength
		 || content[contentOffset] != 0 || content[contentOffset + 1] != 0
		 || content[contentOffset + 2] != 0 || content[contentOffset + 3] != 0
		 || content[contentOffset + 0x14] != 1 || content[contentOffset + 0x15] != 0) // TODO: uncompressed
			return false;
		int width = content[contentOffset + 4] + (content[contentOffset + 5] << 8) + 1;
		int height = content[contentOffset + 6] + (content[contentOffset + 7] << 8) + 1;
		if (!SetSize(width, height, RECOILResolution.Pc981x1))
			return false;
		contentOffset += 24;
		if (content[contentOffset - 2] != 0 || content[contentOffset - 1] != 0) {
			if (contentOffset + 66 > contentLength)
				return false;
			for (int c = 0; c < 16; c++) {
				ContentPalette[c] = content[contentOffset + 1] << 16 | content[contentOffset + 2] << 8 | content[contentOffset];
				contentOffset += 4;
			}
		}
		else {
			for (int c = 0; c < 16; c++)
				ContentPalette[c] = GetZxColor(c);
			ContentPalette[8] = 0xffffff;
		}
		int pixelsLength = width * height;
		for (int pixelsOffset = 0; pixelsOffset < pixelsLength; pixelsOffset++)
			Pixels[pixelsOffset] = ContentPalette[0];
		byte[64] flags3;
		byte[512] data;
		ZimStream() stream;
		stream.Content = content;
		stream.ContentOffset = contentOffset;
		stream.ContentLength = contentLength;
		int skip = stream.ReadWord();
		stream.ContentOffset += skip << 1;
		for (;;) {
			int dot = stream.ReadWord();
			switch (dot) {
			case -1:
				return false;
			case 0:
				return true;
			default:
				break;
			}
			int x = stream.ReadWord();
			if (x < 0 || x >= width)
				return false;
			int y = stream.ReadWord();
			if (y < 0 || y >= height)
				return false;
			int len = stream.ReadWord();
			if (len < 0)
				return false;
			stream.ContentLength = stream.ContentOffset + len;
			if (stream.ContentLength >= contentLength)
				return false;
			int size = stream.ReadWord();
			if (size > 512 || (size & 3) != 0 || size << 1 < dot)
				return false;
			int pixelsOffset = y * width + x;
			if (pixelsOffset + dot > pixelsLength)
				return false;
			stream.UnpackFlags2();
			stream.Unpack(stream.Flags2, flags3, 64);
			stream.Unpack(flags3, data, size);
			stream.ContentLength = contentLength;
			for (int i = 1; i < size; i++)
				data[i] ^= data[i - 1];
			for (int i = 2; i < size; i++)
				data[i] ^= data[i - 2];
			size >>= 2;
			for (int i = 0; i < dot; i++) {
				int bit = ~i & 7;
				int c = (data[i >> 3] >> bit & 1) << 3
					  | (data[size + (i >> 3)] >> bit & 1) << 2
					  | (data[2 * size + (i >> 3)] >> bit & 1) << 1
					  | (data[3 * size + (i >> 3)] >> bit & 1);
				Pixels[pixelsOffset + i] = ContentPalette[c];
			}
		}
	}

	bool DecodeQ4!(byte[] content, int contentLength)
	{
		if (contentLength < 22
		 || (content[2] != 2 && (content[1] > 1 || content[3] > 1))
		 || content[8] + (content[9] << 8) != contentLength
		 || !IsStringAt(content, 11, "MAJYO"))
			return false;
		Q4Stream() rle;
		rle.Content = content;
		rle.ContentOffset = 16;
		rle.ContentLength = contentLength;
		int nextChunkOffset = rle.StartChunk();
		if (nextChunkOffset < 0 || !rle.UnpackQ4())
			return false;
		for (int i = 0; i < 16; i++) {
			int rgb = 0;
			for (int c = 0; c < 3; c++) {
				if (rle.ReadRle() < 0)
					return false;
				int b = rle.ReadRle();
				if (b < 0)
					return false;
				rgb = rgb << 8 | b * 0x11;
			}
			ContentPalette[(i & 8) | (i & 1) << 2 | (i >> 1 & 3)] = rgb;
		}
		SetSize(640, 400, RECOILResolution.Pc981x1);
		int chunkPixels = 0;
		for (int i = 0; i < 640 * 400; i++) {
			if (--chunkPixels <= 0) {
				chunkPixels = (content[nextChunkOffset + 4] | content[nextChunkOffset + 5] << 8) << 1;
				rle.Content = content;
				rle.ContentOffset = nextChunkOffset;
				rle.ContentLength = contentLength;
				nextChunkOffset = rle.StartChunk();
				if (nextChunkOffset < 0 || !rle.UnpackQ4())
					return false;
			}
			int b = rle.ReadRle();
			if (b < 0)
				b = 0;
			Pixels[i] = ContentPalette[b];
		}
		return true;
	}

	static int PackPiPlatform(string s)
		=> s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;

	static RECOILResolution GetPiPlatform(byte[] content, int contentOffset, bool highPixel)
	{
		switch (Get32LittleEndian(content, contentOffset)) {
		case PackPiPlatform("TOWN"):
			return RECOILResolution.FmTowns1x1;
		case PackPiPlatform("PC80"):
			return RECOILResolution.Pc801x2;
		case PackPiPlatform("PC88"):
			return RECOILResolution.Pc881x2;
		case PackPiPlatform("PCVA"):
			return highPixel ? RECOILResolution.Pc881x2 : RECOILResolution.Pc88Va1x1;
		case PackPiPlatform("MSX1"):
		case PackPiPlatform("MSX2"):
		case PackPiPlatform("MSXP"):
		case PackPiPlatform("MSXR"):
			return highPixel ? RECOILResolution.Msx21x2 : RECOILResolution.Msx21x1;
		case PackPiPlatform("X68K"):
			return RECOILResolution.X68K1x1;
		default:
			return highPixel ? RECOILResolution.Pc881x2 : RECOILResolution.Pc981x1;
		}
	}

	bool DecodePi!(byte[] content, int contentLength)
	{
		if (contentLength < 18 || content[0] != 'P' || content[1] != 'i')
			return false;
		PiStream() s;
		s.Content = content;
		s.ContentOffset = 2;
		s.ContentLength = contentLength;
		if (!s.SkipUntilByte(0x1a) || !s.SkipUntilByte(0))
			return false;
		int contentOffset = s.ContentOffset;
		if (contentOffset + 14 > contentLength)
			return false;
		int depth = content[contentOffset + 3];
		s.ContentOffset = contentOffset + 14 + (3 << depth);
		if (content[contentOffset] != 0 // TODO: default palette
		 || (depth != 4 && depth != 8)
		 || content[contentOffset + 8] != 0 // TODO: skip
		 || content[contentOffset + 9] != 0)
			return false;
		int width = content[contentOffset + 10] << 8 | content[contentOffset + 11];
		int height = content[contentOffset + 12] << 8 | content[contentOffset + 13];
		RECOILResolution resolution = GetPiPlatform(content, contentOffset + 4, content[contentOffset + 1] == 2 && content[contentOffset + 2] == 1);
		if (!SetScaledSize(width, height, resolution))
			return false;
		if (s.Unpack(width, height, depth)) {
			DecodeR8G8B8Colors(content, contentOffset + 14, 1 << depth, ContentPalette, 0);
			DecodeBytes(s.Indexes, 0);
			return true;
		}
		return false;
	}

	void SetMagPalette!(byte[] content, int paletteOffset, int colors)
	{
		for (int c = 0; c < colors; c++) {
			int offset = paletteOffset + c * 3;
			ContentPalette[c] = content[offset + 1] << 16 | content[offset] << 8 | content[offset + 2]; // GRB
		}
	}

	bool DecodeMaki1!(byte[] content, int contentLength)
	{
		if (contentLength < 1096
		 || content[40] != 0 || content[41] != 0 || content[42] != 0 || content[43] != 0
		 || content[44] != 2 || content[45] != 0x80 || content[46] != 1 || content[47] != 0x90)
			return false;
		SetSize(640, 400, GetPiPlatform(content, 8, false));
		SetMagPalette(content, 48, 16);
		int contentOffset = 1096;

		ushort[8000] haveBuffer;
		BitStream() haveBlock;
		haveBlock.Content = content;
		haveBlock.ContentOffset = 96;
		haveBlock.ContentLength = 1096;
		for (int i = 0; i < 8000; i++) {
			int have = 0;
			if (haveBlock.ReadBit() == 1) {
				if (contentOffset + 1 >= contentLength)
					return false;
				have = content[contentOffset] << 8 | content[contentOffset + 1];
				contentOffset += 2;
			}
			haveBuffer[i] = have;
		}

		int xorYOffset = content[6] == 'A' ? 2 : 0;
		byte[320 * 4] indexBuffer = 0;
		for (int y = 0; y < 400; y++) {
			for (int x = 0; x < 320; x++) {
				int row = y & 3;
				int index = indexBuffer[(row ^ xorYOffset) * 320 + x];
				if ((haveBuffer[(y & ~3) * 20 + (x >> 2)] >> 15 - (row << 2) - (x & 3) & 1) != 0) {
					if (contentOffset >= contentLength)
						return false;
					index ^= content[contentOffset++];
				}
				indexBuffer[row * 320 + x] = index;
				int pixelsOffset = y * 320 + x << 1;
				Pixels[pixelsOffset] = ContentPalette[index >> 4];
				Pixels[pixelsOffset + 1] = ContentPalette[index & 0xf];
			}
		}
		return true;
	}

	static bool UnpackMag(byte[] content, int headerOffset, int contentLength, int bytesPerLine, int height, byte[]! unpacked)
	{
		BitStream() haveDelta;
		haveDelta.Content = content;
		haveDelta.ContentOffset = headerOffset + Get32LittleEndian(content, headerOffset + 12);
		haveDelta.ContentLength = contentLength;
		int deltaOffset = headerOffset + Get32LittleEndian(content, headerOffset + 16);
		int colorOffset = headerOffset + Get32LittleEndian(content, headerOffset + 24);
		if (haveDelta.ContentOffset < 0 || deltaOffset < 0 || colorOffset < 0)
			return false;
		byte[]# deltas = new byte[bytesPerLine + 3 >> 2];
		deltas.Fill(0, 0, bytesPerLine + 3 >> 2);
		for (int y = 0; y < height; y++) {
			int delta = 0; // initialize only to avoid warnings
			for (int x = 0; x < bytesPerLine; x++) {
				if ((x & 1) == 0) {
					delta = deltas[x >> 2];
					if ((x & 2) == 0) {
						switch (haveDelta.ReadBit()) {
						case 0:
							break;
						case 1:
							if (deltaOffset >= contentLength)
								return false;
							delta ^= content[deltaOffset++];
							deltas[x >> 2] = delta;
							break;
						default:
							return false;
						}
						delta >>= 4;
					}
					else
						delta &= 0xf;
				}
				if (delta == 0) {
					if (colorOffset >= contentLength)
						return false;
					unpacked[y * bytesPerLine + x] = content[colorOffset++];
				}
				else {
					const byte[16] deltaX = { 0, 2, 4, 8, 0, 2, 0, 2, 4, 0, 2, 4, 0, 2, 4, 0 };
					const byte[16] deltaY = { 0, 0, 0, 0, 1, 1, 2, 2, 2, 4, 4, 4, 8, 8, 8, 16 };
					int sourceX = x - deltaX[delta];
					int sourceY = y - deltaY[delta];
					if (sourceX < 0 || sourceY < 0)
						return false;
					unpacked[y * bytesPerLine + x] = unpacked[sourceY * bytesPerLine + sourceX];
				}
			}
			if ((bytesPerLine & 1) != 0 && delta == 0)
				colorOffset++;
			if ((bytesPerLine + 1 & 2) != 0 && (deltas[bytesPerLine >> 2] & 0xf) == 0)
				colorOffset += 2;
		}
		return true;
	}

	bool DecodeMag!(byte[] content, int contentLength)
	{
		if (contentLength < 8)
			return false;
		if (IsStringAt(content, 0, "MAKI01A ") || IsStringAt(content, 0, "MAKI01B "))
			return DecodeMaki1(content, contentLength);
		if (!IsStringAt(content, 0, "MAKI02  "))
			return false;
		int headerOffset = 0;
		do {
			if (headerOffset >= contentLength)
				return false;
		} while (content[headerOffset++] != 0x1a);
		if (headerOffset + (32 + 16 * 3) > contentLength
		 || content[headerOffset] != 0)
			return false;
		int width = content[headerOffset + 8] - content[headerOffset + 4] + (content[headerOffset + 9] - content[headerOffset + 5] << 8) + 1;
		int height = content[headerOffset + 10] - content[headerOffset + 6] + (content[headerOffset + 11] - content[headerOffset + 7] << 8) + 1;
		int bytesPerLine;
		int colors;
		if (content[headerOffset + 3] < 0x80) {
			bytesPerLine = width + 1 >> 1;
			colors = 16;
		}
		else {
			if (headerOffset + (32 + 256 * 3) >= contentLength)
				return false;
			bytesPerLine = width;
			colors = 256;
		}
		RECOILResolution resolution;
		int msxMode = 0;
		switch (content[headerOffset + 1]) {
		case 0x00:
		case 0x88:
			resolution = (content[headerOffset + 3] & 1) == 0 ? RECOILResolution.Pc88Va1x1 : RECOILResolution.Pc881x2;
			break;
		case 0x03:
			msxMode = content[headerOffset + 2] & 0xfc; // mask out horizontal alignment
			switch (msxMode) {
			case 0x00:
			case 0x14:
			case 0x54:
				resolution = RECOILResolution.Msx21x1;
				break;
			case 0x04:
				resolution = RECOILResolution.Msx21x2;
				break;
			case 0x10:
			case 0x50:
				resolution = RECOILResolution.Msx22x1i;
				break;
			case 0x20:
			case 0x40:
				if (colors == 16)
					width >>= 1;
				resolution = RECOILResolution.Msx2Plus2x1i;
				break;
			case 0x24:
			case 0x44:
				if (colors == 16)
					width >>= 1;
				resolution = RECOILResolution.Msx2Plus1x1;
				break;
			case 0x60:
				width = bytesPerLine << 2;
				resolution = RECOILResolution.Msx21x1i;
				break;
			case 0x64:
				width = bytesPerLine << 2;
				resolution = RECOILResolution.Msx21x2;
				break;
			default:
				return false;
			}
			break;
		case 0x62: // untested PC-98XA
		case 0x70: // untested PC-9821
			resolution = RECOILResolution.Pc981x1;
			break;
		case 0x68:
			resolution = RECOILResolution.X68K1x1;
			break;
		case 0x80:
			resolution = RECOILResolution.Pc801x2;
			break;
		case 0x99: // untested
			resolution = RECOILResolution.Macintosh1x1;
			break;
		// case 0xff: Hellon - untested
		default: // try to decode anyway
			resolution = (content[headerOffset + 3] & 1) == 0 ? RECOILResolution.Msx21x1 : RECOILResolution.Msx21x2; // arbitrary
			break;
		}
		if (!SetScaledSize(width, height, resolution))
			return false;

		byte[]# unpacked = new byte[bytesPerLine * height];
		if (!UnpackMag(content, headerOffset, contentLength, bytesPerLine, height, unpacked))
			return false;
		SetMagPalette(content, headerOffset + 32, colors);
		switch (msxMode) {
		case 0x20:
		case 0x24:
			DecodeMsxYjkScreen(unpacked, 0, true);
			break;
		case 0x40:
		case 0x44:
			DecodeMsxYjkScreen(unpacked, 0, false);
			break;
		case 0x60:
		case 0x64:
			DecodeMsx6(unpacked, 0);
			break;
		default:
			if (colors == 16)
				DecodeNibbles(unpacked, 0, bytesPerLine);
			else
				DecodeBytes(unpacked, 0);
			break;
		}
		return true;
	}

	// Commodore 128 formats.

	bool DecodeVbm!(byte[] content, int contentLength)
	{
		if (contentLength < 9 || content[0] != 'B' || content[1] != 'M' || content[2] != 0xcb || content[3] != 2)
			return false;
		int width = content[4] << 8 | content[5];
		int height = content[6] << 8 | content[7];
		return SetSize(width, height, RECOILResolution.C1281x1)
			&& DecodeBlackAndWhite(content, 8, contentLength, false, 0xffffff);
	}

	bool DecodeBrus!(byte[] content, int contentLength)
	{
		if (contentLength < 20 || !IsStringAt(content, 2, "BRUS")
		 || content[6] != 4 || content[10] != 1 || content[11] != 2)
			return false;
		const int maxColumns = 90;
		int columns = content[12];
		if (columns == 0 || columns > maxColumns)
			return false;
		const int maxHeight = 700;
		int height = content[13] | content[14] << 8;
		if (height == 0 || height > maxHeight)
			return false;
		int width = columns << 3;
		SetSize(width, height, RECOILResolution.C1281x1);

		int bitmapLength = height * columns;
		byte[maxHeight * maxColumns] bitmap;
		PgcStream() rle;
		rle.Content = content;
		rle.ContentOffset = 18;
		rle.ContentLength = contentLength;
		if (!rle.Unpack(bitmap, 0, 1, bitmapLength))
			return false;
		int contentOffset = rle.ContentOffset;
		if (contentOffset + 4 >= contentLength
		 || !IsStringAt(content, contentOffset, "COLR")) {
			// BASIC 8
			return DecodeBlackAndWhite(bitmap, 0, bitmapLength, false, 0xffffff);
		}

		// I Paint
		rle.ContentOffset = contentOffset + 4;
		byte[2 * maxColumns] colors;
		for (int y = 0; y < height; y++) {
			if ((y & 7) == 0 && !rle.Unpack(colors, 0, 1, columns << 1))
				return false;
			for (int x = 0; x < width; x++) {
				int column = x >> 3;
				int c = colors[(y & 1) * columns + column];
				if ((bitmap[y * columns + column] >> (~x & 7) & 1) == 0)
					c >>= 4;
				const int[16] palette = {
					0x000000,
					0x555555,
					0x0000aa,
					0x5555ff,
					0x00aa00,
					0x55ff55,
					0x00aaaa,
					0x55ffff,
					0xaa0000,
					0xff5555,
					0xaa00aa,
					0xff55ff,
					0xaa5500,
					0xffff55,
					0xaaaaaa,
					0xffffff
				};
				Pixels[y * width + x] = palette[c & 0xf];
			}
		}
		return true;
	}

	// Commodore 16 formats.

	void SetC16Palette!()
	{
		byte[] pal = resource<byte[]>("c16.pal");
		for (int i = 0; i < 256; i++)
			ContentPalette[i] = pal[i * 3] << 16 | pal[i * 3 + 1] << 8 | pal[i * 3 + 2];
	}

	bool DecodeP4i!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 10050:
			if (IsStringAt(content, 0x3fc, "MULT")) {
				SetSize(320, 200, RECOILResolution.C162x1);
				SetC16Palette();
				for (int y = 0; y < 200; y++) {
					for (int x = 0; x < 320; x++) {
						int offset = (y & ~7) * 40 + (x & ~7) + (y & 7);
						int c = content[0x802 + offset] >> (~x & 6) & 3;
						switch (c) {
						case 0:
							c = content[0x401];
							break;
						case 1:
							offset >>= 3;
							c = (content[0x402 + offset] & 0xf0) | (content[2 + offset] & 7);
							break;
						case 2:
							offset >>= 3;
							c = (content[0x402 + offset] & 0xf) << 4 | content[2 + offset] >> 4;
							break;
						default:
							c = content[0x400];
							break;
						}
						Pixels[y * 320 + x] = ContentPalette[c];
					}
				}
			}
			else {
				SetSize(320, 200, RECOILResolution.C161x1);
				SetC16Palette();
				for (int y = 0; y < 200; y++) {
					for (int x = 0; x < 320; x++) {
						int offset = (y & ~7) * 40 + (x & ~7) + (y & 7);
						int c = content[0x802 + offset] >> (~x & 7) & 1;
						offset >>= 3;
						if (c == 0)
							c = (content[0x402 + offset] & 0xf) << 4 | content[2 + offset] >> 4;
						else
							c = (content[0x402 + offset] & 0xf0) | (content[2 + offset] & 7);
						Pixels[y * 320 + x] = ContentPalette[c];
					}
				}
			}
			break;
		case 2050:
			SetSize(256, 64, RECOILResolution.C162x1);
			SetC16Palette();
			for (int y = 0; y < 64; y++) {
				for (int x = 0; x < 256; x++) {
					const byte[4] logoColors = { 0, 0x13, 0x15, 0x17 };
					int c = logoColors[content[2 + ((x & ~7) << 3) + y] >> (~x & 6) & 3];
					Pixels[(y << 8) + x] = ContentPalette[c];
				}
			}
			break;
		default:
			return false;
		}
		return true;
	}

	// Commodore 64 formats.

	bool Decode64c!(byte[] content, int contentLength)
	{
		if (contentLength < 10 || contentLength > 2050 || content[0] != 0)
			return false;
		SetSize(256, contentLength + 253 >> 8 << 3, RECOILResolution.C641x1);
		DecodeBlackAndWhiteFont(content, 2, contentLength, 8);
		return true;
	}

	bool DecodeG!(byte[] content, int contentLength)
	{
		if (contentLength != 514 || content[0] != 0x42 || content[1] != 0)
			return false;
		SetSize(256, 16, RECOILResolution.C641x1);
		DecodeBlackAndWhiteFont(content, 2, 514, 8);
		return true;
	}

	bool DecodeCle!(byte[] content, int contentLength)
	{
		if (contentLength != 8194)
			return false;
		SetSize(320, 200, RECOILResolution.C641x1);
		int[4] palette;
		palette[0] = C64Palette[content[8004] & 0xf];
		palette[1] = C64Palette[content[8002] >> 4];
		palette[2] = C64Palette[content[8002] & 0xf];
		palette[3] = C64Palette[content[8003] & 0xf];
		for (int y = 0; y < 200; y++) {
			for (int x = 0; x < 320; x++)
				Pixels[y * 320 + x] = palette[content[2 + (y & ~7) * 40 + (x & ~7) + (y & 7)] >> (~x & 6) & 3];
		}
		return true;
	}

	bool Decode4bt!(byte[] content, int contentLength)
	{
		if (contentLength < 5 || !IsStringAt(content, 0, "GOD0") || content[contentLength - 1] != 0xad)
			return false;
		byte[32000] unpacked;
		GoDotStream() rle;
		rle.Content = content;
		rle.ContentOffset = 4;
		rle.ContentLength = contentLength - 1;
		if (!rle.Unpack(unpacked, 0, 1, 32000))
			return false;
		SetSize(320, 200, RECOILResolution.C641x1);
		for (int y = 0; y < 200; y++) {
			for (int x = 0; x < 320; x++) {
				const byte[16] byBrightness = { 0, 6, 9, 11, 2, 4, 8, 12, 14, 10, 5, 15, 3, 7, 13, 1 };
				int c = unpacked[(y & ~7) * 160 + ((x & ~7) + (y & 7) << 2) + (x >> 1 & 3)];
				Pixels[y * 320 + x] = C64Palette[byBrightness[(x & 1) == 0 ? c >> 4 : c & 0xf]];
			}
		}
		return true;
	}

	const int FliBugCharacters = 3;

	void DecodeC64HiresFrame!(byte[] content, int bitmapOffset, int videoMatrixOffset, int pixelsOffset)
	{
		bool afli = Width == 320 - FliBugCharacters * 8;
		for (int y = 0; y < Height; y++) {
			for (int x = 0; x < Width; x++) {
				int offset = (y & ~7) * 40 + (x & ~7) + (y & 7);
				int c = content[bitmapOffset + offset] >> (~x & 7) & 1;
				int v;
				if (videoMatrixOffset >= 0) {
					offset >>= 3;
					if (afli)
						offset += (y & 7) << 10;
					v = content[videoMatrixOffset + offset];
				}
				else
					v = -videoMatrixOffset;
				c = c == 0 ? v & 0xf : v >> 4;
				Pixels[pixelsOffset + y * Width + x] = C64Palette[c];
			}
		}
	}

#if FUNPAINT_BORDER
	const int FunPaintBackground = -0x3f5a;
#else
	const int FunPaintBackground = 0;
#endif
	const int GunPaintBackground = -0x3f51;

	void DecodeC64MulticolorFrame!(byte[] content, int bitmapOffset, int videoMatrixOffset, int colorOffset, int background, int pixelsOffset)
	{
		bool fli = Width == 320 - FliBugCharacters * 8;
		bool bottomBfli = pixelsOffset != 0 && Height == 400;
		for (int y = 0; y < 200; y++) {
			int lineBackground;
			if (background >= 0)
				lineBackground = background;
#if FUNPAINT_BORDER
			else if (background == FunPaintBackground && y >= 100)
				lineBackground = content[0x833a - 100 + y];
#endif
			else if (background == GunPaintBackground && y >= 177)
				lineBackground = content[y < 197 ? 0x47ea - 177 + y : 0x47fd];
			else
				lineBackground = content[y - background];
			for (int x = 0; x < Width; x++) {
				int c = lineBackground;
				int i = x + LeftSkip;
				if (i >= 0) {
					int offset = (y & ~7) * 40 + (i & ~7) + (y & 7);
					if (bottomBfli)
						offset = offset - (24 - FliBugCharacters) * 8 & 0x1fff;
					switch (content[bitmapOffset + offset] >> (~i & 6) & 3) {
					case 1:
						offset >>= 3;
						if (fli)
							offset += (y & 7) << 10;
						c = content[videoMatrixOffset + offset] >> 4;
						break;
					case 2:
						offset >>= 3;
						if (fli)
							offset += (y & 7) << 10;
						c = content[videoMatrixOffset + offset];
						break;
					case 3:
						c = colorOffset < 0 ? content[-colorOffset] : content[colorOffset + (offset >> 3)];
						break;
					default:
						break;
					}
				}
				Pixels[pixelsOffset + y * Width + x] = C64Palette[c & 0xf];
			}
		}
	}

	bool DecodeC64Multicolor!(int width, byte[] content, int bitmapOffset, int videoMatrixOffset, int colorOffset, int background)
	{
		SetSize(width, 200, RECOILResolution.C642x1);
		DecodeC64MulticolorFrame(content, bitmapOffset, videoMatrixOffset, colorOffset, background, 0);
		return true;
	}

	bool DecodeOcp!(byte[] content, int contentLength)
		=> contentLength == 10018 && DecodeC64Multicolor(320, content, 2, 0x1f42, 0x233a, content[0x232b]);

	bool DecodeC64Hir!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 8002: // FGS, GIH, HBM, HIR, HPI
		case 8194: // GCD, MON
			break;
		default:
			return false;
		}
		SetSize(320, 200, RECOILResolution.C641x1);
		DecodeC64HiresFrame(content, 2, -0x10, 0);
		return true;
	}

	bool DecodeIhe!(byte[] content, int contentLength)
	{
		if (contentLength != 16194)
			return false;
		SetSize(320, 200, RECOILResolution.C641x1, 2);
		DecodeC64HiresFrame(content, 2, -0x0c, 0);
		DecodeC64HiresFrame(content, 0x2002, -0x0c, 320 * 200);
		return ApplyBlend();
	}

	bool DecodeIph!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 9002: // IPH
		case 9003: // HPC
		case 9009: // AAS, ART
			break;
		default:
			return false;
		}
		SetSize(320, 200, RECOILResolution.C641x1);
		DecodeC64HiresFrame(content, 2, 0x1f42, 0);
		return true;
	}

	bool DecodeIsh!(byte[] content)
	{
		SetSize(320, 200, RECOILResolution.C641x1);
		DecodeC64HiresFrame(content, 2, 0x2002, 0);
		return true;
	}

	bool DecodeDd!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 9026:
		case 9218:
		case 9346:
			break;
		default:
			return false;
		}
		SetSize(320, 200, RECOILResolution.C641x1);
		DecodeC64HiresFrame(content, 0x402, 2, 0);
		return true;
	}

	bool DecodeJj!(byte[] content, int contentLength)
	{
		if (contentLength < 2)
			return false;
		byte[9026] unpacked;
		C64KoalaStream() rle;
		rle.Content = content;
		rle.ContentOffset = 2;
		rle.ContentLength = contentLength;
		return rle.UnpackC64(unpacked, 9026)
			&& DecodeDd(unpacked, 9026);
	}

	bool DecodeHfc!(byte[] content, int contentLength)
	{
		if (contentLength != 16386)
			return false;
		SetSize(320 - FliBugCharacters * 8, 112, RECOILResolution.C641x1);
		DecodeC64HiresFrame(content, 2 + FliBugCharacters * 8, 0x2002 + FliBugCharacters, 0);
		return true;
	}

	bool DecodeAfl!(byte[] content, int contentLength)
	{
		if (contentLength != 16385)
			return false;
		SetSize(320 - FliBugCharacters * 8, 200, RECOILResolution.C641x1);
		DecodeC64HiresFrame(content, 0x2002 + FliBugCharacters * 8, 2 + FliBugCharacters, 0);
		return true;
	}

	bool DecodePmg!(byte[] content, int contentLength)
		=> contentLength == 9332
			&& DecodeC64Multicolor(320, content, 0x74, 0x2074, -0x1fb7, content[0x1fb4]);

	bool DecodeKoa!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 10001: // KOA
			return DecodeC64Multicolor(320, content, 0, 0x1f40, 0x2328, content[0x2710]);
		case 10003: // GIG, KLA, KOA
		case 10006: // RPM
			return DecodeC64Multicolor(320, content, 2, 0x1f42, 0x232a, content[0x2712]);
		default:
			return false;
		}
	}

	bool DecodeGg!(byte[] content, int contentLength)
	{
		if (contentLength < 2)
			return false;
		byte[10003] unpacked;
		C64KoalaStream() rle;
		rle.Content = content;
		rle.ContentOffset = 2;
		rle.ContentLength = contentLength;
		return rle.UnpackC64(unpacked, 10003)
			&& DecodeKoa(unpacked, 10003);
	}

	bool DecodeDol!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 10241: // VIC
		case 10242: // DOL
		case 10050: // VID
			break;
		default:
			return false;
		}
		return DecodeC64Multicolor(320, content, 0x802, 0x402, 2, content[0x7ea]);
	}

	bool DecodeAmi!(byte[] content, int contentLength)
	{
		if (contentLength < 2)
			return false;
		byte[10259] unpacked;
		DrpStream() rle;
		rle.Content = content;
		rle.ContentOffset = 2;
		rle.ContentLength = contentLength;
		rle.Escape = 0xc2;
		return rle.UnpackC64(unpacked, 10259)
			&& DecodeKoa(unpacked, 10003);
	}

	bool DecodeHlf!(byte[] content, int contentLength)
	{
		if (contentLength != 24578)
			return false;
		SetSize(320 , 200, RECOILResolution.C641x1, 2);
		DecodeC64HiresFrame(content, 2, 0x2402, 0);
		DecodeC64HiresFrame(content, 0x4002, 0x2802, 320 * 200);
		return ApplyBlend();
	}

	bool DecodeMci!(byte[] content, int contentLength)
	{
		if (contentLength != 19434)
			return false;
		SetSize(320, 200, RECOILResolution.C641x1, 2);
		DecodeC64MulticolorFrame(content, 0x402, 2, 0x4802, content[0x3ea], 0);
		LeftSkip = -1;
		DecodeC64MulticolorFrame(content, 0x2402, 0x4402, 0x4802, content[0x3ea], 320 * 200);
		return ApplyBlend();
	}

	bool DecodeDrz!(byte[] content, int contentLength)
	{
		byte[10051] unpacked;
		content = DrpStream.UnpackFile(content, contentLength, "DRAZPAINT 1.4", unpacked, 10051);
		return content != null
			&& DecodeC64Multicolor(320, content, 0x802, 0x402, 2, content[0x2742]);
	}

	bool DecodeDrl!(byte[] content, int contentLength)
	{
		byte[18242] unpacked;
		content = DrpStream.UnpackFile(content, contentLength, "DRAZLACE! 1.0", unpacked, 18242);
		if (content == null)
			return false;
		int shift = content[0x2744];
		if (shift > 1)
			return false;
		SetSize(320, 200, shift == 0 ? RECOILResolution.C642x1 : RECOILResolution.C641x1, 2);
		DecodeC64MulticolorFrame(content, 0x802, 0x402, 2, content[0x2742], 0);
		LeftSkip = -shift;
		DecodeC64MulticolorFrame(content, 0x2802, 0x402, 2, content[0x2742], 320 * 200);
		return ApplyBlend();
	}

	void DecodeMleFrame!(byte[] content, int contentOffset, int pixelsOffset)
	{
		for (int y = 0; y < 56; y++) {
			for (int x = 0; x < 320; x++) {
				int c = 0;
				int i = x + LeftSkip;
				if (i >= 0) {
					int ch = (y >> 3) * 40 + (i >> 3);
					if (ch < 256) {
						const byte[4] colors = { 0, 9, 8, 5 };
						c = colors[content[contentOffset + (ch << 3) + (y & 7)] >> (~i & 6) & 3];
					}
				}
				Pixels[pixelsOffset + y * Width + x] = C64Palette[c];
			}
		}
	}

	bool DecodeMle!(byte[] content, int contentLength)
	{
		if (contentLength != 4098)
			return false;
		SetSize(320, 56, RECOILResolution.C641x1, 2);
		DecodeMleFrame(content, 2050, 0);
		LeftSkip = -1;
		DecodeMleFrame(content, 2, 320 * 56);
		return ApplyBlend();
	}

	bool DecodeHimUnpacked!(byte[] content)
	{
		SetSize(320 - FliBugCharacters * 8, 192, RECOILResolution.C641x1);
		DecodeC64HiresFrame(content, 2 + 40 * 8 + FliBugCharacters * 8, 0x2002 + 40 + FliBugCharacters, 0);
		return true;
	}

	bool DecodeHim!(byte[] content, int contentLength)
	{
		if (contentLength < 18 || content[0] != 0 || content[1] != 0x40)
			return false;
		if (content[3] == 0xff)
			return contentLength == 16385 && DecodeHimUnpacked(content);

		if (content[2] + (content[3] << 8) != 0x4000 - 3 + contentLength
		 || content[4] != 0xf2 || content[5] != 0x7f)
			return false;
		byte[16372] unpacked;
		HimStream() rle;
		rle.Content = content;
		rle.ContentOffset = contentLength - 1;
		for (int unpackedOffset = 0x3ff3; unpackedOffset >= 2 + 320; unpackedOffset--) {
			int b = rle.ReadRle();
			if (b < 0)
				return false;
			unpacked[unpackedOffset] = b;
		}
		return DecodeHimUnpacked(unpacked);
	}

	bool DecodeEci!(byte[] content, int contentLength)
	{
		if (contentLength != 32770)
			return false;
		SetSize(320 - FliBugCharacters * 8, 200, RECOILResolution.C641x1, 2);
		DecodeC64HiresFrame(content, 2 + FliBugCharacters * 8, 0x2002 + FliBugCharacters, 0);
		DecodeC64HiresFrame(content, 0x4002 + FliBugCharacters * 8, 0x6002 + FliBugCharacters, 296 * 200);
		return ApplyBlend();
	}

	bool DecodeEcp!(byte[] content, int contentLength)
	{
		if (contentLength < 6)
			return false;
		byte[32770] unpacked;
		DrpStream() rle;
		rle.Content = content;
		rle.ContentOffset = 3;
		rle.ContentLength = contentLength;
		rle.Escape = content[2];
		return rle.Unpack(unpacked, 2, 1, 32770)
			&& DecodeEci(unpacked, 32770);
	}

	bool DecodeFli!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 17218: // FD2
		case 17409: // FLI
		case 17410: // VIC
			break;
		default:
			return false;
		}
		DecodeC64Multicolor(320 - FliBugCharacters * 8, content, 0x2402 + FliBugCharacters * 8, 0x402 + FliBugCharacters, 2 + FliBugCharacters, 0);
		return true;
	}

	bool DecodeBml!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 17474: // BML
		case 17665: // VIC
		case 17666: // VIC
			break;
		default:
			return false;
		}
		DecodeC64Multicolor(320 - FliBugCharacters * 8, content, 0x2502 + FliBugCharacters * 8, 0x502 + FliBugCharacters, 0x102 + FliBugCharacters, -2);
		return true;
	}

	bool DecodeFbi!(byte[] content, int contentLength)
	{
		byte[17216] unpacked;
		int unpackedOffset = unpacked.Length;
		for (int contentOffset = contentLength; contentOffset > 18; ) {
			int count = 1;
			int b = content[--contentOffset];
			if (b == content[2]) {
				if (contentOffset <= 19)
					return false;
				count = content[--contentOffset];
				if (count == 0)
					count = 256;
				b = content[--contentOffset];
			}
			if (unpackedOffset < count)
				return false;
			do
				unpacked[--unpackedOffset] = b;
			while (--count > 0);
		}
		if (unpackedOffset != 0)
			return false;
		DecodeC64Multicolor(320 - FliBugCharacters * 8, unpacked, 0x2400 + FliBugCharacters * 8, 0x400 + FliBugCharacters, FliBugCharacters, 0);
		return true;
	}

	bool DecodeFfli!(byte[] content, int contentLength)
	{
		if (contentLength != 26115 || content[2] != 'f')
			return false;
		SetSize(320 - FliBugCharacters * 8, 200, RECOILResolution.C642x1, 2);
		DecodeC64MulticolorFrame(content, 0x2503 + FliBugCharacters * 8, 0x503 + FliBugCharacters, 0x103 + FliBugCharacters, -3, 0);
		DecodeC64MulticolorFrame(content, 0x2503 + FliBugCharacters * 8, 0x4503 + FliBugCharacters, 0x103 + FliBugCharacters, -0x6503, 296 * 200);
		return ApplyBlend();
	}

	bool DecodeIfli!(byte[] content, int bitmap1Offset, int bitmap2Offset, int videoMatrix1Offset, int videoMatrix2Offset, int colorOffset, int background)
	{
		SetSize(320 - FliBugCharacters * 8, 200, RECOILResolution.C641x1, 2);
		DecodeC64MulticolorFrame(content, bitmap1Offset + FliBugCharacters * 8, videoMatrix1Offset + FliBugCharacters, colorOffset + FliBugCharacters, background, 0);
		LeftSkip = -1;
		DecodeC64MulticolorFrame(content, bitmap2Offset + FliBugCharacters * 8, videoMatrix2Offset + FliBugCharacters, colorOffset + FliBugCharacters, background, 296 * 200);
		return ApplyBlend();
	}

	bool DecodePpUnpacked!(byte[] content)
		=> DecodeIfli(content, 0x2402, 0x6402, 0x402, 0x4402, 2, content[0x4381]);

	bool DecodePp!(byte[] content, int contentLength)
	{
		if (contentLength < 8)
			return false;
		if (content[2] == 0x10 && content[3] == 0x10 && content[4] == 0x10) {
			byte[33602] unpacked;
			CmpStream() rle;
			rle.Content = content;
			rle.ContentOffset = 6;
			rle.ContentLength = contentLength;
			rle.Escape = content[5];
			return rle.Unpack(unpacked, 2, 1, 33602)
				&& rle.ReadRle() < 0
				&& DecodePpUnpacked(unpacked);
		}
		return contentLength == 33602 && DecodePpUnpacked(content);
	}

	bool DecodeGun!(byte[] content, int contentLength)
	{
		if (contentLength != 33602 && contentLength != 33603)
			return false;
		//if (!IsStringAt(content, 0x3ea, "GUNPAINT (JZ)   "))
		//	return false;
		return DecodeIfli(content, 0x2002, 0x6402, 2, 0x4402, 0x4002, GunPaintBackground);
	}

	bool DecodeFunUnpacked!(byte[] content)
		=> DecodeIfli(content, 0x2012, 0x63fa, 0x12, 0x43fa, 0x4012, FunPaintBackground);

	bool DecodeC64Fun!(byte[] content, int contentLength)
	{
		if (contentLength < 18 || !IsStringAt(content, 2, "FUNPAINT (MT) "))
			return false;
		if (content[16] != 0) {
			byte[33694] unpacked;
			DrpStream() rle;
			rle.Content = content;
			rle.ContentOffset = 18;
			rle.ContentLength = contentLength;
			rle.Escape = content[17];
			return rle.Unpack(unpacked, 18, 1, 33694)
				&& rle.ReadRle() < 0
				&& DecodeFunUnpacked(unpacked);
		}
		return contentLength == 33694 && DecodeFunUnpacked(content);
	}

	bool DecodeBfli!(byte[] content, int contentLength)
	{
		if (contentLength != 33795 || content[2] != 'b')
			return false;
		SetSize(320 - FliBugCharacters * 8, 400, RECOILResolution.C642x1);
		DecodeC64MulticolorFrame(content, 0x2403 + FliBugCharacters * 8, 0x403 + FliBugCharacters, 3 + FliBugCharacters, 0, 0);
		DecodeC64MulticolorFrame(content, 0x6403, 0x4403, 3, 0, 296 * 200);
		return true;
	}

	bool DecodeLp3!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 4098:
		case 4174:
			break;
		default:
			return false;
		}
		if (content[0] != 0 || content[1] != 0x18)
			return false;
		SetSize(320, 400, RECOILResolution.C642x1);
		byte[4] colors;
		if (contentLength == 4174) {
			colors[0] = content[2 + 0x7fb] & 0xf;
			colors[1] = content[2 + 0x7fd] & 0xf;
			colors[2] = content[2 + 0x7fe] & 0xf;
			colors[3] = content[2 + 0x7fc] & 7;
		}
		else {
			colors[0] = 0;
			colors[1] = 0xa;
			colors[2] = 2;
			colors[3] = 1;
		}
		for (int y = 0; y < 400; y++) {
			for (int x = 0; x < 320; x++) {
				int c = content[2 + (y >> 3) * 40 + (x >> 3)];
				c = content[0x802 + (c << 3) + (y & 7)] >> (~x & 6) & 3;
				Pixels[y * 320 + x] = C64Palette[colors[c]];
			}
		}
		return true;
	}

	bool DecodeVic!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 9002:
		case 9003:
		case 9009:
			return DecodeIph(content, contentLength);
		case 10018:
			return DecodeOcp(content, contentLength);
		case 10241:
		case 10242:
			return DecodeDol(content, contentLength);
		case 17218:
		case 17409:
		case 17410:
			return DecodeFli(content, contentLength);
		case 17474:
		case 17665:
		case 17666:
			return DecodeBml(content, contentLength);
		case 18242:
			return DecodeDrl(content, contentLength);
		case 33602:
		case 33603:
			return DecodeGun(content, contentLength);
		case 33694:
			return DecodeC64Fun(content, contentLength);
		default:
			return false;
		}
	}

	bool DecodeA!(byte[] content, int contentLength)
	{
		if (contentLength != 8130 || content[0] != 0x42 || content[1] != 0)
			return false;
		const int spriteWidth = 24;
		const int spriteHeight = 21;
		const int horizontalGap = 2;
		const int verticalGap = 2;
		const int width = 16 * spriteWidth + 16 * horizontalGap;
		const int height = 8 * spriteHeight + 7 * verticalGap;
		SetSize(width, height, RECOILResolution.C642x1);
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				int c = 11; // gray background
				int row = y % (spriteHeight + verticalGap);
				if (row < spriteHeight) {
					int column = x % (spriteWidth + horizontalGap);
					if (column < spriteWidth) {
						int spriteNo = x / (spriteWidth + horizontalGap) + (y / (spriteHeight + verticalGap) << 4);
						if (spriteNo < 127) {
							int spriteOffset = 2+ (spriteNo << 6);
							switch (content[spriteOffset + row * 3 + (column >> 3)] >> (~column & 6) & 3) {
							case 1:
								c = 0; // black;
								break;
							case 2:
								c = content[spriteOffset + 63] & 0xf;
								break;
							case 3:
								c = 1; // white
								break;
							default:
								break;
							}
						}
					}
				}
				Pixels[y * width + x] = C64Palette[c];
			}
		}
		return true;
	}

	bool DecodeSpd!(byte[] content, int contentLength)
	{
		if (contentLength < 67)
			return false;
		int headerLength;
		int spriteCount;
		if (content[0] == 'S' && content[1] == 'P' && content[2] == 'D' && content[3] == 1) {
			// SpritePad 2
			headerLength = 6;
			spriteCount = content[4] + 1;
			if (contentLength < 9 + (spriteCount << 6))
				return false;
		}
		else {
			// SpritePad 1
			if ((contentLength & 63) != 3
			 || content[0] > 0xf || content[1] > 0xf || content[2] > 0xf)
				return false;
			headerLength = 0;
			spriteCount = contentLength >> 6;
		}

		RECOILResolution resolution = RECOILResolution.C642x1;
		for (int spriteNo = 0; spriteNo < spriteCount; spriteNo++) {
			if (content[headerLength + 66 + (spriteNo << 6)] < 0x80) {
				resolution = RECOILResolution.C641x1;
				break;
			}
		}
		const int spriteWidth = 24;
		const int spriteHeight = 21;
		const int horizontalGap = 2;
		const int verticalGap = 2;
		int width;
		int height;
		if (spriteCount <= 16) {
			width = spriteCount * (spriteWidth + horizontalGap) - horizontalGap;
			height = spriteHeight;
		}
		else {
			width = 16 * spriteWidth + 15 * horizontalGap;
			height = (spriteCount + 15 >> 4) * (spriteHeight + verticalGap) - verticalGap;
		}
		if (!SetSize(width, height, resolution))
			return false;

		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				int c = 0;
				int row = y % (spriteHeight + verticalGap);
				if (row < spriteHeight) {
					int column = x % (spriteWidth + horizontalGap);
					if (column < spriteWidth) {
						int spriteNo = x / (spriteWidth + horizontalGap) + (y / (spriteHeight + verticalGap) << 4);
						if (spriteNo < spriteCount) {
							int spriteOffset = 3 + (spriteNo << 6);
							int b = content[headerLength + spriteOffset + row * 3 + (column >> 3)];
							if (content[headerLength + spriteOffset + 63] < 0x80) {
								if ((b >> (~column & 7) & 1) != 0)
									c = spriteOffset + 63;
							}
							else {
								switch (b >> (~column & 6) & 3) {
								case 1:
									c = 1;
									break;
								case 2:
									c = spriteOffset + 63;
									break;
								case 3:
									c = 2;
									break;
								default:
									break;
								}
							}
						}
					}
				}
				Pixels[y * width + x] = C64Palette[content[headerLength + c] & 0xf];
			}
		}
		return true;
	}

	bool DecodePetScreen!(byte[] content, int screenOffset, int colorsOffset, int backgroundOffset, int columns, int rows)
	{
		int width = columns << 3;
		int height = rows << 3;
		if (!SetSize(width, height, RECOILResolution.C641x1))
			return false;
		byte[] font = resource<byte[]>("c64.fnt");
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				int offset = (y >> 3) * columns + (x >> 3);
				if ((font[content[screenOffset + offset] << 3 | (y & 7)] >> (~x & 7) & 1) == 0)
					offset = backgroundOffset;
				else
					offset += colorsOffset;
				Pixels[y * width + x] = C64Palette[content[offset] & 0xf];
			}
		}
		return true;
	}

	bool DecodePet!(byte[] content, int contentLength)
	{
		return contentLength == 2026
			&& DecodePetScreen(content, 2, 0x402, 0x3eb, 40, 25);
	}

	bool DecodeScrCol!(string filename, byte[] content, int contentLength)
	{
		if (contentLength != 1002)
			return false;
		byte[1002 + 1] colors;
		if (ReadCompanionFile(filename, "COL", "col", colors, colors.Length) != 1002)
			return false;
		SetSize(320, 200, RECOILResolution.C641x1);
		byte[] font = resource<byte[]>("c64.fnt");
		for (int y = 0; y < 200; y++) {
			for (int x = 0; x < 320; x++) {
				int offset = 2 + (y & ~7) * 5 + (x >> 3);
				int c;
				if ((font[content[offset] << 3 | (y & 7)] >> (~x & 7) & 1) == 0)
					c = 0;
				else
					c = colors[offset] & 0xf;
				Pixels[y * 320 + x] = C64Palette[c];
			}
		}
		return true;
	}

	bool DecodeFpr!(byte[] content, int contentLength)
	{
		if (contentLength != 18370)
			return false;
		SetSize(320, 200, RECOILResolution.C642x1);
		for (int y = 0; y < 200; y++) {
			for (int x = 0; x < 320; x++) {
				int offset = (y >> 3) * 40 + (x >> 3);
				int c = x < 24 ? 0xff : content[0x882 + offset + ((y & 7) << 10)];
				switch (content[0x2882 + (offset << 3) + (y & 7)] >> (~x & 6) & 3) {
				case 0:
					c = 0;
					break;
				case 1:
					c >>= 4;
					break;
				case 3:
					c = x < 24 ? content[0x382 + y] >> 4 : content[0x482 + offset];
					break;
				default: // case 2
					break;
				}
				if (x < 24) {
					switch (content[2 + (((y + 1 & 2) != 0 ? 5 : 0) + y / 42 << 6) + (y >> 1) % 21 * 3 + (x >> 3)] >> (~x & 6) & 3) {
					case 1:
						c = content[0x282 + y];
						break;
					case 2:
						c = content[0x44a];
						break;
					case 3:
						c = content[0x44b];
						break;
					default:
						break;
					}
				}
				Pixels[y * 320 + x] = C64Palette[c & 0xf];
			}
		}
		return true;
	}

	bool DecodeCtm!(byte[] content, int contentLength)
	{
		if (contentLength < 30 || content[0] != 'C' || content[1] != 'T' || content[2] != 'M' || content[3] != 5)
			return false;
		int colorMethod = content[8];
		if (colorMethod > 2)
			return false;
		int flags = content[9];
		bool tiles = (flags & 1) != 0;
		if (colorMethod == 1 && !tiles)
			return false;
		bool charex = (flags & 2) != 0;
		bool multi = (flags & 4) != 0;
		int charCount = content[10] + (content[11] << 8) + 1;
		int tileCount = tiles ? content[12] + (content[13] << 8) + 1 : 0;
		int tileWidth = tiles ? content[14] : 1;
		int tileHeight = tiles ? content[15] : 1;
		if (tileWidth == 0 || tileHeight == 0)
			return false;
		int mapWidth = content[16] | content[17] << 8;
		int mapHeight = content[18] | content[19] << 8;
		int tilesOffset = 20 + charCount * 9;
		int tileColorsOffset = charex ? tilesOffset : tilesOffset + tileCount * (tileWidth * tileHeight << 1);
		int mapOffset = colorMethod == 1 ? tileColorsOffset + tileCount : tileColorsOffset;
		if (contentLength != mapOffset + (mapWidth * mapHeight << 1))
			return false;
		int width = mapWidth * tileWidth << 3;
		int height = mapHeight * tileHeight << 3;
		if (!SetSize(width, height, multi ? RECOILResolution.C642x1 : RECOILResolution.C641x1))
			return false;
		for (int y = 0; y < height; y++) {
			int mapRowOffset = mapOffset + ((y >> 3) / tileHeight * mapWidth << 1);
			for (int x = 0; x < width; x++) {
				int mapTileOffset = mapRowOffset + ((x >> 3) / tileWidth << 1);
				int tile = content[mapTileOffset] | content[mapTileOffset + 1] << 8;
				int ch;
				if (tiles) {
					if (tile >= tileCount)
						return false;
					ch = (tile * tileHeight + (y >> 3) % tileHeight) * tileWidth + (x >> 3) % tileWidth;
					if (!charex) {
						int tileOffset = tilesOffset + (ch << 1);
						ch = content[tileOffset] | content[tileOffset + 1] << 8;
					}
				}
				else
					ch = tile;
				if (ch >= charCount)
					return false;
				int foregroundOffset;
				switch (colorMethod) {
				case 1:
					foregroundOffset = tileColorsOffset + tile;
					break;
				case 2:
					foregroundOffset = 20 + (charCount << 3) + ch;
					break;
				default:
					foregroundOffset = 7;
					break;
				}
				int c = content[20 + (ch << 3) + (y & 7)];
				if (multi) {
					c = c >> (~x & 6) & 3;
					if (c == 3)
						c = content[foregroundOffset] & 7;
					else
						c = content[4 + c];
				}
				else {
					c = c >> (~x & 7) & 1;
					c = content[c == 0 ? 4 : foregroundOffset];
				}
				Pixels[y * width + x] = C64Palette[c & 15];
			}
		}
		return true;
	}

	// Atari ST formats.

	bool DecodeDoo!(byte[] content, int contentLength)
	{
		SetSize(640, 400, RECOILResolution.St1x1);
		return DecodeBlackAndWhite(content, 0, contentLength, false, 0xffffff);
	}

	bool DecodeDa4!(byte[] content, int contentLength)
	{
		SetSize(640, 800, RECOILResolution.St1x1);
		return DecodeBlackAndWhite(content, 0, contentLength, false, 0xffffff);
	}

	bool DecodeStCmp!(byte[] content, int contentLength)
	{
		if (contentLength < 5)
			return false;
		switch (content[1]) {
		case 0:
			SetSize(640, 400, RECOILResolution.St1x1);
			break;
		case 200:
			SetSize(640, 800, RECOILResolution.St1x1);
			break;
		default:
			return false;
		}
		CmpStream() rle;
		rle.Content = content;
		rle.ContentOffset = 2;
		rle.ContentLength = contentLength;
		rle.Escape = content[0];
		return DecodeRleBlackAndWhite(rle, 0xffffff);
	}

	bool DecodeBld!(byte[] content, int contentLength)
	{
		if (contentLength < 5)
			return false;
		int width = content[0] << 8 | content[1];
		int height = content[2] << 8 | content[3];
		if (content[0] < 0x80)
			return SetSize(width, height, RECOILResolution.St1x1)
				&& DecodeBlackAndWhite(content, 4, contentLength, false, 0xffffff);
		if (!SetSize(65536 - width, height, RECOILResolution.St1x1))
			return false;
		BldStream() rle;
		rle.Content = content;
		rle.ContentOffset = 4;
		rle.ContentLength = contentLength;
		return DecodeRleBlackAndWhite(rle, 0xffffff);
	}

	bool DecodeCrg!(byte[] content, int contentLength)
	{
		if (contentLength < 43 || !IsStringAt(content, 0, "CALAMUSCRG")
		 || content[10] != 3 || content[11] != 0xe8 || content[12] != 0 || content[13] != 2)
			return false;
		int width = Get32BigEndian(content, 20);
		int height = Get32BigEndian(content, 24);
		if (!SetSize(width, height, RECOILResolution.St1x1))
			return false;
		CciStream() rle;
		rle.Content = content;
		rle.ContentOffset = 42;
		rle.ContentLength = contentLength;
		return DecodeRleBlackAndWhite(rle, 0xffffff);
	}

	bool DecodePac!(byte[] content, int contentLength)
	{
		if (contentLength < 8
		 || content[0] != 'p' || content[1] != 'M' || content[2] != '8')
			return false;
		int unpackedStride;
		switch (content[3]) {
		case '5':
			unpackedStride = 1;
			break;
		case '6':
			unpackedStride = 80;
			break;
		default:
			return false;
		}
		PacStream() rle;
		rle.Content = content;
		rle.ContentOffset = 7;
		rle.ContentLength = contentLength;
		byte[32000] unpacked;
		return rle.UnpackColumns(unpacked, 0, unpackedStride, 32000)
			&& DecodeDoo(unpacked, 32000);
	}

	static void FillPscLine(byte[]! unpacked, int unpackedOffset, int unpackedStride, int value)
	{
		for (int i = 0; i < unpackedStride; i++)
			unpacked[unpackedOffset + i] = value;
	}

	static int CopyPscLines(byte[]! unpacked, int unpackedOffset, int unpackedStride, int unpackedLength, int count)
	{
		if (unpackedOffset < unpackedStride || unpackedOffset + count * unpackedStride > unpackedLength)
			return -1;
		do {
			unpacked.CopyTo(unpackedOffset - unpackedStride, unpacked, unpackedOffset, unpackedStride);
			unpackedOffset += unpackedStride;
		} while (--count > 0);
		return unpackedOffset;
	}

	bool DecodePsc!(byte[] content, int contentLength)
	{
		// https://github.com/thmuch/tosgem-image-reader/blob/main/docs/PaintShopCompressed.md
		if (contentLength < 18 || !IsStringAt(content, 0, "tm89")
		 || content[8] != 2 || content[9] != 1)
			return false;
		int width = (content[10] << 8) + content[11] + 1;
		int height = (content[12] << 8) + content[13] + 1;
		if (width > 640 || height > 400)
			return false;
		SetSize(width, height, RECOILResolution.St1x1);
		int unpackedStride = width + 7 >> 3;
		int unpackedLength = unpackedStride * height;
		if (content[14] == 99 && contentLength == 16 + unpackedLength && content[15 + unpackedLength] == 0xff)
			return DecodeBlackAndWhite(content, 15, contentLength - 1, false, 0xffffff);

		byte[32000] unpacked;
		int contentOffset = 14;
		for (int unpackedOffset = 0; unpackedOffset < unpackedLength; ) {
			if (contentOffset + 1 >= contentLength)
				return false;
			switch (content[contentOffset++]) {
			case 0:
				FillPscLine(unpacked, unpackedOffset, unpackedStride, 0);
				unpackedOffset += unpackedStride;
				break;
			case 10:
				unpackedOffset = CopyPscLines(unpacked, unpackedOffset, unpackedStride, unpackedLength, 1 + content[contentOffset++]);
				if (unpackedOffset < 0)
					return false;
				break;
			case 12:
				unpackedOffset = CopyPscLines(unpacked, unpackedOffset, unpackedStride, unpackedLength, 256 + 1 + content[contentOffset++]);
				if (unpackedOffset < 0)
					return false;
				break;
			case 100:
				FillPscLine(unpacked, unpackedOffset, unpackedStride, content[contentOffset++]);
				unpackedOffset += unpackedStride;
				break;
			case 102:
				if (contentOffset + 2 >= contentLength)
					return false;
				for (int i = 0; i < unpackedStride; i++)
					unpacked[unpackedOffset + i] = content[contentOffset + (i & 1)];
				contentOffset += 2;
				unpackedOffset += unpackedStride;
				break;
			case 110:
				if (contentOffset + unpackedStride >= contentLength)
					return false;
				content.CopyTo(contentOffset, unpacked, unpackedOffset, unpackedStride);
				contentOffset += unpackedStride;
				unpackedOffset += unpackedStride;
				break;
			case 200:
				FillPscLine(unpacked, unpackedOffset, unpackedStride, 0xff);
				unpackedOffset += unpackedStride;
				break;
			default:
				return false;
			}
		}
		if (contentOffset >= contentLength || content[contentOffset] != 0xff)
			return false;
		return DecodeBlackAndWhite(unpacked, 0, unpackedLength, false, 0xffffff);
	}

	bool DecodeCp3!(byte[] content, int contentLength)
	{
		if (contentLength < 4)
			return false;
		int countLength = 1 + (content[0] << 8) + content[1] << 2;
		if (contentLength <= countLength)
			return false;
		int valueOffset = countLength;
		byte[32000] unpacked;
		int unpackedOffset = 0;
		int count;
		for (int countOffset = 4; countOffset < countLength; countOffset += 4) {
			// literals
			count = (content[countOffset] << 8 | content[countOffset + 1]) << 3;
			if (valueOffset + count + 8 > contentLength
			 || unpackedOffset + count > unpacked.Length)
				return false;
			content.CopyTo(valueOffset, unpacked, unpackedOffset, count);
			valueOffset += count;
			unpackedOffset += count;

			// repeat 8 bytes
			count = (content[countOffset + 2] << 8 | content[countOffset + 3]) << 3;
			if (unpackedOffset + count > unpacked.Length)
				return false;
			for (int offset = 0; offset < count; offset += 8)
				content.CopyTo(valueOffset, unpacked, unpackedOffset + offset, 8);
			valueOffset += 8;
			unpackedOffset += count;
		}
		// literals
		count = unpacked.Length - unpackedOffset;
		if (valueOffset + count != contentLength)
			return false;
		content.CopyTo(valueOffset, unpacked, unpackedOffset, count);

		return DecodeDoo(unpacked, unpacked.Length);
	}

	bool DecodeStFnt!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 2050:
			SetSize(256, 64, RECOILResolution.St1x1);
			break;
		case 4096:
		case 4098:
			SetSize(256, 128, RECOILResolution.St1x1);
			break;
		default:
			return false;
		}
		if ((contentLength & 2) != 0) {
			// the last word in the file is "half-height" flag:
			// 0 = font would look ugly at half-height
			// 1 = font looks ok at half-height
			if (content[contentLength - 2] != 0 || content[contentLength - 2] > 1)
				return false;
			contentLength -= 2;
		}
		DecodeBlackAndWhiteFont(content, 0, contentLength, 16);
		return true;
	}

	bool DecodeGdosFnt!(byte[] content, int contentLength)
	{
		if (contentLength < 88 || content[0x3e] != 0x55 || content[0x3f] != 0x55)
			return false;
		GdosFntStream() stream;
		// detect endianess assuming the point size is less than 256
		if (content[3] == 0) {
			if (content[2] == 0)
				return false;
			stream.BigEndian = false;
		}
		else if (content[2] == 0)
			stream.BigEndian = true;
		else
			return false;
		stream.Content = content;
		stream.ContentLength = contentLength;
		stream.ContentOffset = 0x24;
		int firstCharacter = stream.ReadWord();
		int lastCharacter = stream.ReadWord();
		if (firstCharacter > lastCharacter)
			return false;
		stream.ContentOffset = 0x48;
		int characterOffset = stream.ReadInt();
		if (characterOffset <= 0 || characterOffset >= contentLength)
			return false;
		int bitmapOffset = stream.ReadInt();
		if (bitmapOffset < 0 || bitmapOffset >= contentLength)
			return false;
		int bytesPerLine = stream.ReadWord();
		if (bytesPerLine == 0)
			return false;
		int height = stream.ReadWord();
		if (height == 0 || bitmapOffset + height * bytesPerLine > contentLength)
			return false;
		// + 2 because lastCharacter is inclusive and the character table contains left and right boundaries
		int characterEndOffset = characterOffset + (lastCharacter - firstCharacter + 2 << 1);
		if (characterEndOffset > bitmapOffset)
			return false;

		// At bitmapOffset there's a mono bitmap, bytesPerLine by height.
		// Because it can be even 13360 pixels wide, we choose to layout it in several rows,
		// taking care not to break any character.
		int width = height << 4; // arbitrary
		const int maxWidth = 3840; // arbitrary
		if (width > maxWidth)
			width = maxWidth;
		stream.ContentOffset = characterOffset;
		stream.ContentLength = characterEndOffset;
		stream.BitmapWidth = bytesPerLine << 3;
		stream.Width = width;
		stream.NextX = stream.RightX = 0;
		int row;
		for (row = 0; stream.NextX >= 0; row += height) {
			if (!stream.FitRow())
				return false;
		}
		if (!SetSize(width, row, RECOILResolution.St1x1))
			return false;

		stream.ContentOffset = characterOffset;
		stream.NextX = stream.RightX = 0;
		for (row = 0; stream.NextX >= 0; row += height) {
			stream.FitRow();
			// paint row where leftX <= fontX < rightX
			for (int y = 0; y < height; y++) {
				for (int x = 0; x < width; x++) {
					int fontX = stream.LeftX + x;
					int c;
					if (fontX < stream.RightX) {
						int offset = bitmapOffset + y * bytesPerLine + (fontX >> 3);
						c = (content[offset] >> (~fontX & 7) & 1) == 0 ? 0xffffff : 0;
					}
					else
						c = 0xffffff;
					Pixels[(row + y) * width + x] = c;
				}
			}
		}
		return true;
	}

	static bool IsStePalette(byte[] content, int contentOffset, int colors)
	{
		while (--colors >= 0) {
			if ((content[contentOffset] & 8) != 0 || (content[contentOffset + 1] & 0x88) != 0)
				return true;
			contentOffset += 2;
		}
		return false;
	}

	int GetStColor(byte[] content, int contentOffset)
	{
		int r = content[contentOffset];
		int gb = content[contentOffset + 1];
		int rgb;
		switch (Resolution) {
		case RECOILResolution.St1x1:
		case RECOILResolution.St1x2:
			// ST 512 colors
			// xxxx0RRR 0GGG0BBB -> 00000RRR00000GGG00000BBB
			rgb = (r & 7) << 16
				| (gb & 0x70) << 4
				| (gb & 7);
			return rgb << 5 | rgb << 2 | (rgb >> 1 & 0x030303);
		default:
			// STE 4096 colors
			// xxxxrRRR gGGGbBBB -> 0000RRRr0000GGGg0000BBBb
			rgb = (r & 7) << 17 | (r & 8) << 13
				| (gb & 0x70) << 5 | (gb & 0x87) << 1 | (gb & 8) >> 3;
			return rgb << 4 | rgb;
		}
	}

	internal void SetStPalette!(byte[] content, int contentOffset, int colors)
	{
		for (int c = 0; c < colors; c++)
			ContentPalette[c] = GetStColor(content, contentOffset + c * 2);
	}

	internal static int GetSteInterlacedColor(int rgb)
	{
		// xyzrRRR gGGGbBBB -> 000RRRrx 000GGGgy 000BBBbz
		rgb = (rgb & 0x700) << 10 | (rgb & 0x870) << 6 | (rgb & 0x4087) << 2
			| (rgb & 0x2000) >> 5 | (rgb & 8) >> 2 | (rgb & 0x1000) >> 12;
		return rgb << 3 | (rgb >> 2 & 0x070707);
	}

	static int GetStVdiColor(byte[] content, int contentOffset)
	{
		int rgb = 0;
		for (int i = 0; i < 6; i += 2) {
			int c = content[contentOffset + i] << 8 | content[contentOffset + i + 1];
			// In test.pal accompanying test.mur values are up to 1015.
			// In other places they are up to 1000.
			c = c < 1000 ? c * 255 / 1000 : 255;
			rgb = rgb << 8 | c;
		}
		return rgb;
	}

	internal void SetStVdiColor!(int i, int rgb, int bitplanes)
	{
		switch (i) {
		case   1: i = (1 << bitplanes) - 1; break;
		case   2: i = 1; break;
		case   3: i = 2; break;
		case   5: i = 6; break;
		case   6: i = 3; break;
		case   7: i = 5; break;
		case   8: i = 7; break;
		case   9: i = 8; break;
		case  10: i = 9; break;
		case  11: i = 10; break;
		case  13: i = 14; break;
		case  14: i = 11; break;
		case  15: i = 13; break;
		case 255: i = 15; break;
		default:  break;
		}
		ContentPalette[i] = rgb;
	}

	void SetStVdiPalette!(byte[] content, int contentOffset, int colors, int bitplanes)
	{
		for (int i = 0; i < colors; i++)
			SetStVdiColor(i, GetStVdiColor(content, contentOffset + i * 6), bitplanes);
	}

	static int GetStLowPixel(byte[] content, int contentOffset, int x)
		=> GetBitplaneWordsPixel(content, contentOffset, x, 4);

	bool DecodeStLowWithStride!(byte[] bitmap, int bitmapOffset, int bitmapStride, byte[] palette, int paletteOffset, int width, int height, int frames)
	{
		SetSize(width, height, IsStePalette(palette, paletteOffset, 16) ? RECOILResolution.Ste1x1 : RECOILResolution.St1x1, frames);
		SetStPalette(palette, paletteOffset, 16);
		DecodeBitplanes(bitmap, bitmapOffset, bitmapStride, 4, 0, width, height);
		return true;
	}

	bool DecodeStLow!(byte[] bitmap, int bitmapOffset, byte[] palette, int paletteOffset, int width, int height, int frames = 1)
		=> DecodeStLowWithStride(bitmap, bitmapOffset, width + 15 >> 4 << 3, palette, paletteOffset, width, height, frames);

	void DecodeStMedium!(byte[] bitmap, int bitmapOffset, byte[] palette, int paletteOffset, int width, int height, int frames)
	{
		SetSize(width, height << 1, IsStePalette(palette, paletteOffset, 4) ? RECOILResolution.Ste1x2 : RECOILResolution.St1x2, frames);
		SetStPalette(palette, paletteOffset, 4);
		DecodeScaledBitplanes(bitmap, bitmapOffset, width, height * frames, 2, false, null);
	}

	bool DecodeSrt!(byte[] content, int contentLength)
	{
		if (contentLength != 32038
		 || !IsStringAt(content, 0x7d00, "JHSy")
		 || content[0x7d04] != 0 || content[0x7d05] != 1)
			return false;
		DecodeStMedium(content, 0, content, 32006, 640, 200, 1);
		return true;
	}

	internal bool DecodeSt!(byte[] bitmap, int bitmapOffset, byte[] palette, int paletteOffset, int mode, int doubleHeight)
	{
		switch (mode) {
		case 0:
			return DecodeStLow(bitmap, bitmapOffset, palette, paletteOffset, 320, 200 << doubleHeight);
		case 1:
			DecodeStMedium(bitmap, bitmapOffset, palette, paletteOffset, 640, 200 << doubleHeight, 1);
			return true;
		case 2:
			SetSize(640, 400 << doubleHeight, RECOILResolution.St1x1);
			return DecodeBlackAndWhite(bitmap, bitmapOffset, bitmapOffset + (32000 << doubleHeight), false, 0xffffff);
		default:
			return false;
		}
	}

	bool DecodeStPi!(byte[] content, int contentLength)
	{
		if (contentLength < 32034 || content[0] != 0)
			return false;
		switch (contentLength) {
		case 32034: // DEGAS
		case 32066: // DEGAS Elite
		case 32128: // TROUBLE.PI1
			return DecodeSt(content, 34, content, 2, content[1], 0);
		case 38434: // st.pi1
			return content[1] == 4 && DecodeStLow(content, 34, content, 2, 320, 240);
		case 44834: // 280 lines overscan
			return content[1] == 0 && DecodeStLow(content, 34, content, 2, 320, 280);
		case 64034: // PaintPro ST *.pic
			return DecodeSt(content, 34, content, 2, content[1], 1);
		case 116514: // 416x560 FORESTV.PI1
			return content[1] == 0 && DecodeStLow(content, 34, content, 2, 416, 560);
		case 153606: // PI6 TT-High
			if (content[1] != 6)
				return false;
			SetSize(1280, 960, RECOILResolution.Tt1x1);
			return DecodeBlackAndWhite(content, 6, contentLength, false, 0xffffff);
		case 153634: // PI5 TT-Medium
			if (content[1] != 4)
				return false;
			SetSize(640, 480, RECOILResolution.Tt1x1);
			SetStPalette(content, 2, 16);
			DecodeBitplanes(content, 34, 320, 4, 0, 640, 480);
			return true;
		case 154114: // PI4 TT-Low
			if (content[1] != 7)
				return false;
			SetSize(640, 480, RECOILResolution.Tt2x1);
			SetStPalette(content, 2, 256);
			DecodeScaledBitplanes(content, 514, 320, 480, 8, false, null);
			return true;
		default:
			return false;
		}
	}

	bool DecodePc!(byte[] content, int contentLength)
	{
		if (contentLength < 68 || content[0] != 0x80 || content[1] > 2)
			return false;
		int bitplanes = 4 >> content[1];
		PackBitsStream() rle;
		rle.Content = content;
		rle.ContentOffset = 34;
		rle.ContentLength = contentLength;
		byte[32000] unpacked;
		return rle.UnpackBitplaneLines(unpacked, 320 << content[1], 200, bitplanes, true, false) // handle 640x400 as 1280x200 ;)
			&& DecodeSt(unpacked, 0, content, 2, content[1], 0);
	}

	bool DecodeEza!(byte[] content, int contentLength)
	{
		if (contentLength < 44 || content[0] != 'E' || content[1] != 'Z' || content[2] != 0 || content[3] != 0xc8)
			return false;
		PackBitsStream() rle;
		rle.Content = content;
		rle.ContentOffset = 44;
		rle.ContentLength = contentLength;
		byte[32000] unpacked;
		return rle.UnpackBitplaneLines(unpacked, 320, 200, 4, true, false)
			&& DecodeStLow(unpacked, 0, content, 4, 320, 200);
	}

	bool DecodeNeo!(string filename, byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 32128:
			if (content[0] != 0 || content[1] != 0 || content[2] != 0)
				return false;
			if (content[3] == 0) {
				byte[6800 + 1] rst;
				if (ReadCompanionFile(filename, "RST", "rst", rst, rst.Length) == 6800) {
					SetSize(320, 200, RECOILResolution.St1x1);
					SetStPalette(content, 4, 16);
					RastPalette() palette;
					palette.Content = rst;
					palette.ContentOffset = 0;
					palette.ContentLength = 6800;
					palette.Colors = 16;
					DecodeScaledBitplanes(content, 128, 320, 200, 4, false, palette);
					return true;
				}
			}
			return DecodeSt(content, 128, content, 4, content[3], 0);
		case 128128:
			return content[0] == 0xba && content[1] == 0xbe
				&& content[2] == 0 && content[3] == 0
				&& DecodeStLow(content, 128, content, 4, 640, 400);
		default:
			return false;
		}
	}

	bool DecodeArtDirector!(byte[] content, int contentLength)
		=> contentLength == 32512
			&& content[0x7e1f] < 8
			&& DecodeStLow(content, 0, content, 0x7d00 + (content[0x7e1f] << 5), 320, 200);

	bool DecodeSsb!(byte[] content, int contentLength)
		=> contentLength == 32768
			&& DecodeStLow(content, 0, content, 32000, 320, 200);

	bool DecodeGfaArtist!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 32032:
			return DecodeStLow(content, 32, content, 0, 320, 200);
		case 34360:
			// TODO: rasters?
			return DecodeStLow(content, 4, content, 32004, 320, 200);
		default:
			return false;
		}
	}

	bool DecodePaletteMaster!(byte[] content, int contentLength)
	{
		if (contentLength != 36864 || content[0x8c80] != 0xff || content[0x8c81] != 0xff)
			return false;
		SetSize(320, 200, RECOILResolution.St1x1);
		ArtPalette() palette;
		palette.Content = content;
		DecodeScaledBitplanes(content, 0, 320, 200, 4, false, palette);
		return true;
	}

	bool DecodeCel!(byte[] content, int contentLength)
	{
		if (contentLength < 128 || content[0] != 0xff || content[1] != 0xff
		 || content[2] != 0 || content[3] != 0)
			return false;
		int width = content[0x3a] << 8 | content[0x3b];
		int height = content[0x3c] << 8 | content[0x3d];
		return contentLength == 128 + (width + 15 >> 4 << 3) * height
			&& DecodeStLow(content, 128, content, 4, width, height);
	}

	bool DecodeMur!(string filename, byte[] content, int contentLength)
	{
		if (contentLength != 32000)
			return false;
		byte[96 + 1] pal;
		if (ReadCompanionFile(filename, "PAL", "pal", pal, pal.Length) != 96)
			return false;
		SetSize(320, 200, RECOILResolution.Ste1x1);
		SetStVdiPalette(pal, 0, 16, 4);
		DecodeBitplanes(content, 0, 160, 4, 0, 320, 200);
		return true;
	}

	bool DecodeKid!(byte[] content, int contentLength)
		=> contentLength == 63054 && content[0] == 'K' && content[1] == 'D'
			&& DecodeStLowWithStride(content, 34, 230, content, 2, 448, 274, 1);

	bool DecodeStPpp!(byte[] content, int contentLength)
	{
		// TODO: compression
		return contentLength == 32079
			&& IsStringAt(content, 0, "PABLO PACKED PICTURE: Groupe CDND \r\n32036\r\n")
			&& content[0x2c] == 0 && content[0x2d] == 0x7d && content[0x2e] == 0x24
			&& DecodeSt(content, 0x4f, content, 0x2f, content[0x2b], 0);
	}

	bool DecodeStRgb!(byte[] content, int contentLength)
	{
		if (contentLength != 96102)
			return false;
		SetSize(320, 200, RECOILResolution.Ste1x1);
		Frames = 3;
		for (int i = 0; i < 320 * 200; i++) {
			int rgb = GetStLowPixel(content, 34, i) << 16
				| GetStLowPixel(content, 32068, i) << 8
				| GetStLowPixel(content, 64102, i);
			Pixels[i] = rgb * 0x11;
		}
		return true;
	}

	bool DecodeSd!(byte[] content, int contentLength, int mode)
		=> contentLength == 32128 && DecodeSt(content, 128, content, 4, mode, 0);

	bool DecodeIc!(byte[] content, int contentLength)
	{
		if (contentLength < 68
		 || !IsStringAt(content, 0, "IMDC") || content[4] != 0
		 || content[0x40] != 0xc8 || content[0x41] != 2)
			return false;
		byte[32000] unpacked;
		IcStream() rle;
		rle.Content = content;
		rle.ContentOffset = 0x43;
		rle.ContentLength = contentLength;
		return rle.UnpackColumns(unpacked, 0, 160, 32000)
			&& DecodeSt(unpacked, 0, content, 6, content[5], 0);
	}

	bool DecodeGraphicsProcessor!(byte[] content, int contentLength)
	{
		if (contentLength < 493 || content[0] != 0)
			return false;
		int mode = content[1];
		switch (mode) {
		case 0:
		case 1:
		case 2:
			return contentLength == 32331 && DecodeSt(content, 331, content, 2, mode, 0);
		case 10:
		case 11:
		case 12:
			break;
		default:
			return false;
		}
		mode -= 10;
		int bitplanes = 4 >> mode;
		byte[32000] unpacked;
		int contentOffset = 333;
		int count = 0;
		for (int unpackedOffset = 0; unpackedOffset < 32000; unpackedOffset += bitplanes) {
			if (count == 0) {
				if (contentOffset + bitplanes >= contentLength)
					return false;
				count = content[contentOffset];
				if (count == 0)
					return false;
				contentOffset += 1 + bitplanes;
			}
			content.CopyTo(contentOffset - bitplanes, unpacked, unpackedOffset, bitplanes);
			count--;
		}
		return DecodeSt(unpacked, 0, content, 2, mode, 0);
	}

	bool DecodeDaliCompressed!(byte[] content, int contentLength, int mode)
	{
		DaliStream() stream;
		stream.Content = content;
		stream.ContentOffset = 32;
		stream.ContentLength = contentLength;
		int countLength = stream.ParseDaliInt();
		return countLength > 0 && stream.ParseDaliInt() > 0
			&& stream.Decode(countLength, this, 0, mode);
	}

	bool DecodeRgh!(byte[] content, int contentLength)
	{
		if (contentLength < 14 || !IsStringAt(content, 0, "(c)F.MARCHAL"))
			return false;
		DaliStream() stream;
		stream.Content = content;
		stream.ContentOffset = 12;
		stream.ContentLength = contentLength;
		int countLength = stream.ParseDaliInt();
		int paletteOffset = stream.ContentOffset;
		stream.ContentOffset = paletteOffset + 32;
		return stream.Decode(countLength, this, paletteOffset, 0);
	}

	bool DecodeSc!(byte[] content, int contentLength)
	{
		if (contentLength < 128 || !IsStringAt(content, 0x36, "ANvisionA"))
			return false;
		int flags = content[0x3f];
		int doubleHeight;
		switch (flags & 0xf) {
		case 0:
			doubleHeight = 1;
			break;
		case 1:
		case 2:
			doubleHeight = 0;
			break;
		default:
			return false;
		}
		int bitmapLength = 32000 << doubleHeight;
		int mode = flags >> 4 & 3;
		if (flags >= 0x80) {
			byte[64000] unpacked;
			ScStream() rle;
			rle.Content = content;
			rle.ContentOffset = 128;
			rle.ContentLength = contentLength;
			int bytesPer16Pixels = 8 >> mode;
			for (int bitplane = 0; bitplane < bytesPer16Pixels; bitplane += 2) {
				if (!rle.UnpackWords(unpacked, bitplane, bytesPer16Pixels, bitmapLength))
					return false;
			}
			return DecodeSt(unpacked, 0, content, 4, mode, doubleHeight);
		}
		return contentLength >= 128 + bitmapLength
			&& DecodeSt(content, 128, content, 4, mode, doubleHeight);
	}

	bool DecodeGfb!(byte[] content, int contentLength)
	{
		if (contentLength < 20 || !IsStringAt(content, 0, "GF25"))
			return false;
		int bitplanes;
		switch (Get32BigEndian(content, 4)) {
		case   2: bitplanes = 1; break;
		case   4: bitplanes = 2; break;
		case  16: bitplanes = 4; break;
		case 256: bitplanes = 8; break;
		default: return false;
		}
		int width = Get32BigEndian(content, 8);
		if (width <= 0)
			return false;
		int height = Get32BigEndian(content, 12);
		if (height <= 0)
			return false;
		int bitmapLength = Get32BigEndian(content, 16);
		if (bitmapLength <= 0)
			return false;
		if (1556 + bitmapLength != contentLength
		 || bitmapLength != (width + 15 >> 4 << 1) * bitplanes * height
		 || !SetSizeStOrFalcon(width, height, bitplanes, false))
			return false;
		SetStVdiPalette(content, 20 + bitmapLength, 1 << bitplanes, bitplanes);
		DecodeScaledBitplanes(content, 20, width, height, bitplanes, false, null);
		return true;
	}

	bool DecodeCa!(byte[] content, int contentLength)
	{
		if (contentLength < 8
		 || content[0] != 'C' || content[1] != 'A')
			return false;
		int contentOffset;
		switch (content[3]) {
		case 0:
			contentOffset = 4 + 32;
			break;
		case 1:
			contentOffset = 4 + 8;
			break;
		case 2:
			contentOffset = 4;
			break;
		default:
			return false;
		}
		switch (content[2]) {
		case 0:
			return contentOffset + 32000 == contentLength
				&& DecodeSt(content, contentOffset, content, 4, content[3], 0);
		case 1: {
				byte[32000] unpacked;
				CaStream() rle;
				rle.Content = content;
				rle.ContentOffset = contentOffset;
				rle.ContentLength = contentLength;
				return rle.UnpackCa(unpacked, 0)
					&& DecodeSt(unpacked, 0, content, 4, content[3], 0);
			}
		default:
			return false;
		}
	}

	bool DecodeTny!(byte[] content, int contentLength)
	{
		if (contentLength < 42)
			return false;
		int mode = content[0];
		int contentOffset;
		if (mode > 2) {
			if (mode > 5)
				return false;
			mode -= 3;
			contentOffset = 4;
		}
		else
			contentOffset = 0;

		int controlLength = content[contentOffset + 33] << 8 | content[contentOffset + 34];
		int valueLength = (content[contentOffset + 35] << 8 | content[contentOffset + 36]) << 1;
		if (contentOffset + 37 + controlLength + valueLength > contentLength)
			return false;
		TnyStream() rle;
		rle.Content = content;
		rle.ContentOffset = contentOffset + 37;
		rle.ValueOffset = rle.ContentLength = contentOffset + 37 + controlLength;
		rle.ValueLength = contentOffset + 37 + controlLength + valueLength;

		byte[32000] unpacked;
		for (int bitplane = 0; bitplane < 8; bitplane += 2) {
			for (int x = bitplane; x < 160; x += 8) {
				for (int unpackedOffset = x; unpackedOffset < 32000; unpackedOffset += 160) {
					int b = rle.ReadRle();
					if (b < 0)
						return false;
					unpacked[unpackedOffset] = b >> 8;
					unpacked[unpackedOffset + 1] = b & 0xff;
				}
			}
		}

		return DecodeSt(unpacked, 0, content, contentOffset + 1, mode, 0);
	}

	bool DecodeCptFul!(byte[] content, int contentOffset, int contentLength, HblPalette! palette)
	{
		if (contentLength < contentOffset + 40 || content[contentOffset + 32] != 0)
			return false;
		int mode = content[contentOffset + 33];
		if (mode > 2)
			return false;
		int bitplanes = 4 >> mode;
		byte[32000] unpacked;
		byte[16000] isFilled = 0;
		contentOffset += 34;

		// RLE
		for (;;) {
			int nextContentOffset = contentOffset + 4 + bitplanes * 2;
			if (nextContentOffset > contentLength)
				return false;
			int repeatCount = content[contentOffset] << 8 | content[contentOffset + 1];
			if (repeatCount == 0xffff) {
				contentOffset = nextContentOffset;
				break;
			}
			int offset = (content[contentOffset + 2] << 8 | content[contentOffset + 3]) * bitplanes;
			do {
				if (offset >= 16000)
					return false;
				content.CopyTo(contentOffset + 4, unpacked, offset << 1, bitplanes << 1);
				isFilled[offset] = 1;
				offset += bitplanes;
			} while (--repeatCount >= 0);
			contentOffset = nextContentOffset;
		}

		// fill in holes
		for (int offset = 0; offset < 16000; offset += bitplanes) {
			if (isFilled[offset] == 0) {
				int nextContentOffset = contentOffset + bitplanes * 2;
				if (nextContentOffset > contentLength)
					return false;
				content.CopyTo(contentOffset, unpacked, offset << 1, bitplanes << 1);
				contentOffset = nextContentOffset;
			}
		}

		if (palette == null)
			return DecodeSt(unpacked, 0, content, 0, mode, 0);
		if (mode == 0)
			SetSize(320, 200, RECOILResolution.St1x1);
		else
			SetSize(640, 400, RECOILResolution.St1x2);
		DecodeScaledBitplanes(unpacked, 0, 320 << mode, 200, bitplanes, false, palette);
		return true;
	}

	bool DecodeCpt!(string filename, byte[] content, int contentLength)
	{
		if (contentLength < 40)
			return false;
		if (content[33] <= 1) {
			byte[3248 + 1] hbl;
			int hblLength = ReadCompanionFile(filename, "HBL", "hbl", hbl, hbl.Length);
			if (hblLength >= 896 && hblLength <= 3248) {
				HblPalette() palette;
				palette.Content = hbl;
				palette.ContentLength = hblLength;
				if (palette.Init())
					return DecodeCptFul(content, 0, contentLength, palette);
			}
		}
		return DecodeCptFul(content, 0, contentLength, null);
	}

	bool DecodeFul!(byte[] content, int contentLength)
	{
		if (contentLength < 896 + 608 + 40)
			return false;
		HblPalette() palette;
		palette.Content = content;
		palette.ContentLength = contentLength;
		return palette.Init()
			&& content[palette.ContentOffset + 608 + 33] <= 1
			&& DecodeCptFul(content, palette.ContentOffset + 608, contentLength, palette);
	}

	void SetDefaultStPalette!(int bitplanes)
	{
		ContentPalette[0] = 0xffffff;
		if (bitplanes >= 2) {
			ContentPalette[1] = 0xff0000;
			ContentPalette[2] = 0x00ff00;
			if (bitplanes == 4) {
				ContentPalette[3] = 0xffff00;
				ContentPalette[4] = 0x0000ff;
				ContentPalette[5] = 0xff00ff;
				ContentPalette[6] = 0x00ffff;
				ContentPalette[7] = 0xaaaaaa;
				ContentPalette[8] = 0x555555;
				ContentPalette[9] = 0xaa0000;
				ContentPalette[10] = 0x00aa00;
				ContentPalette[11] = 0xaaaa00;
				ContentPalette[12] = 0x0000aa;
				ContentPalette[13] = 0xaa00aa;
				ContentPalette[14] = 0x00aaaa;
			}
		}
		ContentPalette[(1 << bitplanes) - 1] = 0x000000;
	}

	static bool IsTimg(byte[] content)
	{
		if (!IsStringAt(content, 16, "TIMG") || content[20] != 0 || content[21] != 3)
			return false;
		for (int i = 22; i < 28; i += 2) {
			if (content[i] != 0 || content[i + 1] != 5)
				return false;
		}
		return true;
	}

	static bool IsXimg(byte[] content)
	{
		return IsStringAt(content, 16, "XIMG") && content[20] == 0 && content[21] == 0;
	}

	static bool IsSttt(byte[] content, int bitplanes)
	{
		int colors = content[20] << 8 | content[21];
		return IsStringAt(content, 16, "STTT") && colors == 1 << bitplanes;
	}

	bool DecodeStImg!(byte[] content, int contentLength)
	{
		if (contentLength < 17 || content[0] != 0 || content[1] == 0 || content[1] > 3 || content[4] != 0)
			return false;
		int headerLength = (content[2] << 8 | content[3]) << 1;
		if (headerLength < 16 || headerLength >= contentLength)
			return false;
		int bitplanes = content[5];
		int width = content[12] << 8 | content[13];
		int height = content[14] << 8 | content[15];

		if (headerLength == 18 && content[16] == 0 && content[17] == 3) {
			// Ventura Publisher true color, e.g. BILD0005.IMG
			if (!SetSize(width, height, RECOILResolution.Falcon1x1))
				return false;
			int contentOffset = 18;
			int pixelsLength = width * height;
			int count = 0;
			for (int i = 0; i < pixelsLength; i++) {
				if (count == 0) {
					if (contentOffset + 1 >= contentLength)
						return false;
					if (content[contentOffset++] != 0x80)
						return false;
					count = content[contentOffset++];
					if (count == 0)
						return false;
				}
				if (contentOffset + 2 >= contentLength)
					return false;
				Pixels[i] = content[contentOffset + 2] << 16 | content[contentOffset + 1] << 8 | content[contentOffset]; // BGR
				contentOffset += 3;
				count--;
			}
			return true;
		}

		int xRatio = content[8] << 8 | content[9];
		int yRatio = content[10] << 8 | content[11];
		if (bitplanes <= 2 && width <= 640 && height <= 200 && yRatio * 2 > xRatio * 3)
			SetSize(width, height << 1, RECOILResolution.St1x2);
		else if (bitplanes <= 8 && width <= 320 && height <= 480 && xRatio * 2 > yRatio * 3)
			SetSize(width << 1, height, RECOILResolution.Tt2x1);
		else if (!SetSizeStOrFalcon(width, height, bitplanes, true))
			return false;

		switch (bitplanes) {
		case 1:
		case 2:
		case 4:
		case 8:
			if (headerLength == 22 + (6 << bitplanes) && IsXimg(content)) {
				for (int i = 0; i < 1 << bitplanes; i++)
					ContentPalette[i] = GetStVdiColor(content, 22 + i * 6);
			}
			else if (headerLength == 22 + (2 << bitplanes) && IsSttt(content, bitplanes))
				SetStPalette(content, 22, 1 << bitplanes);
			else if (bitplanes == 8) {
				// grayscale, inverted bits in reverse order
				int rgb = 0xffffff;
				for (int c = 0; c < 256; c++) {
					ContentPalette[c] = rgb;
					// decrement in reverse bit order
					for (int mask = 0x808080; ; mask >>= 1) {
						rgb ^= mask;
						if ((rgb & mask) == 0)
							break;
					}
				}
			}
			else if (headerLength == 50 && content[16] == 0 && content[17] == 0x80)
				SetStPalette(content, 18, 16); // HyperPaint
			else
				SetDefaultStPalette(bitplanes);
			break;
		case 15:
			if (headerLength != 28 || !IsTimg(content))
				return false;
			break;
		case 16:
		case 24:
		case 32:
			break;
		default:
			return false;
		}

		ImgStream() rle;
		rle.Content = content;
		rle.ContentOffset = headerLength;
		rle.ContentLength = contentLength;
		int bytesPerBitplane = width + 7 >> 3;
		if (bitplanes == 24) // XXX: only 24?
			bytesPerBitplane = (bytesPerBitplane + 1) & ~1;
		int bytesPerLine = bitplanes * bytesPerBitplane;
		byte[]# unpacked = new byte[bytesPerLine];
		for (int y = 0; y < height; ) {
			int lineRepeatCount = rle.GetLineRepeatCount();
			if (lineRepeatCount > height - y)
				lineRepeatCount = height - y;

			for (int x = 0; x < bytesPerLine; x++) {
				int b = rle.ReadRle();
				if (b < 0)
					return false;
				if (b != ImgStream.Keep)
					unpacked[x] = b;
				else if (y == 0)
					unpacked[x] = 0;
			}

			for (int x = 0; x < width; x++) {
				int c;
				switch (bitplanes) {
				case 16:
					c = GetFalconTrueColor(unpacked, x << 1);
					break;
				case 24:
					c = GetR8G8B8Color(unpacked, x * 3);
					break;
				case 32:
					c = GetR8G8B8Color(unpacked, (x << 2) + 1);
					break;
				default:
					c = GetBitplanePixel(unpacked, x >> 3, x, bitplanes, bytesPerBitplane);
					c = bitplanes == 15 ? GetB5G5R5Color(c) : ContentPalette[c];
					break;
				}
				for (int i = 0; i < lineRepeatCount; i++)
					SetScaledPixel(x, y + i, c);
			}

			y += lineRepeatCount;
		}
		return true;
	}

	bool DecodeStLowBlend!(byte[] bitmap, int bitmapOffset, byte[] palette, int paletteOffset, int width, int height)
	{
		DecodeStLow(bitmap, bitmapOffset, palette, paletteOffset, width, height, 2);
		DecodeBitplanes(bitmap, bitmapOffset + (width >> 1) * height, width >> 1, 4, width * height, width, height);
		return ApplyBlend();
	}

	bool DecodeDuo!(byte[] content, int contentLength)
	{
		return contentLength == 113600
			&& DecodeStLowBlend(content, 32, content, 0, 416, 273);
	}

	bool DecodeDu2!(byte[] content, int contentLength)
	{
		if (contentLength != 113576 && contentLength != 113600)
			return false;
		DecodeStMedium(content, 8, content, 0, 832, 273, 2);
		return ApplyBlend();
	}

	bool DecodeP3c!(byte[] content, int contentLength)
	{
		CaStream() rle;
		rle.Content = content;
		rle.ContentOffset = 0;
		rle.ContentLength = contentLength;
		int compressedLength = rle.ParseDaliInt();
		if (compressedLength < 0)
			return false;
		int paletteOffset = rle.ContentOffset;
		rle.ContentLength = paletteOffset + 32 + compressedLength;
		if (rle.ContentLength >= contentLength)
			return false;
		rle.ContentOffset = paletteOffset + 32;
		byte[64000] unpacked;
		if (!rle.UnpackCa(unpacked, 0))
			return false;

		rle.ContentLength = contentLength;
		compressedLength = rle.ParseDaliInt();
		if (compressedLength < 0 || rle.ContentOffset + compressedLength != contentLength)
			return false;
		rle.ContentLength = contentLength;
		return rle.UnpackCa(unpacked, 32000)
			&& DecodeStLowBlend(unpacked, 0, content, paletteOffset, 320, 200);
	}

	bool UnpackLz4(byte[] content, int contentLength, byte[]! unpacked, int unpackedLength)
	{
		if (contentLength < 4 + 3 + 4
		 || content[0] != 0x04 || content[1] != 0x22 || content[2] != 0x4d || content[3] != 0x18
		 || (content[4] & 0xc3) != 0x40)
			return false;
		Lz4Stream() stream;
		stream.Content = content;
		stream.ContentOffset = 6 + 1;
		if ((content[4] & 0x08) != 0)
			stream.ContentOffset += 8; // content size
		stream.Unpacked = unpacked;
		stream.UnpackedOffset = 0;
		stream.UnpackedLength = unpackedLength;

		for (;;) {
			if (stream.ContentOffset + 4 > contentLength)
				return false;
			int blockSize = Get32LittleEndian(content, stream.ContentOffset);
			stream.ContentOffset += 4;
			stream.ContentLength = contentLength;

			if (blockSize == 0)
				break;
			if ((blockSize >> 31) != 0) {
				if (!stream.Copy(blockSize & 0x7fffffff))
					return false;
				continue;
			}
			stream.ContentLength = stream.ContentOffset + blockSize;
			if (stream.ContentLength > contentLength)
				return false;

			for (;;) {
				int token = stream.ReadByte();
				if (token < 0)
					return false;

				// literals
				int count = stream.ReadCount(token >> 4);
				if (count < 0
				 || !stream.Copy(count))
					return false;

				if (stream.ContentOffset == stream.ContentLength)
					break;

				// LZ77
				if (stream.ContentOffset > stream.ContentLength - 2)
					return false;
				int distance = stream.ReadByte();
				distance += stream.ReadByte() << 8;
				if (distance == 0)
					return false;
				count = stream.ReadCount(token & 0xf);
				if (count < 0)
					return false;
				count += 4;
				int nextOffset = stream.UnpackedOffset + count;
				if (nextOffset > unpackedLength
				 || !CopyPrevious(unpacked, stream.UnpackedOffset, distance, count))
					return false;
				stream.UnpackedOffset = nextOffset;
			}

			if ((content[4] & 0x10) != 0)
				stream.ContentOffset += 4; // block checksum
		}

		if ((content[4] & 0x04) != 0)
			stream.ContentOffset += 4; // content checksum
		return stream.ContentOffset == contentLength && stream.UnpackedOffset == unpackedLength;
	}

	bool DecodePl4!(byte[] content, int contentLength)
	{
		byte[64070] unpacked;
		const int secondPi1Offset = 32036;
		if (!UnpackLz4(content, contentLength, unpacked, unpacked.Length)
		 || unpacked[0] != 0 || unpacked[1] != 0
		 || unpacked[secondPi1Offset] != 0 || unpacked[secondPi1Offset + 1] != 0)
			return false;
		SetSize(320, 200, IsStePalette(unpacked, 2, 16) || IsStePalette(unpacked, secondPi1Offset + 2, 16) ? RECOILResolution.Ste1x1 : RECOILResolution.St1x1, 2);
		SetStPalette(unpacked, 2, 16);
		DecodeBitplanes(unpacked, 34, 160, 4, 0, 320, 200);
		SetStPalette(unpacked, secondPi1Offset + 2, 16);
		DecodeBitplanes(unpacked, secondPi1Offset + 34, 160, 4, 320 * 200, 320, 200);
		return ApplyBlend();
	}

	bool DecodeSpuScreen!(byte[] content, int bitmapOffset, int height, bool enhanced)
	{
		int paletteOffset = bitmapOffset + height * 160;
		if (!SetSize(320, height, enhanced || IsStePalette(content, paletteOffset, height * 48) ? RECOILResolution.Ste1x1 : RECOILResolution.St1x1))
			return false;
		if (enhanced)
			Frames = 2;
		int pixelsOffset = 0;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < 320; x++) {
				int c = GetStLowPixel(content, bitmapOffset, pixelsOffset);
				// http://www.atari-forum.com/wiki/index.php?title=ST_Picture_Formats
				int x1 = c * 10 + 1 - (c & 1) * 6;
				if (x >= x1 + 160)
					c += 32;
				else if (x >= x1)
					c += 16;
				int colorOffset = paletteOffset + y * 96 + (c << 1);
				Pixels[pixelsOffset++] = enhanced
					? GetSteInterlacedColor(content[colorOffset] << 8 | content[colorOffset + 1])
					: GetStColor(content, colorOffset);
			}
		}
		return true;
	}

	bool DecodeSpu!(byte[] content, int contentLength)
		=> contentLength == 51104 && DecodeSpuScreen(content, 160, 199, IsStringAt(content, 0, "5BIT"));

	static bool UnpackSpc(RleStream! rle, byte[]! unpacked)
	{
		for (int bitplane = 0; bitplane < 8; bitplane += 2) {
			if (!rle.UnpackWords(unpacked, 160 + bitplane, 8, 32000))
				return false;
		}
		return true;
	}

	bool DecodeStSpc!(byte[] content, int contentLength)
	{
		if (contentLength < 12
		 || content[0] != 'S' || content[1] != 'P')
			return false;
		byte[51104] unpacked;

		// bitmap
		SpcStream() rle;
		rle.Content = content;
		rle.ContentOffset = 12;
		rle.ContentLength = contentLength;
		if (!UnpackSpc(rle, unpacked))
			return false;

		// palettes
		int contentOffset = 12 + Get32BigEndian(content, 4);
		if (contentOffset < 12)
			return false;
		for (int unpackedOffset = 32000; unpackedOffset < 51104; ) {
			if (contentOffset >= contentLength - 1)
				return false;
			int got = (content[contentOffset] & 0x7f) << 8 | content[contentOffset + 1];
			contentOffset += 2;
			for (int i = 0; i < 16; i++) {
				if ((got >> i & 1) == 0) {
					unpacked[unpackedOffset] = 0;
					unpacked[unpackedOffset + 1] = 0;
				}
				else {
					if (contentOffset >= contentLength - 1)
						return false;
					unpacked[unpackedOffset] = content[contentOffset];
					unpacked[unpackedOffset + 1] = content[contentOffset + 1];
					contentOffset += 2;
				}
				unpackedOffset += 2;
			}
		}

		return DecodeSpuScreen(unpacked, 160, 199, false);
	}

	bool DecodeSps!(byte[] content, int contentLength)
	{
		if (contentLength < 13
		 || content[0] != 'S' || content[1] != 'P' || content[2] != 0 || content[3] != 0)
			return false;
		byte[51104] unpacked;

		// bitmap
		SpsStream() rle;
		rle.Content = content;
		rle.ContentOffset = 12;
		rle.ContentLength = contentLength;
		if ((content[contentLength - 1] & 1) == 0) {
			for (int bitplane = 0; bitplane < 8; bitplane += 2) {
				for (int x = 0; x < 40; x++) {
					if (!rle.Unpack(unpacked, 160 + ((x & ~1) << 2) + bitplane + (x & 1), 160, 32000))
						return false;
				}
			}
		}
		else if (!UnpackSpc(rle, unpacked))
			return false;

		// palettes
		BitStream() bitStream;
		bitStream.Content = content;
		bitStream.ContentOffset = 12 + Get32BigEndian(content, 4);
		if (bitStream.ContentOffset < 12)
			return false;
		bitStream.ContentLength = contentLength;
		for (int unpackedOffset = 32000; unpackedOffset < 51104; ) {
			int got = bitStream.ReadBits(14);
			if (got < 0)
				return false;
			got <<= 1;
			for (int i = 15; i >= 0; i--) {
				int rgb;
				if ((got >> i & 1) == 0)
					rgb = 0;
				else {
					rgb = bitStream.ReadBits(9);
					if (rgb < 0)
						return false;
				}
				// RRRGGGBBB -> 00000RRR 0GGG0BBB
				unpacked[unpackedOffset] = rgb >> 6;
				unpacked[unpackedOffset + 1] = (rgb & 0x3f) + (rgb & 0x38);
				unpackedOffset += 2;
			}
		}

		return DecodeSpuScreen(unpacked, 160, 199, false);
	}

	bool UnpackAndDecodeSpx!(SpxStream! stream, int contentLength, int height, byte[]! unpacked)
	{
		byte[] content = stream.Content;
		int bitmapLength = height * 160;
		int paletteOffset = stream.ContentOffset;
		int paletteLength = Get32BigEndian(content, stream.ContentStart - 4);

		// unpack bitmap
		if (content[4] == 0)
			content.CopyTo(stream.ContentStart + 160, unpacked, 0, bitmapLength);
		else if (content[3] == 1) {
			if (!stream.Unpack(unpacked, 0, bitmapLength))
				return false;
		}
		else if (content[5] != 1)
			return false;
		else {
			// v2: bitmap&palette
			int packedLength = Get32BigEndian(content, stream.ContentStart + 4);
			int packedEnd = stream.ContentStart +8 + packedLength;
			if (Get32BigEndian(content, stream.ContentStart - 8) != 8 + packedLength
			 || packedEnd > contentLength
			 || packedEnd < 0)
				return false;
			stream.ContentStart += 8;
			stream.ContentOffset = packedEnd;
			if (!stream.UnpackV2(unpacked, height << 8))
				return false;
		}

		// unpack palette
		if (content[5] == 0) {
			if (paletteLength != height * 96)
				return false;
			content.CopyTo(paletteOffset, unpacked, bitmapLength, paletteLength);
		}
		else if (content[3] == 1) {
			stream.ContentStart = paletteOffset;
			stream.ContentOffset = paletteOffset + paletteLength;
			if (stream.ContentOffset > contentLength
			 || stream.GetUnpackedLength() != height * 96
			 || !stream.Unpack(unpacked, bitmapLength, height << 8))
				return false;
		}

		return DecodeSpuScreen(unpacked, 0, height, false);
	}

	bool DecodeSpx!(byte[] content, int contentLength)
	{
		if (contentLength < 12 || content[0] != 'S' || content[1] != 'P' || content[2] != 'X')
			return false;

		// skip descriptions
		int contentOffset = 10;
		for (int zerosToSkip = 2;;) {
			if (contentOffset + 16 >= contentLength)
				return false;
			if (content[contentOffset++] == 0) {
				if (--zerosToSkip == 0)
					break;
			}
		}

		// determine height
		int bitmapLength = Get32BigEndian(content, contentOffset);
		SpxStream() stream;
		stream.Content = content;
		stream.ContentStart = contentOffset + 8;
		stream.ContentOffset = contentOffset + 8 + bitmapLength;
		if (stream.ContentOffset > contentLength)
			return false;
		switch (content[4]) {
		case 0:
			bitmapLength -= 160;
			break;
		case 1:
			switch (content[3]) {
			case 1:
				bitmapLength = stream.GetUnpackedLength() - 160;
				break;
			case 2:
				bitmapLength = Get32BigEndian(content, contentOffset + 4) - 320;
				break;
			default:
				return false;
			}
			break;
		default:
			return false;
		}
		if (bitmapLength <= 0 || bitmapLength % 160 != 0)
			return false;
		int height = bitmapLength / 160;
		byte[]# unpacked = new byte[height << 8];
		return UnpackAndDecodeSpx(stream, contentLength, height, unpacked);
	}

	static int GetStLowSeparateBitplanes(byte[] content, int contentOffset, int bitplaneLength, int x)
		=> GetBitplanePixel(content, contentOffset + (x >> 3), x, 4, bitplaneLength);

	bool DecodePci!(byte[] content, int contentLength)
	{
		if (contentLength != 115648)
			return false;
		SetSize(352, 278, IsStePalette(content, 0x17e40, 8896) ? RECOILResolution.Ste1x1 : RECOILResolution.St1x1, 2);
		int bitmapOffset = 0;
		for (int y = 0; y < 2 * 278; y++) {
			if (y == 278)
				bitmapOffset = 0xbf20;
			SetStPalette(content, 0x17e40 + (y << 5), 16);
			for (int x = 0; x < 352; x++)
				Pixels[y * 352 + x] = ContentPalette[GetStLowSeparateBitplanes(content, bitmapOffset, 278 * 44, x)];
			bitmapOffset += 44;
		}
		return ApplyBlend();
	}

	void DecodePcsScreen!(byte[] unpacked, int pixelsOffset)
	{
		for (int y = 0; y < 199; y++) {
			for (int x = 0; x < 320; x++) {
				int c = GetStLowSeparateBitplanes(unpacked, 40 + y * 40, 8000, x) << 1;
				// http://www.atari-forum.com/wiki/index.php?title=ST_Picture_Formats
				if (x >= c * 2) {
					if (c < 14 * 2) {
						if (x >= c * 2 + 76) {
							if (x >= 176 + c * 5 - (c & 2) * 3)
								c += 32;
							c += 32;
						}
					}
					else if (x >= c * 2 + 92)
						c += 32;
					c += 32;
				}
				Pixels[pixelsOffset++] = GetStColor(unpacked, 32000 + y * 96 + c);
			}
		}
	}

	bool DecodePcs!(byte[] content, int contentLength)
	{
		if (contentLength < 18
		 || content[0] != 0x01 || content[1] != 0x40 || content[2] != 0x00 || content[3] != 0xc8)
			return false;

		PcsStream() rle;
		rle.Content = content;
		rle.ContentOffset = 6;
		rle.ContentLength = contentLength;
		byte[PcsStream.UnpackedLength] unpacked1;
		if (!rle.UnpackPcs(unpacked1))
			return false;
		if (content[4] == 0) {
			SetSize(320, 199, IsStePalette(unpacked1, 32000, 9616) ? RECOILResolution.Ste1x1 : RECOILResolution.St1x1);
			DecodePcsScreen(unpacked1, 0);
			return true;
		}

		byte[PcsStream.UnpackedLength] unpacked2;
		if (!rle.UnpackPcs(unpacked2))
			return false;
		if ((content[4] & 1) == 0) {
			for (int i = 0; i < 32000; i++)
				unpacked2[i] ^= unpacked1[i];
		}
		if ((content[4] & 2) == 0) {
			for (int i = 32000; i < PcsStream.UnpackedLength; i++)
				unpacked2[i] ^= unpacked1[i];
		}
		SetSize(320, 199, IsStePalette(unpacked1, 32000, 9616) || IsStePalette(unpacked2, 32000, 9616) ? RECOILResolution.Ste1x1 : RECOILResolution.St1x1, 2);
		DecodePcsScreen(unpacked1, 0);
		DecodePcsScreen(unpacked2, 320 * 199);
		return ApplyBlend();
	}

	byte[] UnpackPbx(byte[] content, int contentLength, byte[]! unpacked, int bitmapOffset, int bytesPer16Pixels, int unpackedLength)
	{
		if (content[4] != 0x80 || content[5] != 1)
			return contentLength == unpackedLength ? content : null;
		PackBitsStream() rle;
		rle.Content = content;
		rle.ContentOffset = 128;
		rle.ContentLength = contentLength;
		if (!rle.Unpack(unpacked, 128, 1, bitmapOffset))
			return null;
		for (int bitplane = 0; bitplane < bytesPer16Pixels; bitplane += 2) {
			for (int x = bitplane; x < 160; x += bytesPer16Pixels) {
				if (!rle.UnpackWords(unpacked, bitmapOffset + x, 160, unpackedLength))
					return null;
			}
		}
		return unpacked;
	}

	bool DecodePbx01!(byte[] content, int contentLength, int bitplanes, int lineHeight)
	{
		byte[32512] unpacked;
		content = UnpackPbx(content, contentLength, unpacked, 512, bitplanes << 1, 32512);
		if (content == null || content[128 + 33] != 0)
			return false;
		int paletteOffset = 128;
		for (int y = 0; y < 200; y++) {
			if (paletteOffset < 512 && y == content[paletteOffset + 33]) {
				SetStPalette(content, paletteOffset, 16);
				do
					paletteOffset += 48;
				while (paletteOffset < 512 && content[paletteOffset + 34] == 0 && content[paletteOffset + 35] == 0);
			}
			DecodeBitplanes(content, 512 + y * 160, 0, bitplanes, y * lineHeight * Width, Width, lineHeight);
		}
		return true;
	}

	void DecodePbx8!(byte[] content, int paletteOffset, int bitmapOffset, int pixelsOffset)
	{
		for (int y = 0; y < 200; y++) {
			for (int x = 0; x < 320; x++) {
				int c = GetStLowPixel(content, bitmapOffset + y * 160, x);
				if (x >= (c > 7 ? 88 : 76) + c * 10 - (c & 1) * 6)
					c += 16;
				Pixels[pixelsOffset + x] = GetStColor(content, paletteOffset + (y << 6) + (c << 1));
			}
			pixelsOffset += 320;
		}
	}

	bool DecodePbx!(byte[] content, int contentLength)
	{
		if (contentLength < 128 || content[0] != 0 || content[1] != 0 || content[2] != 0)
			return false;
		switch (content[3]) {
		case 0:
			SetSize(320, 200, RECOILResolution.St1x1);
			return DecodePbx01(content, contentLength, 4, 1);
		case 1:
			SetSize(640, 400, RECOILResolution.St1x2);
			return DecodePbx01(content, contentLength, 2, 2);
		case 0x80: {
				byte[44928] unpacked;
				content = UnpackPbx(content, contentLength, unpacked, 0x3280, 8, 44928);
				if (content == null)
					return false;
				SetSize(320, 200, RECOILResolution.St1x1);
				DecodePbx8(content, 128, 0x3280, 0);
				return true;
			}
		case 0x81: {
				byte[57728] unpacked;
				content = UnpackPbx(content, contentLength, unpacked, 0x6480, 8, 57728);
				if (content == null)
					return false;
				SetSize(320, 200, RECOILResolution.St1x1, 2);
				DecodePbx8(content, 128, 0x6480, 0);
				DecodePbx8(content, 0x3280, 0x6480, 320 * 200);
				return ApplyBlend();
			}
		default:
			return false;
		}
	}

	void DecodeMppScreen!(byte[] content, int paletteOffset, int paletteLength, int pixelsOffset)
	{
		int mode = content[3];
		int bitmapOffset = paletteOffset + paletteLength;
		int[16] palette = 0;
		MppPaletteStream() paletteStream;
		paletteStream.Content = content;
		paletteStream.ContentOffset = paletteOffset;
		paletteStream.ContentLength = bitmapOffset;

		for (int y = 0; y < Height; y++) {
			// For modes 0,1,2 palette[0] is black here.
			// No need to set it here, because it's black initially
			// and at the end of the previous line.
			// For mode 3 six colors remain from the previous line.
			for (int c = mode == 3 ? 6 : 1; c < 16; c++)
				palette[c] = paletteStream.Read();
			const byte[4] firstChangeX = { 33, 9, 4, 69 };
			int changeX = firstChangeX[mode];
			int changeColor = 0;
			for (int x = 0; x < Width; x++) {
				if (x == changeX) {
					// For modes 0,1,2 palette[0] is black in the last palette in line
					// and not stored in the file.
					// This is not the case for mode 3.
					const byte[4] rightBorderColor = { 0x20, 0x10, 0x20, 0x7f };
					palette[changeColor & 0xf] = changeColor == rightBorderColor[mode] ? 0 : paletteStream.Read();
					switch (mode) {
					case 0:
					case 3:
						switch (changeColor) {
						case 15:
							changeX += mode == 0 ? 88 : 112;
							break;
						case 31:
							changeX += 12;
							break;
						case 37:
							changeX += 100;
							break;
						default:
							changeX += 4;
							break;
						}
						break;
					case 1:
						changeX += (changeColor & 1) == 0 ? 4 : 16;
						break;
					case 2:
						changeX += 8;
						break;
					default:
						assert false;
					}
					changeColor++;
				}

				Pixels[pixelsOffset + x] = palette[GetStLowPixel(content, bitmapOffset, x)];
			}
			bitmapOffset += Width >> 1;
			pixelsOffset += Width;
		}
	}

	bool DecodeMpp!(byte[] content, int contentLength)
	{
		if (contentLength < 12
		 || content[0] != 'M' || content[1] != 'P' || content[2] != 'P')
			return false;

		int mode = content[3];
		if (mode > 3)
			return false;
		int width = mode < 3 ? 320 : 416;
		int height = mode < 3 ? 199 : 273;
		int frames = 1 + ((content[4] >> 2) & 1);
		const byte[4] modeColorsPerLine = { 52, 46, 54, 48 };
		int paletteLength = modeColorsPerLine[mode] * height;
		switch (content[4] & 3) {
		case 0:
			SetSize(width, height, RECOILResolution.St1x1, frames);
			paletteLength *= 9;
			break;
		case 1:
			SetSize(width, height, RECOILResolution.Ste1x1, frames);
			paletteLength *= 12;
			break;
		case 3:
			SetSize(width, height, RECOILResolution.Ste1x1, frames);
			Frames = 2;
			paletteLength *= 15;
			break;
		default:
			return false;
		}
		paletteLength = paletteLength + 15 >> 4 << 1;
		int paletteOffset = 12 + Get32BigEndian(content, 8);
		if (paletteOffset < 12)
			return false;
		int pixelsLength = width * height;
		if (contentLength != paletteOffset + (paletteLength + (pixelsLength >> 1)) * frames)
			return false;

		DecodeMppScreen(content, paletteOffset, paletteLength, 0);
		if (frames == 1)
			return true;
		DecodeMppScreen(content, paletteOffset + paletteLength + (pixelsLength >> 1), paletteLength, pixelsLength);
		return ApplyBlend();
	}

	bool DecodeHrm!(byte[] content, int contentLength)
	{
		if (contentLength != 92000)
			return false;
		SetSize(640, 400, RECOILResolution.Ste1x2);
		Frames = 2;
		for (int y = 0; y < 400; y++) {
			for (int x = 0; x < 640; x++) {
				int offset = y * 160 + (x >> 2 & ~3) + (x >> 3 & 1);
				int bit = ~x & 7;
				int c = content[offset] >> bit & 1 | (content[offset + 2] >> bit & 1) << 1;
				const byte[4] colorOffsets = { 80, 72, 40, 32 };
				c += ((x + colorOffsets[c]) / 80 << 2) - 1;
				int rgb = GetStColor(content, 64000 + y * 70 + (c << 1));
				int pixelsOffset = y * 640 + x;
				if ((y & 1) == 0)
					Pixels[pixelsOffset] = rgb;
				else {
					int rgb1 = Pixels[pixelsOffset - 640];
					Pixels[pixelsOffset] = Pixels[pixelsOffset - 640] = (rgb1 & rgb) + ((rgb1 ^ rgb) >> 1 & 0x7f7f7f);
				}
			}
		}
		return true;
	}

	bool DecodeStIcn!(byte[] content, int contentLength)
	{
		const int maxWidth = 256;
		const int maxHeight = 256;
		IcnParser() parser;
		parser.Content = content;
		parser.ContentOffset = 0;
		parser.ContentLength = contentLength;
		int width = parser.ParseDefine("ICON_W");
		if (width <= 0 || width >= maxWidth)
			return false;
		int height = parser.ParseDefine("ICON_H");
		if (height <= 0 || height >= maxHeight)
			return false;
		int size = parser.ParseDefine("ICONSIZE");
		if (size != (width + 0xf >> 4) * height)
			return false;
		if (!parser.Expect("int")
		 || !parser.Expect("image[ICONSIZE]")
		 || !parser.Expect("=")
		 || !parser.Expect("{"))
			return false;
		byte[maxWidth / 8 * maxHeight] bitmap;
		for (int i = 0; ; ) {
			int value = parser.ParseHex();
			if (value < 0)
				return false;
			bitmap[i * 2] = value >> 8;
			bitmap[i * 2 + 1] = value & 0xff;
			if (++i >= size)
				break;
			if (parser.ContentOffset >= contentLength)
				return false;
			if (content[parser.ContentOffset++] != ',')
				return false;
		}
		if (!parser.Expect("};"))
			return false;
		SetSize(width, height, RECOILResolution.St1x1);
		return DecodeBlackAndWhite(bitmap, 0, size << 1, true, 0xffffff);
	}

	bool DecodeCe!(byte[] content, int contentLength)
	{
		if (contentLength < 192022 || !IsStringAt(content, 0, "EYES") || content[4] != 0)
			return false;
		switch (content[5]) {
		case 0: // CE1
			if (contentLength != 192022)
				return false;
			SetSize(320, 200, RECOILResolution.St1x1);
			for (int y = 0; y < 200; y++) {
				for (int x = 0; x < 320; x++) {
					int offset = 22 + x * 200 + y;
					int rgb = content[offset] << 16 | content[64000 + offset] << 8 | content[128000 + offset];
					if ((rgb & 0xc0c0c0) != 0)
						return false;
					Pixels[y * 320 + x] = rgb << 2 | (rgb >> 4 & 0x030303);
				}
			}
			return true;
		case 1: // CE2
			if (contentLength != 256022)
				return false;
			SetSize(640, 400, RECOILResolution.St1x2);
			for (int y = 0; y < 200; y++) {
				for (int x = 0; x < 640; x++) {
					int offset = 11 + x * 200 + y << 1;
					int c = content[offset] << 8 | content[offset + 1];
					if (c >= 0x8000)
						return false;
					offset = y * 1280 + x;
					Pixels[offset + 640] = Pixels[offset] = GetR5G5B5Color(c);
				}
			}
			return true;
		case 2: // CE3
			if (contentLength != 256022)
				return false;
			SetSize(640, 400, RECOILResolution.St1x1);
			for (int y = 0; y < 400; y++) {
				for (int x = 0; x < 640; x++) {
					int b = content[22 + x * 400 + (y & 1) * 200 + (y >> 1)];
					// 192 levels because it's a sum of 6-bit R, G and B
					if (b > 191)
						return false;
					Pixels[y * 640 + x] = b * 4 / 3 * 0x010101;
				}
			}
			return true;
		default:
			return false;
		}
	}

	// Atari Falcon formats.

	bool DecodeIbi!(byte[] content, int contentLength)
	{
		if ((contentLength != 704 && contentLength != 1600)
		 || content[0] != 'I' || content[1] != 'C' || content[2] != 'B'
		 || (content[3] != 'I' && content[3] != '3')
		 || content[8] != 0 || content[9] != 0x20 || content[10] != 0 || content[11] != 0x20)
			return false;
		SetSize(32, 32, RECOILResolution.Falcon1x1);
		SetDefaultStPalette(4);
		DecodeBitplanes(content, 0x40, 16, 4, 0, 32, 32);
		return true;
	}

	bool DecodeFalconGrayscale!(byte[] content, int contentOffset, int contentLength, int width, int height)
	{
		int pixelsLength = width * height;
		if (contentLength != contentOffset + pixelsLength
		 || !SetSize(width, height, RECOILResolution.Falcon1x1))
			return false;
		for (int i = 0; i < pixelsLength; i++)
			Pixels[i] = content[contentOffset + i] * 0x010101;
		return true;
	}

	bool DecodeBw!(byte[] content, int contentLength)
	{
		if (contentLength < 11 || !IsStringAt(content, 0, "B&W256"))
			return false;
		int width = content[6] << 8 | content[7];
		int height = content[8] << 8 | content[9];
		return DecodeFalconGrayscale(content, 10, contentLength, width, height);
	}

	bool DecodeFalconHir!(byte[] content, int contentLength)
	{
		if (contentLength < 11 || content[0] != 0xf || content[1] != 0xf
		 || content[2] != 0 || content[3] != 1 || content[8] != 0 || content[9] != 1)
			return false;
		int width = content[4] << 8 | content[5];
		int height = content[6] << 8 | content[7];
		int pixelsLength = width * height;
		if (contentLength != 10 + pixelsLength
		 || !SetSize(width, height, RECOILResolution.Falcon1x1))
			return false;
		for (int i = 0; i < pixelsLength; i++) {
			int b = content[10 + i];
			if (b >= 128)
				return false;
			Pixels[i] = b * 0x020202;
		}
		return true;
	}

	bool DecodeRw!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 64000: // RWL
			SetSize(320, 200, RECOILResolution.Falcon1x1);
			break;
		case 128000: // RAW
			SetSize(640, 200, RECOILResolution.Falcon1x1);
			break;
		case 256000: // RWH
			SetSize(640, 400, RECOILResolution.Falcon1x1);
			break;
		default:
			return false;
		}
		for (int i = 0; i < contentLength; i++)
			Pixels[i] = (255 - content[i]) * 0x010101;
		return true;
	}

	void DecodeR8G8G8X8Colors!(byte[] content, int contentOffset, int count)
	{
		for (int i = 0; i < count; i++)
			Pixels[i] = GetR8G8B8Color(content, contentOffset + (i << 2));
	}

	bool DecodeIim!(byte[] content, int contentLength)
	{
		if (contentLength < 17 || !IsStringAt(content, 0, "IS_IMAGE") || content[8] != 0)
			return false;
		int width = content[12] << 8 | content[13];
		int height = content[14] << 8 | content[15];
		int pixelsLength = width * height;
		switch (content[9]) {
		case 0:
			return SetSize(width, height, RECOILResolution.Falcon1x1)
				&& DecodeBlackAndWhite(content, 16, contentLength, false, 0xffffff);
		case 1:
			return DecodeFalconGrayscale(content, 16, contentLength, width, height);
		case 4:
			if (contentLength != 16 + pixelsLength * 3
			 || !SetSize(width, height, RECOILResolution.Falcon1x1))
				return false;
			DecodeR8G8B8Colors(content, 16, pixelsLength, Pixels, 0);
			return true;
		case 5:
			if (contentLength != 16 + (pixelsLength << 2)
			 || !SetSize(width, height, RECOILResolution.Falcon1x1))
				return false;
			DecodeR8G8G8X8Colors(content, 17, pixelsLength);
			return true;
		default:
			return false;
		}
	}

	void SetFalconPalette!(byte[] content, int contentOffset)
	{
		for (int i = 0; i < 256; i++) {
			int offset = contentOffset + (i << 2);
			ContentPalette[i] = content[offset] << 16 | content[offset + 1] << 8 | content[offset + 3];
		}
	}

	void DecodeFalconPalette!(byte[] content, int bitplanesOffset, int paletteOffset, int width, int height)
	{
		SetFalconPalette(content, paletteOffset);
		SetSize(width, height, RECOILResolution.Falcon1x1);
		DecodeBitplanes(content, bitplanesOffset, width, 8, 0, width, height);
	}

	bool DecodeFuckpaint!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 65024:
			DecodeFalconPalette(content, 1024, 0, 320, 200);
			return true;
		case 77824:
			DecodeFalconPalette(content, 1024, 0, 320, 240);
			return true;
		case 308224:
			DecodeFalconPalette(content, 1024, 0, 640, 480);
			return true;
		default:
			return false;
		}
	}

	bool DecodeDg1!(byte[] content, int contentLength)
	{
		if (contentLength != 65032
		 || content[0] != 'D' || content[1] != 'G' || content[2] != 'U' || content[3] != 1
		 || content[4] != 1 || content[5] != 64 || content[6] != 0 || content[7] != 200)
			return false;
		DecodeFalconPalette(content, 1032, 8, 320, 200);
		return true;
	}

	bool DecodeDc1!(byte[] content, int contentLength)
	{
		if (contentLength < 1042
		 || content[0] != 'D' || content[1] != 'G' || content[2] != 'C'
		 || content[4] != 1 || content[5] != 64 || content[6] != 0 || content[7] != 200)
			return false;
		int compression = content[3];
		if (compression == 0) {
			if (contentLength != 65034)
				return false;
			DecodeFalconPalette(content, 1034, 10, 320, 200);
			return true;
		}
		if (compression > 3)
			return false;

		byte[64000] unpacked;
		int contentOffset = 0x40e;
		int valueBytes = 1 << compression - 1; // 1, 2 or 4
		int repeatCount = 0;
		for (int bitplane = 0; bitplane < 16; bitplane += 2) {
			for (int unpackedOffset = bitplane; unpackedOffset < 64000; unpackedOffset += 16) {
				for (int x = 0; x < 2; x++) {
					if (repeatCount == 0) {
						int nextContentOffset = contentOffset + compression * 2;
						if (nextContentOffset > contentLength) {
							unpacked[unpackedOffset + x] = 0;
							continue;
						}
						switch (compression) {
						case 1:
							repeatCount = content[contentOffset] + 1;
							break;
						case 2:
							repeatCount = (content[contentOffset] << 8) + content[contentOffset + 1] + 1 << 1;
							break;
						case 3:
							repeatCount = (content[contentOffset] << 8) + content[contentOffset + 1] + 1 << 2;
							break;
						default:
							assert false;
						}
						contentOffset = nextContentOffset;
					}
					unpacked[unpackedOffset + x] = content[contentOffset - (--repeatCount & valueBytes - 1) - 1];
				}
			}
		}

		SetFalconPalette(content, 10);
		SetSize(320, 200, RECOILResolution.Falcon1x1);
		DecodeBitplanes(unpacked, 0, 320, 8, 0, 320, 200);
		return true;
	}

	bool DecodeDel!(byte[] content, int contentLength)
	{
		byte[96000] unpacked;
		return CaStream.UnpackDel(content, contentLength, unpacked, 2)
			&& DecodeFuckpaint(unpacked, 77824);
	}

	bool DecodeDph!(byte[] content, int contentLength)
	{
		byte[]# unpacked = new byte[320000];
		if (!CaStream.UnpackDel(content, contentLength, unpacked, 10))
			return false;
		SetFalconPalette(unpacked, 0);
		SetSize(640, 480, RECOILResolution.Falcon1x1);
		// Combine four 320x240 quarters:
		// 1 2
		// 3 4
		DecodeBitplanes(unpacked, 1024, 320, 8, 0, 320, 240);
		DecodeBitplanes(unpacked, 1024 + 76800, 320, 8, 320, 320, 240);
		DecodeBitplanes(unpacked, 1024 + 2 * 76800, 320, 8, 240 * 640, 320, 240);
		DecodeBitplanes(unpacked, 1024 + 3 * 76800, 320, 8, 240 * 640 + 320, 320, 240);
		return true;
	}

	bool DecodeFalconTrueColor!(byte[] content, int contentOffset, int width, int height, RECOILResolution resolution)
	{
		if (!SetScaledSize(width, height, resolution))
			return false;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				SetScaledPixel(x, y, GetFalconTrueColor(content, contentOffset));
				contentOffset += 2;
			}
		}
		return true;
	}

	bool DecodeFalconTrueColorVariable!(byte[] content, int contentLength, int widthOffset, int dataOffset)
	{
		int width = content[widthOffset] << 8 | content[widthOffset + 1];
		int height = content[widthOffset + 2] << 8 | content[widthOffset + 3];
		return dataOffset + width * height * 2 == contentLength
			&& DecodeFalconTrueColor(content, dataOffset, width, height, RECOILResolution.Falcon1x1);
	}

	bool DecodeFtc!(byte[] content, int contentLength)
		=> contentLength == 184320 && DecodeFalconTrueColor(content, 0, 384, 240, RECOILResolution.Falcon1x1);

	bool DecodeXga!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 153600:
			return DecodeFalconTrueColor(content, 0, 320, 240, RECOILResolution.Falcon1x1);
		case 368640:
			return DecodeFalconTrueColor(content, 0, 384, 480, RECOILResolution.Falcon2x1);
		default:
			return false;
		}
	}

	bool DecodeGod!(byte[] content, int contentLength)
		=> contentLength > 6 && DecodeFalconTrueColorVariable(content, contentLength, 2, 6);

	bool DecodeTrp!(byte[] content, int contentLength)
	{
		return contentLength >= 9
			&& (IsStringAt(content, 0, "TRUP") || IsStringAt(content, 0, "tru?"))
			&& DecodeFalconTrueColorVariable(content, contentLength, 4, 8);
	}

	bool DecodeTru!(byte[] content, int contentLength)
	{
		return contentLength >= 256
			&& IsStringAt(content, 0, "Indy")
			&& DecodeFalconTrueColorVariable(content, contentLength, 4, 256);
	}

	bool DecodeTg1!(byte[] content, int contentLength)
	{
		return contentLength >= 20 && IsStringAt(content, 0, "COKE format.")
			&& content[16] == 0 && content[17] == 0x12
			&& DecodeFalconTrueColorVariable(content, contentLength, 12, 18);
	}

	bool DecodeTcp!(byte[] content, int contentLength)
	{
		return contentLength >= 218 && IsStringAt(content, 0, "TRUECOLR")
			&& content[12] == 0 && content[13] == 0x12 && content[14] == 0 && content[15] == 1
			&& content[16] == 0 && content[17] == 1 && IsStringAt(content, 0x12, "PICT")
			&& DecodeFalconTrueColorVariable(content, contentLength, 0x1c, 0xd8);
	}

	bool DecodeTre!(byte[] content, int contentLength)
	{
		if (contentLength < 13 || !IsStringAt(content, 0, "tre1"))
			return false;
		int width = content[4] << 8 | content[5];
		int height = content[6] << 8 | content[7];
		if (!SetSize(width, height, RECOILResolution.Falcon1x1))
			return false;
		Tre1Stream() rle;
		rle.Content = content;
		rle.ContentOffset = 12;
		rle.ContentLength = contentLength;
		int pixelsLength = width * height;
		for (int i = 0; i < pixelsLength; i++) {
			int rgb = rle.ReadRle();
			if (rgb < 0)
				return false;
			Pixels[i] = rgb;
		}
		return true;
	}

	bool DecodeRag!(byte[] content, int contentLength)
	{
		if (contentLength < 55 || !IsStringAt(content, 0, "RAG-D!")
		 || content[6] != 0 || content[7] != 0 || content[16] != 0)
			return false;
		int width = content[12] << 8 | content[13];
		if ((width & 15) != 0)
			return false;
		int height = (content[14] << 8) + content[15] + 1;
		int bitplanes = content[17];
		int paletteLength = Get32BigEndian(content, 18);
		switch (bitplanes) {
		case 1:
		case 2:
		case 4:
		case 8:
			switch (paletteLength) {
			case 32:
				if (bitplanes > 4)
					return false;
				break;
			case 1024:
				break;
			default:
				return false;
			}
			int bytesPerLine = (width >> 3) * bitplanes;
			if (30 + paletteLength + height * bytesPerLine > contentLength
			 || !SetSize(width, height, RECOILResolution.Falcon1x1))
				return false;
			if (paletteLength == 32)
				SetStPalette(content, 30, 16);
			else
				SetFalconPalette(content, 30);
			DecodeBitplanes(content, 30 + paletteLength, bytesPerLine, bitplanes, 0, width, height);
			return true;
		case 16:
			return paletteLength == 1024
				&& contentLength >= 0x41e + width * height * 2
				&& DecodeFalconTrueColor(content, 0x41e, width, height, RECOILResolution.Falcon1x1);
		default:
			return false;
		}
	}

	bool DecodeFalconFun!(byte[] content, int contentLength)
	{
		if (contentLength < 14
		 || content[0] != 0 || content[1] != 0xa || content[2] != 0xcf || content[3] != 0xe2
		 || content[8] != 0)
			return false;
		int width = content[4] << 8 | content[5];
		if ((width & 15) != 0)
			return false;
		int height = content[6] << 8 | content[7];
		int bitplanes = content[9];
		switch (bitplanes) {
		case 1:
		case 2:
		case 4:
		case 8:
			int bytesPerLine = (width >> 3) * bitplanes;
			int paletteOffset = 13 + 12 + height * bytesPerLine;
			int colors = 1 << bitplanes;
			if (contentLength != paletteOffset + colors * 6
			 || !SetSizeStOrFalcon(width, height, bitplanes, false))
				return false;
			if (bitplanes == 1)
				SetDefaultStPalette(1);
			else
				SetStVdiPalette(content, paletteOffset, colors, bitplanes);
			DecodeScaledBitplanes(content, 13, width, height, bitplanes, false, null);
			return true;
		case 16:
			return contentLength >= 13 + width * height * 2
				&& DecodeFalconTrueColor(content, 13, width, height, RECOILResolution.Falcon1x1);
		default:
			return false;
		}
	}

	bool DecodeEsm!(byte[] content, int contentLength)
	{
		if (contentLength < 812
		 || content[0] != 'T' || content[1] != 'M' || content[2] != 'S' || content[3] != 0
		 || content[4] != 3 || content[5] != 0x2c || content[10] != 0)
			return false;
		int width = content[6] << 8 | content[7];
		int height = content[8] << 8 | content[9];
		if (!SetSize(width, height, RECOILResolution.Falcon1x1))
			return false;
		int pixelsLength = width * height;
		switch (content[11]) {
		case 1:
			return DecodeBlackAndWhite(content, 0x32c, contentLength, false, 0xffffff);
		case 8:
			if (contentLength != 0x32c + pixelsLength)
				return false;
			for (int i = 0; i < 256; i++)
				ContentPalette[i] = content[0x24 + i] << 16 | content[0x124 + i] << 8 | content[0x224 + i];
			for (int i = 0; i < pixelsLength; i++)
				Pixels[i] = ContentPalette[content[0x32c + i]];
			return true;
		case 24:
			if (contentLength != 0x32c + pixelsLength * 3)
				return false;
			DecodeR8G8B8Colors(content, 0x32c, pixelsLength, Pixels, 0);
			return true;
		default:
			return false;
		}
	}

	bool DecodeFalconPix!(byte[] content, int contentLength)
	{
		if (contentLength < 15 || !IsStringAt(content, 0, "PIXT") || content[4] != 0)
			return false;
		int contentOffset;
		switch (content[5]) {
		case 1:
			contentOffset = 14;
			break;
		case 2:
			contentOffset = 16;
			break;
		default:
			return false;
		}
		int width = content[8] << 8 | content[9];
		if ((width & 15) != 0)
			return false;
		int bitplanes = content[7];
		int height = content[10] << 8 | content[11];
		int pixelsLength;
		switch (bitplanes) {
		case 1:
			return content[6] == 1
				&& SetSizeStOrFalcon(width, height, 1, false)
				&& DecodeBlackAndWhite(content, contentOffset, contentLength, true, 0xffffff);
		case 2:
		case 4:
			int bitmapOffset = contentOffset + (3 << bitplanes);
			if (content[6] != 1
			 || contentLength != bitmapOffset + (width >> 3) * bitplanes * height
			 || !SetSizeStOrFalcon(width, height, bitplanes, false))
				return false;
			DecodeR8G8B8Colors(content, contentOffset, 1 << bitplanes, ContentPalette, 0);
			DecodeScaledBitplanes(content, bitmapOffset, width, height, bitplanes, false, null);
			return true;
		case 8:
			if (content[6] != 0
			 || contentLength != contentOffset + 768 + width * height
			 || !SetSize(width, height, RECOILResolution.Falcon1x1))
				return false;
			DecodeR8G8B8Colors(content, contentOffset, 256, ContentPalette, 0);
			DecodeBytes(content, contentOffset + 768);
			return true;
		case 16:
			return content[6] == 1
			 && contentLength == contentOffset + width * height * 2
			 && DecodeFalconTrueColor(content, contentOffset, width, height, RECOILResolution.Falcon1x1);
		case 24:
			pixelsLength = width * height;
			if (content[6] != 1
			 || contentLength != contentOffset + pixelsLength * 3
			 || !SetSize(width, height, RECOILResolution.Falcon1x1))
				return false;
			DecodeR8G8B8Colors(content, contentOffset, pixelsLength, Pixels, 0);
			return true;
		case 32:
			pixelsLength = width * height;
			if (contentLength != contentOffset + (pixelsLength << 2)
			 || !SetSize(width, height, RECOILResolution.Falcon1x1))
				return false;
			DecodeR8G8G8X8Colors(content, contentOffset + 1, pixelsLength);
			return true;
		default:
			return false;
		}
	}

	bool DecodePntUnpacked!(byte[] content, byte[] bitmap, int bitmapOffset, int width, int height)
	{
		int bitplanes = content[13];
		switch (bitplanes) {
		case 1:
		case 2:
		case 4:
		case 8:
			if (!SetSizeStOrFalcon(width, height, bitplanes, false))
				return false;
			int paletteLength = content[6] << 8 | content[7];
			SetStVdiPalette(content, 128, paletteLength, bitplanes);
			DecodeScaledBitplanes(bitmap, bitmapOffset, width, height, bitplanes, false, null);
			return true;
		case 16:
			return DecodeFalconTrueColor(bitmap, bitmapOffset, width, height, RECOILResolution.Falcon1x1);
		case 24:
			if (!SetSize(width, height, RECOILResolution.Falcon1x1))
				return false;
			for (int y = 0; y < height; y++) {
				DecodeR8G8B8Colors(bitmap, bitmapOffset, width, Pixels, y * width);
				bitmapOffset += (width + 15 & ~15) * 3;
			}
			return true;
		default:
			return false;
		}
	}

	bool DecodeFalconPnt!(byte[] content, int contentLength)
	{
		if (contentLength < 128 || content[0] != 'P' || content[1] != 'N' || content[2] != 'T' || content[3] != 0
		 || content[4] != 1 || content[5] != 0 || content[12] != 0 || content[14] != 0)
			return false;
		int paletteLength = content[6] << 8 | content[7];
		int bitmapOffset = 128 + paletteLength * 6;
		int bitmapLength = Get32BigEndian(content, 16);
		if (bitmapLength <= 0 || contentLength < bitmapOffset + bitmapLength)
			return false;
		int width = content[8] << 8 | content[9];
		int height = content[10] << 8 | content[11];
		int bitplanes = content[13];
		int unpackedLength = (width + 15 >> 4 << 1) * height * bitplanes;
		switch (content[15]) {
		case 0:
			return bitmapLength == unpackedLength
				&& DecodePntUnpacked(content, content, bitmapOffset, width, height);
		case 1:
			byte[]# unpacked = new byte[unpackedLength];
			PackBitsStream() rle;
			rle.Content = content;
			rle.ContentOffset = bitmapOffset;
			rle.ContentLength = contentLength;
			return rle.UnpackBitplaneLines(unpacked, width, height, bitplanes, true, false)
				&& DecodePntUnpacked(content, unpacked, 0, width, height);
		default:
			return false;
		}
	}

	// Amiga formats.

	internal void SetOcsColor!(int c, int r, int gb)
	{
		int rgb = (r & 0xf) << 16 | (gb & 0xf0) << 4 | (gb & 0xf); // 0x0R0G0B
		ContentPalette[c] = rgb * 0x11; // 0xRRGGBB
	}

	internal void SetOcsPalette!(byte[] content, int contentOffset, int colors)
	{
		for (int c = 0; c < colors; c++) {
			int r = content[contentOffset++];
			int gb = content[contentOffset++];
			SetOcsColor(c, r, gb);
		}
	}

	bool DecodeInfo!(byte[] content, int contentLength)
	{
		if (contentLength < 98 || content[0] != 0xe3 || content[1] != 0x10 || content[2] != 0 || content[3] != 1)
			return false;

		const int[4] os1Palette = { 0x55AAFF, 0xFFFFFF, 0x000000, 0xFF8800 };
		const int[8] os2Palette = { 0x959595, 0x000000, 0xFFFFFF, 0x3B67A2, 0x7B7B7B, 0xAFAFAF, 0xAA907C, 0xFFA997 };
		int[] palette;
		switch (Get32BigEndian(content, 0x2c)) {
		case 0:
			palette = os1Palette;
			break;
		case 1:
			palette = os2Palette;
			break;
		default:
			return false;
		}

		int contentOffset = Get32BigEndian(content, 0x42) == 0 ? 0x4e : 0x4e + 0x38; // skip DrawerData if present
		int width = content[contentOffset + 4] << 8 | content[contentOffset + 5];
		int height = content[contentOffset + 6] << 8 | content[contentOffset + 7];
		int bitplanes = content[contentOffset + 8] << 8 | content[contentOffset + 9];
		switch (bitplanes) {
		case 2:
			break;
		case 3:
			if (palette == os1Palette)
				return false;
			break;
		default:
			return false;
		}
		int bytesPerLine = width + 15 >> 4 << 1;
		int bitplaneLength = height * bytesPerLine;
		contentOffset += 0x14;
		return contentLength >= contentOffset + bitplanes * bitplaneLength
			&& DecodeAmigaPlanar(content, contentOffset, width, height, RECOILResolution.Amiga1x2, bitplanes, palette);
	}

	bool DecodeAbkSprite!(byte[] content, int contentLength)
	{
		if (content[10] != 0)
			return false;
		int bitplanes = content[11];
		if (bitplanes == 0 || bitplanes > 5)
			return false;
		int width = content[6] << 8 | content[7];
		int height = content[8] << 8 | content[9];
		int bitplaneLength = width * height << 1;
		int paletteOffset = 16 + (bitplanes * bitplaneLength);
		if (paletteOffset + 64 > contentLength)
			return false;
		SetOcsPalette(content, paletteOffset, 32);
		return DecodeAmigaPlanar(content, 16, width << 4, height, RECOILResolution.Amiga1x1, bitplanes, ContentPalette);
	}

	bool DecodeAbk!(byte[] content, int contentLength)
	{
		if (contentLength < 6 + 10 + 2 + 64
		 || content[0] != 'A' || content[1] != 'm')
			return false;
		switch (content[2]) {
		case 'S':
			return content[3] == 'p' && DecodeAbkSprite(content, contentLength);
		case 'I':
			return content[3] == 'c' && DecodeAbkSprite(content, contentLength);
		case 'B':
			break;
		default:
			return false;
		}

		if (content[3] != 'k'
		 || contentLength < 135
		 || !IsStringAt(content, 12, "Pac.Pic")
		 || content[0x6e] != 0x06
		 || content[0x6f] != 0x07
		 || content[0x70] != 0x19
		 || content[0x71] != 0x63
		 || content[0x7c] != 0)
			return false;
		int width = content[0x76] << 8 | content[0x77];
		int lumps = content[0x78] << 8 | content[0x79];
		int lumpLines = content[0x7a] << 8 | content[0x7b];
		int height = lumps * lumpLines;
		int bitplanes = content[0x7d];
		// TODO: 6 bitplanes, (content[0x28] & 8) != 0 ? HAM : EHB
		if (bitplanes == 0 || bitplanes > 5
		 || !SetSize(width << 3, height, RECOILResolution.Amiga1x1))
			return false;
		int rleOffset = 0x6e + Get32BigEndian(content, 0x7e);
		if (rleOffset < 0 || rleOffset >= contentLength)
			return false;
		int pointsOffset = 0x6e + Get32BigEndian(content, 0x82);
		if (pointsOffset < 0)
			return false;
		byte[]# unpacked = new byte[bitplanes * width * height];
		int picOffset = 0x87;
		byte pic = content[0x86];
		int rleBits = content[rleOffset++] << 8 | 0x80;
		int pointsBits = 0;
		for (int bitplane = 0; bitplane < bitplanes; bitplane++) {
			for (int lump = 0; lump < lumps; lump++) {
				for (int x = 0; x < width; x++) {
					for (int y = 0; y < lumpLines; y++) {
						rleBits <<= 1;
						if ((rleBits & 0xff) == 0) {
							pointsBits <<= 1;
							if ((pointsBits & 0xff) == 0) {
								if (pointsOffset >= contentLength)
									return false;
								pointsBits = content[pointsOffset++] << 1 | 1;
							}
							if ((pointsBits >> 8 & 1) != 0) {
								if (rleOffset >= contentLength)
									return false;
								rleBits = content[rleOffset++] << 1 | 1;
							}
							else {
								rleBits >>= 8;
							}
						}
						if ((rleBits >> 8 & 1) != 0) {
							pic = content[picOffset++];
						}
						unpacked[((bitplane * lumps + lump) * lumpLines + y) * width + x] = pic;
					}
				}
			}
		}
		SetOcsPalette(content, 0x2e, 32);
		return DecodeAmigaPlanar(unpacked, 0, width << 3, height, RECOILResolution.Amiga1x1, bitplanes, ContentPalette);
	}

	static RECOILResolution GetAmigaAspectRatio(int xRatio, int yRatio, RECOILResolution resolution)
	{
		if (xRatio <= 0 || yRatio <= 0)
			return resolution;
		if (xRatio > yRatio * 6)
			return RECOILResolution.Amiga8x1;
		if (xRatio > yRatio * 3)
			return RECOILResolution.Amiga4x1;
		if (xRatio * 2 > yRatio * 3)
			return RECOILResolution.Amiga2x1;
		if (yRatio > xRatio * 3)
			return RECOILResolution.Amiga1x4;
		if (yRatio * 2 > xRatio * 3)
			return resolution == RECOILResolution.Amiga1x1 ? RECOILResolution.Amiga1x2 : RECOILResolution.St1x2;
		return resolution;
	}

	static RECOILResolution GetCamgAspectRatio(int camg, RECOILResolution resolution)
	{
		int log; // log2 of x/y aspect ratio
		switch (camg & ~0xefff) {
		case 0: // default
		case 0x11000: // NTSC
		case 0x21000: // PAL
		case 0x71000: // EURO36
		case 0xc1000: // Film24
		case 0xd1000: // Super+
			// 15 kHz
			camg &= 0x802c;
			log = 0;
			break;
		case 0x41000: // A2024
			return RECOILResolution.Amiga1x1;
		case 0x51000: // HighGFX
		case 0x81000: // SUPER72
		case 0xb1000: // HD720
		case 0xe1000: // Xtreme
			// 24 kHz
			camg &= 0x802c;
			log = -1;
			break;
		case 0x31000: // Mutiscan
		case 0x61000: // EURO72
			// 31 kHz
			camg &= 0x8025;
			log = -1;
			break;
		case 0x91000: // DBL NTSC
		case 0xa1000: // DBL PAL
			// 30 kHz
			camg &= 0x8205;
			log = 0;
			break;
		default:
			return resolution;
		}

		// horizontal resolution
		switch (camg & 0x8220) {
		case 0:
			break;
		case 0x8000:
			log++;
			break;
		case 0x8020:
			log += 2;
			break;
		case 0x0200:
			log--;
			break;
		default:
			return resolution;
		}

		// vertical resolution
		switch (camg & 0xd) {
		case 0:
			break;
		case 4:
			log--;
			break;
		case 5:
			log -= 2;
			break;
		case 8:
			log++;
			break;
		default:
			return resolution;
		}

		switch (log) {
		case 0:
			return RECOILResolution.Amiga1x1;
		case -1:
			return RECOILResolution.Amiga2x1;
		case -2:
			return RECOILResolution.Amiga4x1;
		case -3:
			return RECOILResolution.Amiga8x1;
		case 1:
			return RECOILResolution.Amiga1x2;
		case 2:
			return RECOILResolution.Amiga1x4;
		default:
			return resolution;
		}
	}

	bool DecodeDeep!(byte[] content, int contentLength)
	{
		int width = 0;
		int height = 0;
		int compression = 0;
		RECOILResolution resolution = RECOILResolution.Amiga1x1;
		DeepStream() rle;
		rle.Content = content;
		int tvdcOffset = -1;
		for (int contentOffset = 12; contentOffset < contentLength - 7; ) {
			int chunkLength = Get32BigEndian(content, contentOffset + 4);
			int chunkEndOffset = contentOffset + 8 + chunkLength; // don't round yet, some files are of odd length
			if (chunkEndOffset > contentLength || chunkEndOffset < contentOffset + 8)
				break;
			if (IsStringAt(content, contentOffset, "DGBL")) {
				if (chunkLength < 8 || content[contentOffset + 12] != 0)
					return false;
				// not sure if DLOC is mandatory, get width and height here just in case
				width = content[contentOffset + 8] << 8 | content[contentOffset + 9];
				height = content[contentOffset + 10] << 8 | content[contentOffset + 11];
				compression = content[contentOffset + 13];
				resolution = GetAmigaAspectRatio(content[contentOffset + 14], content[contentOffset + 15], resolution);
			}
			else if (IsStringAt(content, contentOffset, "DPEL")) {
				if (!rle.SetDpel(contentOffset, chunkLength))
					return false;
			}
			else if (IsStringAt(content, contentOffset, "DLOC")) {
				if (chunkLength < 4)
					return false;
				width = content[contentOffset + 8] << 8 | content[contentOffset + 9];
				height = content[contentOffset + 10] << 8 | content[contentOffset + 11];
			}
			else if (IsStringAt(content, contentOffset, "TVDC")) {
				if (chunkLength != 32)
					return false;
				tvdcOffset = contentOffset + 8;
			}
			else if (IsStringAt(content, contentOffset, "DBOD")) {
				// reject multi-layer pictures instead of decoding just the first layer
				if (chunkEndOffset + 8 < contentLength && IsStringAt(content, chunkEndOffset, "DBOD"))
					return false;
				if (rle.Components <= 0 || !SetScaledSize(width, height, resolution))
					return false;
				rle.ContentOffset = contentOffset + 8;
				rle.ContentLength = chunkEndOffset;
				for (int y = 0; y < height; y++) {
					if (compression == 5) {
						if (tvdcOffset < 0 || !rle.ReadDeltaLine(width, tvdcOffset))
							return false;
					}
					for (int x = 0; x < width; x++) {
						int rgb;
						switch (compression) {
						case 0:
							rgb = rle.ReadValue();
							break;
						case 1:
							rgb = rle.ReadRle();
							break;
						case 5:
							rgb = rle.Line[x];
							break;
						default:
							return false;
						}
						if (rgb < 0)
							return false;
						SetScaledPixel(x, y, rgb);
					}
				}
				return true;
			}
			contentOffset = chunkEndOffset + 1 & ~1; // round up to even bytes
		}
		return false;
	}

	bool DecodeRgbn!(byte[] content, int contentOffset, int contentLength, int width, int height, bool rgb8)
	{
		int rgb = 0;
		int count = 0;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				if (count == 0) {
					if (rgb8) {
						if (contentOffset > contentLength - 4)
							return false;
						rgb = GetR8G8B8Color(content, contentOffset);
						count = content[contentOffset + 3] & 0x7f;
						contentOffset += 4;
					}
					else {
						if (contentOffset > contentLength - 2)
							return false;
						rgb = content[contentOffset]; // 0xRG
						count = content[contentOffset + 1]; // 0xBC
						rgb = (((rgb & 0xf0) << 4 | (rgb & 0xf)) << 8 | count >> 4) * 0x11; // 0xRRGGBB
						count &= 7;
						contentOffset += 2;
					}
					if (count == 0) {
						if (contentOffset >= contentLength)
							return false;
						count = content[contentOffset++];
						if (count == 0) {
							if (contentOffset > contentLength - 2)
								return false;
							count = content[contentOffset] << 8 | content[contentOffset + 1];
							contentOffset += 2;
						}
					}
				}
				SetScaledPixel(x, y, rgb);
				count--;
			}
		}
		return true;
	}

	bool DecodeRast!(byte[] content, int contentOffset, int contentLength, byte[] unpacked, int width, int height, int bitplanes)
	{
		if (!SetSizeStOrFalcon(width, height, bitplanes, false))
			return false;
		RastPalette() rast;
		rast.Content = content;
		rast.ContentOffset = contentOffset + 8;
		rast.ContentLength = contentLength;
		rast.Colors = 1 << bitplanes;
		DecodeScaledBitplanes(unpacked, 0, width, height, bitplanes, false, rast);
		return true;
	}

	void DecodeHam!(byte[] unpacked, int width, int height, int bitplanes, MultiPalette! multiPalette)
	{
		int bytesPerLine = (width + 15 >> 4 << 1) * bitplanes;
		int holdBits = bitplanes > 6 ? 6 : 4;
		for (int y = 0; y < height; y++) {
			if (multiPalette != null)
				multiPalette.SetLinePalette(this, y);
			int rgb = ContentPalette[0];
			for (int x = 0; x < width; x++) {
				int c = GetBitplaneWordsPixel(unpacked, y * bytesPerLine, x, bitplanes);
				switch (c >> holdBits) {
				case 0:
					rgb = ContentPalette[c];
					break;
				case 1: // blue
					c = c << 8 - holdBits & 0xff;
					c |= c >> holdBits;
					rgb = (rgb & 0xffff00) | c;
					break;
				case 2: // red
					c = c << 8 - holdBits & 0xff;
					c |= c >> holdBits;
					rgb = (rgb & 0x00ffff) | c << 16;
					break;
				case 3: // green
					c = c << 8 - holdBits & 0xff;
					c |= c >> holdBits;
					rgb = (rgb & 0xff00ff) | c << 8;
					break;
				default:
					assert false;
				}
				SetScaledPixel(x, y, rgb);
			}
		}
	}

	int GetHameNibble(byte[] content, int contentOffset, int x)
	{
		int c = GetStLowPixel(content, contentOffset, x);
		// We could simply return c here, because the palette is set up
		// for the RGBI values in order, but to precisely emulate the way
		// the original hardware worked, lookup the color and convert it to RGBI.
		int rgb = ContentPalette[c];
		// Digital R, G, B are the highest bits of the components.
		// I is the lowest bit of the 4-bit Blue component.
		return (rgb >> 20 & 8) | (rgb >> 13 & 4) | (rgb >> 6 & 2) | (rgb >> 4 & 1);
	}

	int GetHameByte(byte[] content, int contentOffset, int x)
		=> GetHameNibble(content, contentOffset, x << 1) << 4 | GetHameNibble(content, contentOffset, (x << 1) + 1);

	bool IsHame(byte[] content, int contentOffset)
	{
		for (int i = 0; i < 7; i++) {
			const byte[7] magic = { 0xa2, 0xf5, 0x84, 0xdc, 0x6d, 0xb0, 0x7f };
			if (GetHameByte(content, contentOffset, i) != magic[i])
				return false;
		}
		switch (GetHameByte(content, contentOffset, 7)) {
		case 0x14: // REG
		case 0x18: // HAME
			return true;
		default:
			return false;
		}
	}

	void DecodeHame!(byte[] content, int width)
	{
		int[512] palette = 0;
		int[2] paletteLength = 0;
		bool hame = false;
		for (int y = 0; y < Height; y++) {
			int lineOffset = y * width;
			int paletteOffset = Resolution == RECOILResolution.AmigaHame2x1 && (y & 1) != 0 ? 256 : 0;
			if (IsHame(content, lineOffset)) {
				paletteOffset += paletteLength[paletteOffset >> 8];
				for (int c = 0; c < 64; c++) {
					int offset = 8 + c * 3;
					palette[paletteOffset + c] = GetHameByte(content, lineOffset, offset) << 16
						| GetHameByte(content, lineOffset, offset + 1) << 8
						| GetHameByte(content, lineOffset, offset + 2);
				}
				paletteLength[paletteOffset >> 8] = paletteLength[paletteOffset >> 8] + 64 & 0xff;
				hame = GetHameByte(content, lineOffset, 7) == 0x18;
				Pixels.Fill(0, y * Width, Width); // blank the special line
			}
			else {
				int paletteBank = 0;
				int rgb = 0;
				for (int x = 0; x < width; x++) {
					int c = GetHameByte(content, lineOffset, x);
					if (hame) {
						switch (c >> 6) {
						case 0:
							if (c < 60)
								rgb = palette[paletteOffset + paletteBank + c];
							else
								paletteBank = c - 60 << 6;
							break;
						case 1: // blue
							rgb = (c & 0x3f) << 2 | (rgb & 0xffff00);
							break;
						case 2: // red
							rgb = (c & 0x3f) << 18 | (rgb & 0x00ffff);
							break;
						default: // green
							rgb = (c & 0x3f) << 10 | (rgb & 0xff00ff);
							break;
						}
					}
					else
						rgb = palette[paletteOffset + c];
					SetScaledPixel(x, y, rgb);
				}
			}
		}
	}

	const int DctvMaxWidth = 2048; // not sure; ZXGIRL.DCTV is 1024 pixels wide

	int GetDctvValue(byte[] content, int contentOffset, int x, int bitplanes)
	{
		int c = GetBitplaneWordsPixel(content, contentOffset, x, bitplanes);
		int rgb = ContentPalette[c];
		// The value is 0I0R0B0G.
		// Digital R, G, B are the highest bits of the components.
		// I is the lowest bit of the 4-bit Blue component.
		return (rgb << 2 & 0x40) | (rgb >> 19 & 0x10) | (rgb >> 5 & 4) | (rgb >> 15 & 1);
	}

	bool IsDctv(byte[] content, int contentOffset, int bitplanes)
	{
		if (GetDctvValue(content, contentOffset, 0, bitplanes) >> 6 != 0)
			return false;
		int r = 0x7d;
		for (int x = 1; x < 256; x++) {
			if (GetDctvValue(content, contentOffset, x, bitplanes) >> 6 == (r & 1))
				return false;
			if ((r & 1) != 0)
				r ^= 0xc3 << 1;
			r >>= 1;
		}
		return true;
	}

	static int ClampByte(int x)
		=> x <= 0 ? 0 : x >= 255 ? 255 : x;

	bool DecodeDctv!(byte[] content, int width, int height, RECOILResolution resolution, int bitplanes)
	{
		if (!IsDctv(content, 0, bitplanes))
			return false;
		int interlace;
		int bytesPerLine = (width + 15 >> 4 << 1) * bitplanes;
		if (resolution == RECOILResolution.Amiga1x2) {
			interlace = 0;
			height--;
			resolution = RECOILResolution.AmigaDctv1x2;
		}
		else {
			if (!IsDctv(content, bytesPerLine, bitplanes))
				return false;
			interlace = 1;
			height -= 2;
			resolution = RECOILResolution.AmigaDctv1x1;
		}
		SetScaledSize(width, height, resolution);

		int contentOffset = bytesPerLine << interlace;
		int[DctvMaxWidth] chroma;
		for (int y = 0; y < height; y++) {
			int odd = y >> interlace & 1;
			int rgb = 0;
			int o = 0;
			int p = 0;
			for (int x = 0; x < width; x++) {
				if ((x & 1) == odd) {
					int n = x + 1 < width ?
						GetDctvValue(content, contentOffset, x, bitplanes) << 1
						| GetDctvValue(content, contentOffset, x + 1, bitplanes)
						: 0;

					int i = o + n >> 1;
					i = i <= 64 ? 0 : i >= 224 ? 255 : (i - 64) * 8 / 5;

					int u = n + p - (o << 1);
					if (u < 0)
						u += 3;
					u >>= 2;
					if ((x + 1 & 2) == 0)
						u = -u;
					int chromaOffset = (x & ~1) | (y & interlace);
					int v = y > interlace ? chroma[chromaOffset] : 0;
					chroma[chromaOffset] = u;
					if (odd == 0) {
						u = v;
						v = chroma[chromaOffset];
					}

					p = o;
					o = n;

					int r = i + v * 4655 / 2560;
					int b = i + u * 8286 / 2560;
					int g = i - (v * 2372 + u * 1616) / 2560;
					rgb = ClampByte(r) << 16 | ClampByte(g) << 8 | ClampByte(b);
				}
				SetScaledPixel(x, y, rgb);
			}
			contentOffset += bytesPerLine;
		}
		return true;
	}

	bool DecodeIffUnpacked!(byte[] unpacked, int width, int height, RECOILResolution resolution, int bitplanes, int colors, int camg, MultiPalette! multiPalette)
	{
		if (!SetScaledSize(width, height, resolution))
			return false;
		if (bitplanes <= 8) {
			if (colors == 0) {
				// grayscale
				colors = 1 << bitplanes;
				for (int c = 0; c < colors; c++)
					ContentPalette[c] = c * 255 / colors * 0x010101;
			}
			if ((camg & 0x800) != 0 || (bitplanes == 6 && colors == 16)) {
				// Amiga Hold-And-Modify
				DecodeHam(unpacked, width, height, bitplanes, multiPalette);
			}
			else if (width >= 400
				&& (resolution == RECOILResolution.Amiga1x2 || resolution == RECOILResolution.Amiga1x1)
				&& bitplanes == 4
				&& multiPalette == null
				&& IsHame(unpacked, 0)) {
				if (resolution == RECOILResolution.Amiga1x2)
					SetSize(width >> 1, height, RECOILResolution.AmigaHame1x1);
				else
					SetSize(width, height, RECOILResolution.AmigaHame2x1);
				DecodeHame(unpacked, width >> 1);
			}
			else if (width >= 256 && width <= DctvMaxWidth && height >= 3
				&& (resolution == RECOILResolution.Amiga1x2 || resolution == RECOILResolution.Amiga1x1)
				&& multiPalette == null
				&& DecodeDctv(unpacked, width, height, resolution, bitplanes)) {
				// DCTV complete
			}
			else {
				// palette
				DecodeScaledBitplanes(unpacked, 0, width, height, bitplanes, bitplanes == 6 && ((camg & 0x80) != 0 || colors == 32), multiPalette);
			}
		}
		else {
			// 24-bit or 32-bit true color
			int bytesPerBitplane = width + 15 >> 4 << 1;
			for (int y = 0; y < height; y++) {
				for (int x = 0; x < width; x++) {
					int offset = (y * bytesPerBitplane + (x >> 3 & ~1)) * bitplanes + (x >> 3 & 1);
					int c = GetBitplanePixel(unpacked, offset, x, 24, 2);
					// 0xBBGGRR -> 0xRRGGBB
					SetScaledPixel(x, y, (c & 0xff) << 16 | (c & 0xff00) | c >> 16);
				}
			}
		}
		return true;
	}

	bool DecodeIff!(byte[] content, int contentLength, RECOILResolution resolution)
	{
		if (contentLength < 56 || !IsStringAt(content, 0, "FORM"))
			return false;
		if (IsStringAt(content, 8, "DEEP") || IsStringAt(content, 8, "TVPP"))
			return DecodeDeep(content, contentLength);
		int contentOffset = 8;
		if (IsStringAt(content, 8, "DPSTDPAH") && Get32BigEndian(content, 16) == 24 && IsStringAt(content, 44, "FORM"))
			contentOffset = 52;
		else if (IsStringAt(content, 8, "ANIMFORM"))
			contentOffset = 20;
		IffType type;
		if (IsStringAt(content, contentOffset, "ILBM"))
			type = IffType.Ilbm;
		else if (IsStringAt(content, contentOffset, "PBM "))
			type = IffType.Pbm;
		else if (IsStringAt(content, contentOffset, "ACBM"))
			type = IffType.Acbm;
		else if (IsStringAt(content, contentOffset, "RGB8"))
			type = IffType.Rgb8;
		else if (IsStringAt(content, contentOffset, "RGBN"))
			type = IffType.Rgbn;
		else
			return false;
		contentOffset += 4;

		int width = 0;
		int height = 0;
		int bitplanes = 0;
		bool hasMask = false;
		int compression = 0;
		bool ocsPalette = false;
		int colors = 0;
		int camg = 0;
		CtblPalette() ctbl;
		ShamLacePalette() sham;
		PchgPalette() pchg;
		MultiPalette! multiPalette = null;
		while (contentOffset < contentLength - 7) {
			int chunkLength = Get32BigEndian(content, contentOffset + 4);
			int chunkEndOffset = contentOffset + 8 + chunkLength;
			if (chunkEndOffset > contentLength || chunkEndOffset < contentOffset + 8) {
				// handle BODY chunkLength bigger than actual,
				// e.g. incorrectly written as little-endian
				chunkEndOffset = contentLength;
				chunkLength = contentLength - contentOffset - 8;
			}
			if (IsStringAt(content, contentOffset, "BMHD") && chunkLength >= 16) {
				width = content[contentOffset + 8] << 8 | content[contentOffset + 9];
				height = content[contentOffset + 10] << 8 | content[contentOffset + 11];
				bitplanes = content[contentOffset + 16];
				hasMask = content[contentOffset + 17] == 1;
				compression = content[contentOffset + 18];
				switch (type) {
				case IffType.Pbm:
					if (bitplanes != 8 || compression > 1)
						return false;
					break;
				case IffType.Rgb8:
					if (bitplanes != 25 || compression != 4)
						return false;
					break;
				case IffType.Rgbn:
					if (bitplanes != 13 || compression != 4)
						return false;
					break;
				default:
					if (bitplanes == 0 || (bitplanes > 8 && bitplanes != 24 && bitplanes != 32)
					 || compression > 2)
						return false;
					break;
				}
				int pixelsCount = width * height;
				if (pixelsCount <= 0 || pixelsCount > MaxPixelsLength)
					return false;
				ocsPalette = content[contentOffset + 19] != 0x80;
				resolution = GetAmigaAspectRatio(content[contentOffset + 22], content[contentOffset + 23], resolution);
			}
			else if (IsStringAt(content, contentOffset, "CMAP")) {
				colors = chunkLength / 3;
				if (colors > 256)
					return false;
				if (colors > 32)
					ocsPalette = false;
				for (int c = 0; c < colors; c++) {
					ContentPalette[c] = GetR8G8B8Color(content, contentOffset + 8 + c * 3);
					if ((ContentPalette[c] & 0x0f0f0f) != 0)
						ocsPalette = false;
				}
				if (ocsPalette) {
					// 0xR0G0B0 -> 0xRRGGBB
					for (int c = 0; c < colors; c++)
						ContentPalette[c] |= ContentPalette[c] >> 4;
				}
				ContentPalette.Fill(0, colors, 256 - colors);
			}
			else if (IsStringAt(content, contentOffset, "CAMG") && chunkLength >= 4) {
				camg = Get32BigEndian(content, contentOffset + 8);
				resolution = GetCamgAspectRatio(camg, resolution);
			}
			else if ((IsStringAt(content, contentOffset, "CTBL") || IsStringAt(content, contentOffset, "BEAM")) && height > 0) {
				ctbl.Colors = (chunkLength >> 1) / height;
				if (ctbl.Colors <= 32) {
					ctbl.Content = content;
					ctbl.ContentOffset = contentOffset + 8;
					multiPalette = ctbl;
				}
			}
			else if (IsStringAt(content, contentOffset, "SHAM") && chunkLength >= 2
				&& content[contentOffset + 8] == 0 && content[contentOffset + 9] == 0) {
				if (chunkLength == 2 + (height << 5)) {
					ctbl.Content = content;
					ctbl.ContentOffset = contentOffset + 10;
					ctbl.Colors = 16;
					multiPalette = ctbl;
				}
				else if (chunkLength == 2 + (height >> 1 << 5)) {
					sham.Content = content;
					sham.ContentOffset = contentOffset + 10;
					multiPalette = sham;
				}
			}
			else if (IsStringAt(content, contentOffset, "PCHG")) {
				pchg.Content = content;
				pchg.ContentOffset = contentOffset + 8;
				pchg.ContentLength = chunkEndOffset;
				if (!pchg.Init())
					return false;
				multiPalette = pchg;
			}
			else if (IsStringAt(content, contentOffset, "BODY")) {
				if (width == 0)
					return false;
				if (compression == 4)
					return SetScaledSize(width, height, resolution)
						&& DecodeRgbn(content, contentOffset + 8, chunkEndOffset, width, height, type == IffType.Rgb8);
				int bytesPerLine = (width + 15 >> 4 << 1) * bitplanes;
				byte[]# unpacked;
				if (compression == 2) {
					unpacked = new byte[bytesPerLine * height];
					VdatStream() rle;
					rle.Content = content;
					rle.ContentOffset = contentOffset + 8;
					for (int bitplane = 0; bitplane < bitplanes; bitplane++) {
						if (rle.ContentOffset + 14 > chunkEndOffset || !IsStringAt(content, rle.ContentOffset, "VDAT"))
							return false;
						int nextContentOffset = rle.ContentOffset + 8 + Get32BigEndian(content, rle.ContentOffset + 4);
						if (nextContentOffset > chunkEndOffset)
							return false;
						rle.ValueOffset = rle.ContentLength = rle.ContentOffset + 8 + (content[rle.ContentOffset + 8] << 8) + content[rle.ContentOffset + 9];
						rle.ValueLength = nextContentOffset;
						rle.ContentOffset += 10;
						for (int x = bitplane << 1; x < bytesPerLine; x += bitplanes << 1) {
							int unpackedOffset = x;
							for (int y = 0; y < height; y++) {
								int b = rle.ReadRle();
								if (b < 0)
									return false;
								unpacked[unpackedOffset] = b >> 8;
								unpacked[unpackedOffset + 1] = b & 0xff;
								unpackedOffset += bytesPerLine;
							}
						}
						rle.ContentOffset = nextContentOffset;
					}
					resolution = resolution == RECOILResolution.Amiga1x2 ? RECOILResolution.St1x2 : RECOILResolution.St1x1;
				}
				else {
					PackBitsStream() rle;
					rle.Content = content;
					rle.ContentOffset = contentOffset + 8;
					rle.ContentLength = chunkEndOffset;

					if (type == IffType.Pbm) {
						if (colors == 0 || !SetScaledSize(width, height, resolution))
							return false;
						for (int y = 0; y < height; y++) {
							for (int x = 0; x < width; x++) {
								int b = compression == 0 ? rle.ReadByte() : rle.ReadRle();
								if (b < 0)
									return false;
								SetScaledPixel(x, y, ContentPalette[b]);
							}
							// handle padding to even bytes
							if ((width & 1) != 0 && (compression == 0 ? rle.ReadByte() : rle.ReadRle()) < 0)
								return false;
						}
						return true;
					}

					unpacked = new byte[bytesPerLine * height];
					if (!rle.UnpackBitplaneLines(unpacked, width, height, bitplanes, compression == 1, hasMask))
						return false;
				}

				if (bitplanes <= 8 && chunkEndOffset < contentLength - 8) {
					int nextChunkOffset = chunkEndOffset + 1 & ~1;
					if (IsStringAt(content, nextChunkOffset, "RAST"))
						return DecodeRast(content, nextChunkOffset, contentLength, unpacked, width, height, bitplanes);
					if (IsStringAt(content, chunkEndOffset, "RAST")) {
						// unaligned chunk, not conforming to the IFF format
						return DecodeRast(content, chunkEndOffset, contentLength, unpacked, width, height, bitplanes);
					}
				}

				return DecodeIffUnpacked(unpacked, width, height, resolution, bitplanes, colors, camg, multiPalette);
			}
			else if (IsStringAt(content, contentOffset, "ABIT")) {
				if (width == 0 || chunkLength != (width + 15 >> 4 << 1) * height * bitplanes)
					return false;
				contentOffset += 8;
				byte[]# unpacked = new byte[chunkLength];
				for (int bitplane = 0; bitplane < bitplanes; bitplane++) {
					for (int unpackedOffset = bitplane << 1; unpackedOffset < chunkLength; unpackedOffset += bitplanes << 1) {
						unpacked[unpackedOffset] = content[contentOffset++];
						unpacked[unpackedOffset + 1] = content[contentOffset++];
					}
				}
				return DecodeIffUnpacked(unpacked, width, height, resolution, bitplanes, colors, camg, multiPalette);
			}
			contentOffset = chunkEndOffset + 1 & ~1; // round up to even bytes
		}
		return false;
	}

	bool DecodeFlfFont!(byte[] content, int contentOffset, int contentLength, int columns, int rows, RECOILResolution resolution, int[] palette, int colors, int xMask, int cMask)
	{
		if (contentLength != contentOffset + columns * rows * 12)
			return false;
		int width = columns << 3;
		int height = rows << 3;
		SetSize(width, height, resolution);
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				int offset = contentOffset + ((y >> 3) * columns + (x >> 3)) * 12;
				int c = content[offset + (y & 7)] >> (x & xMask) & cMask;
				c = content[offset + 8 + c];
				if (c >= colors)
					return false;
				Pixels[y * width + x] = palette[c];
			}
		}
		return true;
	}

	bool DecodeFlf!(byte[] content, int contentLength)
	{
		if (contentLength < 20 || !IsStringAt(content, 0, "FLUFF64"))
			return false;
		switch (content[11]) {
		case 1:
			return DecodeFlfFont(content, 15, contentLength, 40, 25, RECOILResolution.C642x1, C64Palette, 16, 6, 3);
		case 4:
		case 5:
			return DecodeFlfFont(content, 18, contentLength, 40, 25, RECOILResolution.C642x1, C64Palette, 16, 6, 3);
		case 6:
			return DecodeFlfFont(content, 18, contentLength, 40, 25, RECOILResolution.C641x1, C64Palette, 16, 7, 1);
		case 7:
			int columns = content[0xf];
			int rows = content[0x10];
			// TODO: animation int screens = content[0x11];
			int length = columns * rows;
			return contentLength >= 0x2d + (length << 1)
				&& DecodePetScreen(content, 0x1d + length, 0x1d, 0xd, columns, rows);
		case 9:
			if (content[12] != 6)
				return false;
			const int[8] Vic20Palette = {
				0x000000,
				0xffffff,
				0x68372b,
				0x70a4b2,
				0x6f3d86,
				0x588d43,
				0x352879,
				0xb8c76f
			};
			return DecodeFlfFont(content, 20, contentLength, content[0x12], content[0x13], RECOILResolution.Vic202x1, Vic20Palette, 8, 6, 3);
		case 12:
			if (contentLength < 64020)
				return false;
			int colors = content[0xfa0d];
			if (contentLength != 0xfa0e + colors * 3)
				return false;
			DecodeR8G8B8Colors(content, 0xfa0e, colors, ContentPalette, 0);
			ContentPalette.Fill(0, colors, 256 - colors);
			SetSize(320, 200, RECOILResolution.Amiga1x1);
			DecodeBytes(content, 13);
			return true;
		default:
			return false;
		}
	}

	// Atari 8-bit formats.

	static int ParseAtari8ExecutableHeader(byte[] content, int contentOffset)
	{
		if (content[contentOffset] != 0xff || content[contentOffset + 1] != 0xff)
			return -1;
		int startAddress = content[contentOffset + 2] | content[contentOffset + 3] << 8;
		int endAddress = content[contentOffset + 4] | content[contentOffset + 5] << 8;
		return endAddress - startAddress + 1;
	}

	static int GetAtari8ExecutableOffset(byte[] content, int contentLength)
	{
		if (contentLength >= 7) {
			int blockLength = ParseAtari8ExecutableHeader(content, 0);
			if (blockLength > 0 && 6 + blockLength == contentLength)
				return 6;
		}
		return 0;
	}

	bool SetAtari8RawSize!(byte[] content, int contentLength, RECOILResolution resolution)
	{
		int contentOffset = GetAtari8ExecutableOffset(content, contentLength);
		int height = (contentLength - contentOffset) / 40;
		if (height == 0 || height > 240)
			return false;
		SetSize(320, height, resolution);
		return true;
	}

	byte[16] GtiaColors;

	void SetGtiaColor!(int reg, int value)
	{
		value &= 0xfe;
		switch (reg) {
		case 0:
		case 1:
		case 2:
		case 3:
			GtiaColors[reg] = value;
			break;
		case 4:
		case 5:
		case 6:
		case 7:
			GtiaColors[8 + reg] = GtiaColors[reg] = value;
			break;
		case 8:
			GtiaColors[11] = GtiaColors[10] = GtiaColors[9] = GtiaColors[8] = value;
			break;
		default:
			assert false;
		}
	}

	void SetPM123PF0123Bak!(byte[] content, int contentOffset)
	{
		for (int i = 0; i < 8; i++)
			SetGtiaColor(1 + i, content[contentOffset + i]);
	}

	void SetGtiaColors!(byte[] content, int contentOffset)
	{
		GtiaColors[0] = content[contentOffset] & 0xfe;
		SetPM123PF0123Bak(content, contentOffset + 1);
	}

	void SetPF21!(byte[] content, int contentOffset)
	{
		GtiaColors[6] = content[contentOffset] & 0xfe;
		GtiaColors[5] = content[contentOffset + 1] & 0xfe;
	}

	void SetXeOsDefaultColors!()
	{
		GtiaColors[8] = 0x00;
		GtiaColors[4] = 0x28;
		GtiaColors[5] = 0xca;
		GtiaColors[6] = 0x94;
		GtiaColors[7] = 0x46;
	}

	void SetGr15DefaultColors!()
	{
		GtiaColors[8] = 0x00;
		GtiaColors[4] = 0x04;
		GtiaColors[5] = 0x08;
		GtiaColors[6] = 0x0c;
	}

	void SetBakPF012!(byte[] content, int contentOffset, int contentStride)
	{
		for (int i = 0; i < 4; i++)
			GtiaColors[i == 0 ? 8 : 3 + i] = content[contentOffset + i * contentStride] & 0xfe;
	}

	void SetBakPF0123!(byte[] content, int contentOffset)
	{
		for (int i = 0; i < 5; i++)
			GtiaColors[i == 0 ? 8 : 3 + i] = content[contentOffset + i] & 0xfe;
	}

	void SetPF012Bak!(byte[] content, int contentOffset)
	{
		for (int i = 0; i < 4; i++)
			GtiaColors[i == 3 ? 8 : 4 + i] = content[contentOffset + i] & 0xfe;
	}

	void SetPF0123Bak!(byte[] content, int contentOffset)
	{
		for (int i = 0; i < 5; i++)
			GtiaColors[4 + i] = content[contentOffset + i] & 0xfe;
	}

	void SetPF0123Even!(byte[] content, int contentOffset)
	{
		for (int i = 0; i < 4; i++)
			GtiaColors[4 + i] = content[contentOffset + i * 2] & 0xfe;
	}

	void DecodeAtari8Gr8(byte[] content, int contentOffset, byte[]! frame, int frameOffset, int height)
	{
		byte[2] colors;
		colors[0] = GtiaColors[6];
		colors[1] = GtiaColors[6] & 0xf0 | GtiaColors[5] & 0x0e;
		frameOffset -= LeftSkip;
		for (int y = 0; y < height; y++) {
			int x;
			for (x = LeftSkip; x < Width; x++) {
				int c = content[contentOffset + (x >> 3)] >> (~x & 7) & 1;
				frame[frameOffset + x] = colors[c];
			}
			for ( ; x < Width + LeftSkip; x++)
				frame[frameOffset + x] = GtiaColors[8];
			contentOffset += Width + 7 >> 3;
			frameOffset += Width;
		}
	}

	void DecodeAtari8Gr15(byte[] content, int contentOffset, int contentStride, byte[]! frame, int frameOffset, int frameStride, int height)
	{
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < Width; x++) {
				int c = content[contentOffset + (x >> 3)] >> (~x & 6) & 3;
				frame[frameOffset + x] = GtiaColors[c == 0 ? 8 : c + 3];
			}
			contentOffset += contentStride;
			frameOffset += frameStride;
		}
	}

	void DecodeAtari8Gr7(byte[] content, int contentOffset, byte[]! frame, int frameOffset, int height)
	{
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < Width; x++) {
				int c = content[contentOffset + (x >> 3)] >> (~x & 6) & 3;
				frame[frameOffset + x + Width] = frame[frameOffset + x] = GtiaColors[c == 0 ? 8 : c + 3];
			}
			contentOffset += Width >> 3;
			frameOffset += Width << 1;
		}
	}

	void DecodeAtari8Gr3(byte[] content, byte[]! frame)
	{
		for (int y = 0; y < Height; y++) {
			for (int x = 0; x < Width; x++) {
				int c = content[(y >> 3) * (Width >> 5) + (x >> 5)] >> (~(x >> 2) & 6) & 3;
				frame[y * Width + x] = GtiaColors[c == 0 ? 8 : c + 3];
			}
		}
	}

	void DecodeAtari8Gr9(byte[] content, int contentOffset, int contentStride, byte[]! frame, int frameOffset, int frameStride, int width, int height)
	{
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				int i = x + LeftSkip;
				int c = i < 0 || i >= width ? 0 : content[contentOffset + (i >> 3)] >> (~i & 4) & 0x0f;
				frame[frameOffset + x] = GtiaColors[8] | c;
			}
			contentOffset += contentStride;
			frameOffset += frameStride;
		}
	}

	void DecodeAtari8Gr11(byte[] content, int contentOffset, byte[]! frame, int frameOffset, int frameStride, int height)
	{
		frameOffset -= LeftSkip;
		for (int y = 0; y < height; y++) {
			int x;
			for (x = LeftSkip; x < Width; x++) {
				int c = content[contentOffset + (x >> 3)] << (x & 4) & 0xf0;
				c = c == 0 ? GtiaColors[8] & 0xf0 : GtiaColors[8] | c;
				frame[frameOffset + x] = c;
			}
			for ( ; x < Width + LeftSkip; x++)
				frame[frameOffset + x] = GtiaColors[8] & 0xf0;
			contentOffset += Width >> 3;
			frameOffset += frameStride;
		}
	}

	void DecodeAtari8Gr10(byte[] content, int contentOffset, byte[]! frame, int frameOffset, int frameStride, int height)
	{
		frameOffset += 2 - LeftSkip;
		for (int y = 0; y < height; y++) {
			int x;
			for (x = LeftSkip - 2; x < 0; x++)
				frame[frameOffset + x] = GtiaColors[0];
			for ( ; x < Width + LeftSkip - 2; x++) {
				int c = content[contentOffset + (x >> 3)] >> (~x & 4) & 0x0f;
				frame[frameOffset + x] = GtiaColors[c];
			}
			contentOffset += Width >> 3;
			frameOffset += frameStride;
		}
	}

	void DecodeAtari8Gr11PalBlend(byte[] content, int contentOffset, int contentStride, byte[]! frame, int y)
	{
		for ( ; y < Height; y += 2) {
			int frameOffset = y * Width - LeftSkip;
			for (int x = LeftSkip; x < Width; x++) {
				int c = content[contentOffset + (x >> 3)] << (x & 4) & 0xf0;
				// Average intensity from neighboring lines. This doesn't happen on real hardware,
				// but avoids ugly aliasing with non-integer zoom factors.
				int i =
					((y == 0 ? 0 : frame[frameOffset - Width + x] & 0x0f) +
					(y == Height - 1 ? 0 : frame[frameOffset + Width + x] & 0x0f)) >> 1;
				frame[frameOffset + x] = c | i;
				// Copy hue to the next line emulating PAL color resolution reduction.
				// TODO: we should combine the two hues.
				if (y < Height - 1)
					frame[frameOffset + Width + x] = c | (frame[frameOffset + Width + x] & 0x0f);
			}
			frame.Fill(0, frameOffset + Width, LeftSkip);
			contentOffset += contentStride;
		}
	}

	static int ToAtari8Char(int ascii)
	{
		switch (ascii & 0x60) {
		case 0x00:
			return ascii + 0x40;
		case 0x20:
		case 0x40:
			return ascii - 0x20;
		default:
			return ascii;
		}
	}

	void DecodeAtari8Gr0Line(byte[] characters, int charactersOffset, byte[] font, int fontOffset, byte[]! frame, int frameOffset, int lines)
	{
		byte[2] colors;
		colors[0] = GtiaColors[6];
		colors[1] = GtiaColors[6] & 0xf0 | GtiaColors[5] & 0x0e;
		for (int y = 0; y < lines; y++) {
			for (int x = 0; x < Width; x++) {
				int ch = charactersOffset + (x >> 3);
				if (characters != null)
					ch = characters[ch];
				int b = font[fontOffset + ((ch & 0x7f) << 3) + (y & 7)];
				if (lines == 10) {
					// ANTIC 3 instead of ANTIC 2 / GR.0
					switch ((ch & 0x60) + y >> 1) {
					case 0x04:
					case 0x14:
					case 0x24:
					case 0x30:
						b = 0;
						break;
					default:
						break;
					}
				}
				if (ch >= 0x80)
					b ^= 0xff;
				frame[frameOffset + x] = colors[b >> (~x & 7) & 1];
			}
			frameOffset += Width;
		}
	}

	void DecodeAtari8Gr0!(byte[] characters, int charactersOffset, int charactersStride, byte[] font, int fontOffset, byte[]! frame)
	{
		GtiaColors[6] = 0x00;
		GtiaColors[5] = 0x0e;
		for (int y = 0; y < Height; y += 8)
			DecodeAtari8Gr0Line(characters, charactersOffset + (y >> 3) * charactersStride, font, fontOffset, frame, y * Width, 8);
	}

	void DecodeAtari8Gr1Line(byte[] content, int charactersOffset, byte[] font, int fontOffset, byte[]! frame, int frameOffset, int doubleLine)
	{
		for (int y = 0; y < 8 << doubleLine; y++) {
			for (int x = 0; x < Width; x++) {
				int ch = content[charactersOffset + (x >> 4)];
				int b = font[fontOffset + ((ch & 0x3f) << 3) + (y >> doubleLine)] >> (~(x >> 1) & 7) & 1;
				frame[frameOffset + x] = GtiaColors[b == 0 ? 8 : 4 + (ch >> 6)];
			}
			frameOffset += Width;
		}
	}

	void DecodeAtari8Gr12Line(byte[] characters, int charactersOffset, byte[] font, int fontOffset, byte[]! frame, int frameOffset, int doubleLine)
	{
		for (int y = 0; y < 8 << doubleLine; y++) {
			for (int x = 0; x < Width; x++) {
				int ch = x >> 3;
				if (characters != null)
					ch = characters[charactersOffset + ch];
				int c = font[fontOffset + ((ch & 0x7f) << 3) + (y >> doubleLine)] >> (~x & 6) & 3;
				int gr12Registers = ch >= 0x80 ? 0x7548 : 0x6548;
				frame[frameOffset + x] = GtiaColors[gr12Registers >> (c << 2) & 0xf];
			}
			frameOffset += Width;
		}
	}

	void DecodeAtari8Player(byte[] content, int contentOffset, int color, byte[]! frame, int frameOffset, int height, bool multi)
	{
		color &= 0xfe;
		for (int y = 0; y < height; y++) {
			int b = content[contentOffset + y];
			for (int x = 0; x < 8; x++) {
				int c = b >> (7 - x) & 1;
				if (c != 0)
					frame[frameOffset + x * 2 + 1] = frame[frameOffset + x * 2] = multi ? frame[frameOffset + x * 2] | color : color;
			}
			frameOffset += Width;
		}
	}

	bool ApplyAtari8Palette!(byte[] frame)
	{
		int pixelsLength = Width * Height;
		for (int i = 0; i < pixelsLength; i++)
			Pixels[i] = Atari8Palette[frame[i]];
		return true;
	}

	bool ApplyAtari8PaletteBlend!(byte[] frame1, byte[] frame2)
	{
		int pixelsLength = Width * Height;
		Frames = 2;
		for (int i = 0; i < pixelsLength; i++) {
			int rgb1 = Atari8Palette[frame1[i]];
			int rgb2 = Atari8Palette[frame2[i]];
			// This clever formula just computes the byte-by-byte averages.
			Pixels[i] = (rgb1 & rgb2) + ((rgb1 ^ rgb2) >> 1 & 0x7f7f7f);
		}
		return true;
	}

	bool ApplyAtari8PaletteBlend3!(byte[] frame1, byte[] frame2, byte[] frame3)
	{
		int pixelsLength = Width * Height;
		Frames = 3;
		for (int i = 0; i < pixelsLength; i++) {
			int rgb1 = Atari8Palette[frame1[i]];
			int rgb2 = Atari8Palette[frame2[i]];
			int rgb3 = Atari8Palette[frame3[i]];
			Pixels[i] = ((rgb1 >> 16) + (rgb2 >> 16) + (rgb3 >> 16)) / 3 << 16
				| ((rgb1 >> 8 & 0xff) + (rgb2 >> 8 & 0xff) + (rgb3 >> 8 & 0xff)) / 3 << 8
				| ((rgb1 & 0xff) + (rgb2 & 0xff) + (rgb3 & 0xff)) / 3;
		}
		return true;
	}

	bool DecodeGr8!(byte[] content, int contentLength)
	{
		if (!SetAtari8RawSize(content, contentLength, RECOILResolution.Xe1x1))
			return false;
		int contentOffset = GetAtari8ExecutableOffset(content, contentLength);
		if (contentLength == 7682) {
			// Atari Graphics Studio
			GtiaColors[6] = content[7680] & 0x0e;
			GtiaColors[5] = content[7681] & 0x0e;
		}
		else {
			GtiaColors[6] = 0x00;
			GtiaColors[5] = 0x0e;
		}
		byte[320 * 240] frame;
		DecodeAtari8Gr8(content, contentOffset, frame, 0, Height);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeDrg!(byte[] content, int contentLength)
		=> contentLength == 6400 && DecodeGr8(content, contentLength);

	bool DecodeGr8Raw!(byte[] content, int contentLength, int width, int height)
	{
		SetSize(width, height, RECOILResolution.Xe1x1);
		ContentPalette[0] = Atari8Palette[0x00];
		ContentPalette[1] = Atari8Palette[0x0e];
		return DecodeMono(content, 0, contentLength, false);
	}

	bool DecodePsf!(byte[] content, int contentLength)
	{
		if (contentLength < 572 || contentLength > 640)
			return false;
		SetSize(88, 52, RECOILResolution.Xe1x1);
		ContentPalette[0] = Atari8Palette[0x0e];
		ContentPalette[1] = Atari8Palette[0x00];
		DecodeBitplanes(content, 0, 11, 1, 0, 88, 52);
		return true;
	}

	bool DecodeMonoArt!(byte[] content, int contentLength)
	{
		// the origin, even the platform of the format is unknown
		if (contentLength < 4)
			return false;
		int columns = content[0] + 1;
		int height = content[1] + 1;
		// size limitations are unknown
		// several files have content[0] == 0x0b
		// GUY.ART has content[1] == 0x37
		if (columns > 30 || height > 64 || contentLength != 3 + columns * height)
			return false;
		SetSize(columns << 3, height, RECOILResolution.Xe1x1);
		ContentPalette[0] = Atari8Palette[0x0e];
		ContentPalette[1] = Atari8Palette[0x00];
		DecodeBitplanes(content, 2, columns, 1, 0, columns << 3, height);
		return true;
	}

	bool DecodeGhg!(byte[] content, int contentLength)
	{
		if (contentLength < 4)
			return false;
		int width = content[0] | content[1] << 8;
		int height = content[2];
		if (width == 0 || width > 320 || height == 0 || height > 200 || contentLength != 3 + (width + 7 >> 3) * height)
			return false;
		SetSize(width, height, RECOILResolution.Xe1x1);
		byte[320 * 200] frame;
		GtiaColors[6] = 0x0c;
		GtiaColors[5] = 0x02;
		DecodeAtari8Gr8(content, 3, frame, 0, height);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeCpr!(byte[] content, int contentLength)
	{
		if (contentLength < 2)
			return false;
		XeKoalaStream() rle;
		rle.Content = content;
		rle.ContentOffset = 1;
		rle.ContentLength = contentLength;
		if (!rle.UnpackRaw(content[0], 7680))
			return false;
		GtiaColors[6] = 0x0c;
		GtiaColors[5] = 0x00;
		SetSize(320, 192, RECOILResolution.Xe1x1);
		byte[320 * 192] frame;
		DecodeAtari8Gr8(rle.Unpacked, 0, frame, 0, 192);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeSg3!(byte[] content, int contentLength)
	{
		if (contentLength != 240)
			return false;
		SetSize(320, 192, RECOILResolution.Xe8x8);
		byte[320 * 192] frame;
		SetXeOsDefaultColors();
		DecodeAtari8Gr3(content, frame);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeGr3!(byte[] content, int contentLength)
	{
		if (contentLength != 244)
			return false;
		SetSize(320, 192, RECOILResolution.Xe8x8);
		byte[320 * 192] frame;
		SetBakPF012(content, 240, 1);
		DecodeAtari8Gr3(content, frame);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeDit!(byte[] content, int contentLength)
	{
		if (contentLength != 3845)
			return false;
		SetSize(320, 192, RECOILResolution.Xe2x2);
		byte[320 * 192] frame;
		SetPF0123Bak(content, 3840);
		DecodeAtari8Gr7(content, 0, frame, 0, 96);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeGr7!(byte[] content, int contentOffset, int contentSize)
	{
		if (contentSize > 4804 || contentSize % 40 != 4)
			return false;
		int height = contentSize / 40;
		SetSize(320, height * 2, RECOILResolution.Xe2x2);
		byte[320 * 240] frame;
		SetBakPF012(content, contentOffset + contentSize - 4, 1);
		DecodeAtari8Gr7(content, contentOffset, frame, 0, height);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeRys!(byte[] content, int contentLength)
	{
		if (contentLength != 3840)
			return false;
		SetSize(320, 192, RECOILResolution.Xe2x2);
		byte[320 * 192] frame;
		SetXeOsDefaultColors();
		DecodeAtari8Gr7(content, 0, frame, 0, 96);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeBkg!(byte[] content, int contentLength)
		=> contentLength == 3856 && DecodeGr7(content, 0, 3844);

	bool DecodeAtari8Artist!(byte[] content, int contentLength)
	{
		if (contentLength != 3206 || content[0] != 7)
			return false;
		SetSize(320, 160, RECOILResolution.Xe2x2);
		byte[320 * 160] frame;
		SetPF0123Bak(content, 1);
		DecodeAtari8Gr7(content, 6, frame, 0, 80);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeGr9!(byte[] content, int contentLength)
	{
		if (!SetAtari8RawSize(content, contentLength, RECOILResolution.Xe4x1))
			return false;
		GtiaColors[8] = 0x00;
		int contentOffset = GetAtari8ExecutableOffset(content, contentLength);
		byte[320 * 240] frame;
		DecodeAtari8Gr9(content, contentOffset, 40, frame, 0, 320, 320, Height);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeRap!(byte[] content, int contentLength)
	{
		if (contentLength != 7681)
			return false;
		GtiaColors[8] = content[7680] & 0xfe;
		SetSize(320, 192, RECOILResolution.Xe4x1);
		byte[320 * 192] frame;
		DecodeAtari8Gr9(content, 0, 40, frame, 0, 320, 320, 192);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeTxe!(byte[] content, int contentLength)
	{
		if (contentLength != 3840)
			return false;
		SetSize(320, 192, RECOILResolution.Xe4x2);
		byte[320 * 192] frame;
		GtiaColors[8] = 0x00;
		DecodeAtari8Gr9(content, 0, 40, frame, 320, 640, 320, 96);
		DecodeAtari8Gr9(content, 0, 40, frame, 0, 640, 320, 96); // the original program uses empty lines, but that doesn't look well scaled
		return ApplyAtari8Palette(frame);
	}

	bool DecodeGr9x4!(byte[] content, int contentOffset, int width, int height)
	{
		if (!SetSize(width, height, RECOILResolution.Xe4x4))
			return false;
		byte[]# frame = new byte[width * height];
		GtiaColors[8] = 0x00;
		for (int y = 0; y < 4; y++)
			DecodeAtari8Gr9(content, contentOffset, width >> 3, frame, y * width, width << 2, width, height >> 2);
		ApplyAtari8Palette(frame);
		return true;
	}

	bool DecodeZm4!(byte[] content, int contentLength)
		=> contentLength == 2048 && DecodeGr9x4(content, 0, 256, 256);

	bool DecodeGr9p!(byte[] content, int contentLength)
		=> contentLength == 2400 && DecodeGr9x4(content, 0, 320, 240);

	bool DecodeFge!(byte[] content, int contentLength)
		=> contentLength == 1286 && DecodeGr9x4(content, 6, 256, 160);

	bool Decode16x16x16!(byte[] content, int contentOffset, int colbak)
	{
		SetSize(64, 64, RECOILResolution.Xe4x4);
		for (int y = 0; y < 64; y++) {
			for (int x = 0; x < 64; x++) {
				int c = content[contentOffset + ((y & ~3) << 2) + (x >> 2)];
				if (c > 0xf)
					return false;
				Pixels[(y << 6) + x] = Atari8Palette[colbak | c];
			}
		}
		return true;
	}

	bool DecodeTx0!(byte[] content, int contentLength)
	{
		return contentLength == 257
			&& Decode16x16x16(content, 0, content[256] & 0xfe);
	}

	bool DecodeTxs!(byte[] content, int contentLength)
	{
		return contentLength == 262
			&& content[0] == 0xff && content[1] == 0xff
			&& content[2] == 0 && content[3] == 6
			&& content[4] == 0xff && content[5] == 6
			&& Decode16x16x16(content, 6, 0);
	}

	bool DecodeA4r!(byte[] content, int contentLength)
	{
		A4rStream() a4r;
		a4r.Content = content;
		a4r.ContentOffset = 0;
		a4r.ContentLength = contentLength;
		if (!a4r.UnpackA4r())
			return false;
		SetSize(320, 256, RECOILResolution.Xe4x1);
		byte[320 * 256] frame;
		GtiaColors[8] = 0x00;
		DecodeAtari8Gr9(a4r.Unpacked, 0x5010 - A4rStream.MinAddress, 40, frame, 0, 320, 320, 256);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeG11!(byte[] content, int contentLength)
	{
		if (!SetAtari8RawSize(content, contentLength, RECOILResolution.Xe4x1))
			return false;
		GtiaColors[8] = 0x06; // Atari operating system default
		int contentOffset = GetAtari8ExecutableOffset(content, contentLength);
		byte[320 * 240] frame;
		DecodeAtari8Gr11(content, contentOffset, frame, 0, 320, Height);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeG10!(byte[] content, int contentLength)
	{
		if (!SetAtari8RawSize(content, contentLength, RECOILResolution.Xe4x1))
			return false;
		int contentOffset = GetAtari8ExecutableOffset(content, contentLength);
		if ((contentLength - contentOffset) % 40 != 9)
			return false;
		LeftSkip = 2;
		SetGtiaColors(content, contentLength - 9);
		byte[320 * 240] frame;
		DecodeAtari8Gr10(content, contentOffset, frame, 0, 320, Height);
		return ApplyAtari8Palette(frame);
	}

#if FIVE_CHAR_EXT
	bool DecodeGr10p!(byte[] content, int contentLength)
	{
		if (contentLength != 2409)
			return false;
		SetSize(320, 240, RECOILResolution.Xe4x4);
		LeftSkip = 2;
		SetGtiaColors(content, 2400);
		byte[320 * 240] frame;
		for (int offset = 0; offset < 1280; offset += 320)
			DecodeAtari8Gr10(content, 0, frame, offset, 1280, 60);
		return ApplyAtari8Palette(frame);
	}
#endif

	bool DecodeG09!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 7680:
			return DecodeGr9(content, contentLength);
		case 15360:
			break;
		default:
			return false;
		}
		SetSize(640, 192, RECOILResolution.Xe4x1);
		GtiaColors[8] = 0x00;
		byte[640 * 192] frame;
		DecodeAtari8Gr9(content, 0, 40, frame, 0, 640, 320, 192);
		DecodeAtari8Gr9(content, 7680, 40, frame, 320, 640, 320, 192);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeSkp!(byte[] content, int contentLength)
	{
		if (contentLength != 7680)
			return false;
		GtiaColors[8] = 0x26;
		GtiaColors[4] = 0x28;
		GtiaColors[5] = 0x00;
		GtiaColors[6] = 0x0c;
		SetSize(320, 192, RECOILResolution.Xe2x1);
		byte[320 * 192] frame;
		DecodeAtari8Gr15(content, 0, 40, frame, 0, 320, 192);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeKss!(byte[] content, int contentLength)
	{
		if (contentLength != 6404)
			return false;
		SetSize(320, 160, RECOILResolution.Xe2x1);
		byte[320 * 160] frame;
		SetBakPF012(content, 6400, 1);
		DecodeAtari8Gr15(content, 0, 40, frame, 0, 320, 160);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeMic!(string filename, byte[] content, int contentLength)
	{
		if (contentLength == 15872) {
			// AtariGraphics file format.
			// AtariGraphics was included on a cartridge with the Atari Light Pen.
			// Its files have no default extension. I chose MIC, because it's similar.
			// The format is: 7680 bytes picture, followed by PF0,PF1,PF2,BAK colors,
			// followed by 508 bytes of padding, followed by 7680 bytes of fill map.
			// The fill map allows flood filling areas previously filled with a pattern.
			// It is a copy of the picture, except that areas filled with a pattern
			// are filled with a solid color here. Also, the fill map has inverted bits
			// compared to the picture, don't know why.
			contentLength = 7680;
			SetPF012Bak(content, 7680);
		}
		else {
			switch (contentLength % 40) {
			case 0:
			case 3: // I've found 7683-byte PIC files with three zero bytes at the end.
				SetGr15DefaultColors();
				break;
			case 4:
				SetBakPF012(content, contentLength - 4, 1);
				break;
			case 5:
				// Probably the last byte should be taken for COLBAK, not the previous one,
				// but I can't check that since the 7685-byte PIC files I found
				// have two zero bytes at the end.
				SetPF012Bak(content, contentLength - 5);
				break;
			default:
				return false;
			}
		}

		int height = contentLength / 40;
		if (height == 0 || height > 240)
			return false;
		SetSize(320, height, RECOILResolution.Xe2x1);
		byte[320 * 240] frame;
		if (height == 240) {
			byte[1280 + 1] col;
			switch (ReadCompanionFile(filename, "COL", "col", col, col.Length)) {
			case 1024:
			case 1280:
				for (int y = 0; y < 240; y++) {
					SetBakPF012(col, y, 256);
					DecodeAtari8Gr15(content, y * 40, 40, frame, y * 320, 320, 1);
				}
				return ApplyAtari8Palette(frame);
			default:
				break;
			}
		}
		DecodeAtari8Gr15(content, 0, 40, frame, 0, 320, height);
		return ApplyAtari8Palette(frame);
	}

	bool DecodePi8!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 7680:
			return DecodeMic(null, content, contentLength);
		case 7685:
			return DecodeGr8(content, contentLength);
		default:
			return false;
		}
	}

	bool DecodeHpm!(byte[] content, int contentLength)
	{
		// This format appears in Grass' Slideshow.
		byte[7684] unpacked;
		HpmStream() rle;
		rle.Content = content;
		rle.ContentOffset = 0;
		rle.ContentLength = contentLength;
		if (!rle.Unpack(unpacked, 0, 1, 7680))
			return false;

		// Colors aren't stored in the file.
		// Yvonne (http://atari8.sourceforge.net) sets colors according to filenames
		// (note that Grass' Slideshow and Yvonne were programmed by the same guy).
		// I have found out that the last byte of the file is COLPF0.
		// Other colors can be deduced from this one.
		// One exception is JORDAN.HPM, which I additionally match by length (3494 bytes).
		switch (rle.ReadByte()) {
		case 0x34: // ALIEN.HPM, DN.HPM, HPZ.HPM, RAPER.HPM, SALEM.HPM, ZWIEWKA.HPM, JORDAN.HPM
		case 0x35: // KOPALNY.HPM
			unpacked[7680] = 0x00;
			unpacked[7681] = 0x34;
			unpacked[7682] = contentLength == 3494 ? 0x38 : 0xc8;
			unpacked[7683] = contentLength == 3494 ? 0x3c : 0x7c;
			break;
		case 0x51: // CZASZKA.HPM
			unpacked[7680] = 0xa4;
			unpacked[7681] = 0x51;
			unpacked[7682] = 0xb9;
			unpacked[7683] = 0x7c;
			break;
		case 0xe4: // FSILY.HPM
			unpacked[7680] = 0x00;
			unpacked[7681] = 0xe4;
			unpacked[7682] = 0xc8;
			unpacked[7683] = 0xbe;
			break;
		case 0x04: // GIRL.HPM
			unpacked[7680] = 0x06;
			unpacked[7681] = 0x04;
			unpacked[7682] = 0x00;
			unpacked[7683] = 0x0a;
			break;
		case 0x30: // KISS.HPM
			unpacked[7680] = 0x0e;
			unpacked[7681] = 0x30;
			unpacked[7682] = 0xc7;
			unpacked[7683] = 0x7b;
			break;
		case 0x74: // STAR.HPM, VIVALDI.HPM
			unpacked[7680] = 0x00;
			unpacked[7681] = 0x74; // for STAR.HPM Yvonne uses 0x64, unlike the slideshow
			unpacked[7682] = 0x58;
			unpacked[7683] = 0x7e;
			break;
		// case 0x05: // FATHER.HPM
		default:
			unpacked[7680] = 0x00;
			unpacked[7681] = 0x04;
			unpacked[7682] = 0x08;
			unpacked[7683] = 0x0c;
			break;
		}

		return DecodeMic(null, unpacked, 7684);
	}

	bool DecodeCpi!(byte[] content, int contentLength)
	{
		byte[7936] unpacked;
		CpiStream() rle;
		rle.Content = content;
		rle.ContentOffset = 0;
		rle.ContentLength = contentLength;
		if (!rle.Unpack(unpacked, 0, 1, 7936))
			return false;
		SetSize(320, 192, RECOILResolution.Xe2x1);
		byte[320 * 192] frame;
		GtiaColors[8] = 0x00;
		GtiaColors[4] = 0x0c;
		GtiaColors[5] = 0x08;
		GtiaColors[6] = 0x04;
		DecodeAtari8Gr15(unpacked, 0, 40, frame, 0, 320, 192);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeWnd!(byte[] content, int contentLength)
	{
		if (contentLength != 3072)
			return false;
		int width = content[0] + 1;
		int contentStride = width + 3 >> 2;
		int height = content[1];
		if (contentStride > 40 || height == 0 || height > 192 || contentStride * height > 3070)
			return false;
		SetSize(width << 1, height, RECOILResolution.Xe2x1);
		byte[320 * 192] frame;
		// Blazing Paddles default colors
		GtiaColors[8] = 0x00;
		GtiaColors[4] = 0x46;
		GtiaColors[5] = 0x88;
		GtiaColors[6] = 0x0e;
		DecodeAtari8Gr15(content, 2, contentStride, frame, 0, width << 1, height);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAtari8Koala!(byte[] content, int contentOffset, int contentLength)
	{
		XeKoalaStream() rle;
		rle.Content = content;
		rle.ContentOffset = contentOffset;
		rle.ContentLength = contentLength;
		if (!rle.UnpackWrapped(7680))
			return false;
		SetSize(320, 192, RECOILResolution.Xe2x1);
		SetPF0123Bak(content, contentOffset + 13);
		byte[320 * 192] frame;
		DecodeAtari8Gr15(rle.Unpacked, 0, 40, frame, 0, 320, 192);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAtari8Pix!(byte[] content, int contentLength)
	{
		return contentLength >= 30 && content[0] == 0x1b && content[1] == 0x4d
			&& 4 + (content[2] | content[3] << 8) == contentLength
			&& DecodeAtari8Koala(content, 4, contentLength);
	}

	const int At800SpriteGap = 2;

	void DecodeAt800Players(byte[] content, byte[]! frame)
	{
		for (int i = 0; i < 4; i++)
			DecodeAtari8Player(content, 4 + i * 240, content[i], frame, i * (8 + At800SpriteGap) * 2, 240, false);
	}

	void DecodeAt800Missiles(byte[] content, int contentOffset, byte[]! frame, int frameOffset)
	{
		for (int y = 0; y < 240; y++) {
			for (int i = 0; i < 4; i++) {
				int b = content[contentOffset + y] >> (i << 1);
				int offset = frameOffset + i * (2 + At800SpriteGap) * 2;
				frame[offset + 1] = frame[offset] = (b & 2) == 0 ? 0 : content[i];
				frame[offset + 3] = frame[offset + 2] = (b & 1) == 0 ? 0 : content[i];
			}
			frameOffset += Width;
		}
	}

	bool DecodePla!(byte[] content, int contentLength)
	{
		if (contentLength != 241)
			return false;
		SetSize(16, 240, RECOILResolution.Xe2x1);
		byte[16 * 240] frame = 0;
		DecodeAtari8Player(content, 1, content[0], frame, 0, 240, false);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeMis!(byte[] content, int contentLength)
	{
		if (contentLength != 61 && contentLength != 241)
			return false;
		const int width = 2 * 2;
		SetSize(width, 240, RECOILResolution.Xe2x1);
		byte[width * 240] frame;
		for (int y = 0; y < 240; y++) {
			int b = content[1 + (y >> 2)] >> ((~y & 3) << 1);
			frame[y * width + 1] = frame[y * width] = (b & 2) == 0 ? 0 : content[0];
			frame[y * width + 3] = frame[y * width + 2] = (b & 1) == 0 ? 0 : content[0];
		}
		return ApplyAtari8Palette(frame);
	}

	bool Decode4pl!(byte[] content, int contentLength)
	{
		if (contentLength != 964)
			return false;
		const int width = 4 * (8 + At800SpriteGap) * 2;
		SetSize(width, 240, RECOILResolution.Xe2x1);
		byte[width * 240] frame = 0;
		DecodeAt800Players(content, frame);
		return ApplyAtari8Palette(frame);
	}

	bool Decode4mi!(byte[] content, int contentLength)
	{
		if (contentLength != 244)
			return false;
		const int width = 4 * (2 + At800SpriteGap) * 2;
		SetSize(width, 240, RECOILResolution.Xe2x1);
		byte[width * 240] frame = 0;
		DecodeAt800Missiles(content, 4, frame, 0);
		return ApplyAtari8Palette(frame);
	}

	bool Decode4pm!(byte[] content, int contentLength)
	{
		if (contentLength != 1204)
			return false;
		const int width = 4 * (8 + At800SpriteGap + 2 + At800SpriteGap) * 2;
		SetSize(width, 240, RECOILResolution.Xe2x1);
		byte[width * 240] frame = 0;
		DecodeAt800Players(content, frame);
		DecodeAt800Missiles(content, 964, frame, 4 * (8 + At800SpriteGap) * 2);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAtari8Spr!(byte[] content, int contentLength)
	{
		const int maxHeight = 40;
		if (contentLength < 3 || contentLength > 2 + maxHeight)
			return false;
		int height = content[0];
		if (2 + height != contentLength)
			return false;
		SetSize(16, height, RECOILResolution.Xe2x1);
		byte[16 * maxHeight] frame = 0;
		DecodeAtari8Player(content, 2, content[1], frame, 0, height, false);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeMsl!(byte[] content, int contentLength)
	{
		const int maxHeight = 34;
		if (contentLength < 3 || contentLength > 2 + maxHeight)
			return false;
		int height = content[0];
		if (2 + height != contentLength)
			return false;
		SetSize(4, height, RECOILResolution.Xe2x1);
		byte[4 * maxHeight] frame;
		for (int y = 0; y < height; y++) {
			int b = content[2 + y];
			if (b > 3)
				return false;
			frame[y * 4 + 1] = frame[y * 4] = (b & 2) == 0 ? 0 : content[1];
			frame[y * 4 + 3] = frame[y * 4 + 2] = (b & 1) == 0 ? 0 : content[1];
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeMpl!(byte[] content, int contentLength)
	{
		if (contentLength < 13)
			return false;
		const int maxWidth = 56;
		const int maxHeight = 40;
		int height = content[0];
		if (height == 0 || height > maxHeight)
			return false;
		int bitmapOffset = contentLength - (height << 2);
		if (bitmapOffset != 9 // old format
		 && bitmapOffset != 14) // new format; TODO: sizes, multicolor
			return false;
		int minX = 255;
		int maxX = 0;
		for (int i = 1; i < 5; i++) {
			int x = content[i];
			if (minX > x)
				minX = x;
			if (maxX < x)
				maxX = x;
		}
		if (maxX + 8 > maxWidth)
			return false;
		SetSize(maxX + 8 - minX << 1, height, RECOILResolution.Xe2x1);
		byte[maxWidth * 2 * maxHeight] frame = 0;
		for (int i = 3; i >= 0; i--)
			DecodeAtari8Player(content, bitmapOffset + i * height, content[5 + i], frame, content[1 + i] - minX << 1, height, false);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeLdm!(byte[] content, int contentLength)
	{
		if (contentLength < 281)
			return false;
		for (int i = 0; i < 21; i++)
			if (content[i] != "Ludek Maker data file"[i] + 128)
				return false;
		int shapes = content[0x18] - content[0x17];
		const int maxShapes = 100;
		const int height = 30;
		if (shapes <= 0 || shapes > maxShapes || contentLength < 281 + shapes * (4 * height))
			return false;
		// 8 shapes per row * (16 pixels + 4 pixels gap) = 160 pixels wide
		int rows = shapes + 7 >> 3;
		const int maxRows = maxShapes + 7 >> 3;
		const int horizontalGap = 4;
		const int verticalGap = 2;
		if (rows == 1)
			SetSize(shapes * (16 + horizontalGap << 1), height, RECOILResolution.Xe2x1);
		else
			SetSize(320, rows * (height + verticalGap) - verticalGap, RECOILResolution.Xe2x1);

		byte[320 * (maxRows * (height + verticalGap) - verticalGap)] frame = 0;
		for (int shape = 0; shape < shapes; shape++) {
			int contentOffset = 0x119 + shape * (4 * height);
			int frameOffset = (shape >> 3) * (height + verticalGap) * 320 + (shape & 7) * (16 + horizontalGap << 1);
			DecodeAtari8Player(content, contentOffset, content[0x15], frame, frameOffset, height, true);
			DecodeAtari8Player(content, contentOffset + height, content[0x16], frame, frameOffset, height, true);
			DecodeAtari8Player(content, contentOffset + 2 * height, content[0x15], frame, frameOffset + 16, height, true);
			DecodeAtari8Player(content, contentOffset + 3 * height, content[0x16], frame, frameOffset + 16, height, true);
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodePmd!(byte[] content, int contentLength)
	{
		if (contentLength < 3 + 4 + 4 + 1
		 || content[0] != 0xf0 || content[1] != 0xed || content[2] != 0xe4)
			return false;
		int sprites = content[7];
		int shapes = content[8] * content[9];
		int totalShapes = sprites * shapes;
		int height = content[10];
		if (sprites == 0 || sprites > 4
		 || shapes == 0 || shapes > 16 * 10
		 || height == 0 || height > 48
		 || 11 + totalShapes * height != contentLength)
			return false;

		// Unfortunately the information whether sprites are multi-color is not saved in the file.
		// We choose multi because there are three multi examples vs one mono.
		const bool multi = true;
		if (multi)
			totalShapes >>= 1;
		// 16 shapes per row * (8 pixels + 2 pixels gap) = 160 pixels wide
		int rows = totalShapes + 15 >> 4;
		const int horizontalGap = 2;
		const int verticalGap = 2;
		const int maxHeight = 560;
		if (rows == 1)
			SetSize(totalShapes * (8 + horizontalGap << 1), height, RECOILResolution.Xe2x1);
		else {
			int totalHeight = rows * (height + verticalGap) - verticalGap;
			if (totalHeight > maxHeight)
				return false;
			SetSize(320, totalHeight, RECOILResolution.Xe2x1);
		}

		byte[320 * maxHeight] frame = 0;
		for (int shape = 0; shape < totalShapes; shape++) {
			int frameOffset = (shape >> 4) * (height + verticalGap) * 320 + (shape & 0xf) * (8 + horizontalGap << 1);
			if (multi) {
				int spritePair = shape / shapes;
				int contentOffset = 11 + (spritePair * shapes + shape) * height;
				DecodeAtari8Player(content, contentOffset, content[3 + spritePair * 2], frame, frameOffset, height, true);
				DecodeAtari8Player(content, contentOffset + shapes * height, content[4 + spritePair * 2], frame, frameOffset, height, true);
			}
			else
				DecodeAtari8Player(content, 11 + shape * height, content[3 + shape / shapes], frame, frameOffset, height, false);
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeApl!(byte[] content, int contentLength)
	{
		if (contentLength != 1677
		 || content[0] != 0x9a || content[1] != 0xf8 || content[2] != 0x39 || content[3] != 0x21)
			return false;
		int frames = content[4];
		int height = content[5];
		int gap = content[6];
		if (frames == 0 || frames > 16 || height == 0 || height > 48 || gap > 8)
			return false;
		const int frameGap = 2;
		int frameWidth = 8 + gap + frameGap << 1;
		SetSize(frames * frameWidth, height, RECOILResolution.Xe2x1);
		byte[(16 + frameGap) * 2 * 16 * 48] frame = 0;

		for (int f = 0; f < frames; f++) {
			DecodeAtari8Player(content, 42 + f * 48, content[7 + f], frame, f * frameWidth, height, true);
			DecodeAtari8Player(content, 858 + f * 48, content[24 + f], frame, f * frameWidth + gap * 2, height, true);
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAtari8Hr!(byte[] content, int contentLength)
	{
		if (contentLength != 16384)
			return false;
		SetSize(256, 239, RECOILResolution.Xe1x1);
		GtiaColors[6] = 0x00;
		GtiaColors[5] = 0x0e;
		byte[256 * 239] frame1;
		DecodeAtari8Gr8(content, 0, frame1, 0, 239);
		byte[256 * 239] frame2;
		DecodeAtari8Gr8(content, 8192, frame2, 0, 239);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeMcppVariable!(byte[] content, int bitmapOffset, int colorsOffset, int width, int height)
	{
		if (!SetSize(width, height, RECOILResolution.Xe2x2))
			return false;
		byte[]# frame = new byte[width * height];
		SetPF012Bak(content, colorsOffset);
		DecodeAtari8Gr15(content, bitmapOffset, width >> 3, frame, 0, width << 1, height >> 1);
		SetPF012Bak(content, colorsOffset + 4);
		DecodeAtari8Gr15(content, bitmapOffset + (width * height >> 4), width >> 3, frame, width, width << 1, height >> 1);
		ApplyAtari8Palette(frame);
		return true;
	}

	bool DecodeMcpp!(byte[] content, int contentLength)
		=> contentLength == 8008 && DecodeMcppVariable(content, 0, 8000, 320, 200);

	bool DecodeIld!(byte[] content, int contentLength)
	{
		if (contentLength != 8195)
			return false;
		SetSize(256, 128, RECOILResolution.Xe2x1);
		GtiaColors[8] = 0x00;
		GtiaColors[4] = 0x06;
		GtiaColors[5] = 0x02;
		GtiaColors[6] = 0x0a;
		byte[256 * 128] frame1;
		DecodeAtari8Gr15(content, 0, 32, frame1, 0, 256, 128);
		byte[256 * 128] frame2;
		DecodeAtari8Gr15(content, 4096, 32, frame2, 0, 256, 128);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	// INP, ING
	bool DecodeInp!(byte[] content, int contentLength)
	{
		if (contentLength < 16004)
			return false;
		SetSize(320, 200, RECOILResolution.Xe2x1);
		SetBakPF012(content, 16000, 1);
		byte[320 * 200] frame1;
		DecodeAtari8Gr15(content, 0, 40, frame1, 0, 320, 200);
		byte[320 * 200] frame2;
		DecodeAtari8Gr15(content, 8000, 40, frame2, 0, 320, 200);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeIge!(byte[] content, int contentLength)
	{
		if (contentLength != 6160
		 || content[0] != 0xff || content[1] != 0xff
		 || content[2] != 0xf6 || content[3] != 0xa3 || content[4] != 0xff || content[5] != 0xbb
		 || content[6] != 0xff || content[7] != 0x5f)
			return false;
		SetSize(256, 96, RECOILResolution.Xe2x1);
		byte[256 * 96] frame1;
		SetBakPF012(content, 8, 1);
		DecodeAtari8Gr15(content, 0x10, 32, frame1, 0, 256, 96);
		byte[256 * 96] frame2;
		SetBakPF012(content, 12, 1);
		DecodeAtari8Gr15(content, 0xc10, 32, frame2, 0, 256, 96);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeInt!(byte[] content, int contentLength)
	{
		if (contentLength < 18
		 || !IsStringAt(content, 0, "INT95a")
		 || content[8] != 0x0f || content[9] != 0x2b)
			return false;
		int contentStride = content[6];
		int height = content[7];
		if (contentStride == 0 || contentStride > 320
		 || height == 0 || height > 239
		 || 18 + contentStride * height * 2 != contentLength)
			return false;
		int width = contentStride << 3;
		SetSize(width, height, RECOILResolution.Xe2x1);
		byte[320 * 239] frame1;
		SetBakPF012(content, 10, 1);
		DecodeAtari8Gr15(content, 18, contentStride, frame1, 0, width, height);
		byte[320 * 239] frame2;
		SetBakPF012(content, 14, 1);
		DecodeAtari8Gr15(content, 18 + contentStride * height, contentStride, frame2, 0, width, height);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeIst!(byte[] content, int contentLength)
	{
		if (contentLength != 17184)
			return false;
		SetSize(320, 200, RECOILResolution.Xe2x1);
		byte[320 * 200] frame1;
		byte[320 * 200] frame2;
		for (int y = 0; y < 200; y++) {
			SetBakPF012(content, 0x4000 + y, 200);
			DecodeAtari8Gr15(content, 16 + y * 40, 0, frame1, y * 320, 320, 1);
			DecodeAtari8Gr15(content, 0x2010 + y * 40, 0, frame2, y * 320, 320, 1);
		}
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeGr15Blend!(byte[] content, int bitmapOffset, int colorsOffset, int height)
	{
		SetSize(320, height, RECOILResolution.Xe2x1);
		byte[320 * 200] frame1;
		SetPF012Bak(content, colorsOffset);
		DecodeAtari8Gr15(content, bitmapOffset, 80, frame1, 0, 640, height >> 1);
		SetPF012Bak(content, colorsOffset + 4);
		DecodeAtari8Gr15(content, bitmapOffset + 40, 80, frame1, 320, 640, height >> 1);
		byte[320 * 200] frame2;
		DecodeAtari8Gr15(content, bitmapOffset + height * 40, 80, frame2, 0, 640, height >> 1);
		SetPF012Bak(content, colorsOffset);
		DecodeAtari8Gr15(content, bitmapOffset + height * 40 + 40, 80, frame2, 320, 640, height >> 1);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeMcp!(byte[] content, int contentLength)
		=> contentLength == 16008
			&& DecodeGr15Blend(content, 0, 16000, 200);

	bool DecodeAtari8Raw!(byte[] content, int contentLength)
		=> contentLength == 15372 && IsStringAt(content, 0, "XLPB")
			&& DecodeGr15Blend(content, 4, 0x3c04, 192);

	bool DecodeXlp!(byte[] content, int contentLength)
	{
		XlpStream() rle;
		rle.Content = content;
		rle.ContentLength = contentLength;
		byte[16000] unpacked;
		int height;
		int colorsOffset;
		if (contentLength >= 10 && IsStringAt(content, 0, "XLPC")) {
			// ignore errors: STAIRS.XLP included with XL-Paint is missing last two image bytes
			unpacked.Fill(0);
			rle.ContentOffset = 8;
			rle.UnpackColumns(unpacked, 0, 40, 2 * 40 * 192);
			height = 192;
			colorsOffset = 4;
		}
		else {
			// no header, so better check for errors
			rle.ContentOffset = 4;
			if (rle.UnpackColumns(unpacked, 0, 40, 2 * 40 * 200))
				height = 200;
			else {
				rle.ContentOffset = 4;
				if (rle.UnpackColumns(unpacked, 0, 40, 2 * 40 * 192))
					height = 192;
				else
					return false;
			}
			colorsOffset = 0;
		}

		SetSize(320, height, RECOILResolution.Xe2x1);
		SetPF012Bak(content, colorsOffset);
		byte[320 * 200] frame1;
		DecodeAtari8Gr15(unpacked, 0, 40, frame1, 0, 320, height);
		byte[320 * 200] frame2;
		DecodeAtari8Gr15(unpacked, height * 40, 40, frame2, 0, 320, height);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeAtari8Max!(byte[] content, int contentLength)
	{
		if (contentLength < 4 + 9 * 192 || !IsStringAt(content, 0, "XLPM"))
			return false;
		XlpStream() rle;
		rle.Content = content;
		rle.ContentOffset = 4 + 9 * 192;
		rle.ContentLength = contentLength;
		byte[15360] unpacked;
		if (!rle.UnpackColumns(unpacked, 0, 40, 15360))
			return false;

		SetSize(320, 192, RECOILResolution.Xe2x1);
		byte[320 * 192] frame1;
		byte[320 * 192] frame2;
		for (int y = 0; y < 192; y++) {
			SetBakPF012(content, 4 + 4 * 192 + y, 192);
			DecodeAtari8Gr15(unpacked, y * 40, 40, frame1, y * 320, 320, 1);
			SetBakPF012(content, 4 + y, 192);
			DecodeAtari8Gr15(unpacked, 7680 + y * 40, 40, frame2, y * 320, 320, 1);
		}
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeHr2!(byte[] content, int contentLength)
	{
		if (contentLength != 16006)
			return false;
		SetSize(320, 200, RECOILResolution.Xe1x1);
		byte[320 * 200] frame1;
		SetPF21(content, 16000);
		DecodeAtari8Gr8(content, 0, frame1, 0, 200);
		byte[320 * 200] frame2;
		SetBakPF012(content, 16002, 1);
		DecodeAtari8Gr15(content, 8000, 40, frame2, 0, 320, 200);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeLum!(string filename, byte[] content, int contentLength)
	{
		if (contentLength != 4766)
			return false;
		SetSize(320, 238, RECOILResolution.Xe4x2);
		byte[320 * 238] frame;
		GtiaColors[8] = 0x00;
		DecodeAtari8Gr9(content, 6, 40, frame, 320, 640, 320, 119);
		byte[4766 + 1] col;
		if (ReadCompanionFile(filename, "COL", "col", col, col.Length) == 4766) {
			// LUM file combined with COL file gives 256-color Technicolor Dream
			DecodeAtari8Gr11PalBlend(col, 6, 40, frame, 0);
		}
		else {
			// problem with COL, at least show the grayscale
			DecodeAtari8Gr9(content, 6, 40, frame, 0, 640, 320, 119);
		}
		return ApplyAtari8Palette(frame);
	}

	// APC, PLM
	bool DecodeApc!(byte[] content, int contentLength)
	{
		if (contentLength != 7680 && contentLength != 7720)
			return false;
		SetSize(320, 192, RECOILResolution.Xe4x2);
		byte[320 * 192] frame;
		GtiaColors[8] = 0x00;
		DecodeAtari8Gr9(content, 40, 80, frame, 320, 640, 320, 96);
		DecodeAtari8Gr11PalBlend(content, 0, 80, frame, 0);
		return ApplyAtari8Palette(frame);
	}

	// 256, AP2
	bool Decode256!(byte[] content, int contentLength)
	{
		if (contentLength != 7680 && contentLength != 7684)
			return false;
		SetSize(320, 192, RECOILResolution.Xe4x2);
		byte[320 * 192] frame;
		GtiaColors[8] = 0x00;
		DecodeAtari8Gr9(content, 3840, 40, frame, 320, 640, 320, 96);
		DecodeAtari8Gr11PalBlend(content, 0, 40, frame, 0);
		return ApplyAtari8Palette(frame);
	}

	// MGA
	bool DecodeMga!(byte[] content, int contentLength)
	{
		if (contentLength != 7856)
			return false;
		SetSize(320, 192, RECOILResolution.Xe4x2);
		byte[320 * 192] frame;
		GtiaColors[8] = 0x00;
		DecodeAtari8Gr9(content, 0, 80, frame, 320, 640, 320, 96);
		DecodeAtari8Gr11PalBlend(content, 40, 80, frame, 0);
		// 40 bytes of text in screen codes at 0x1e00
		// the trailing 136 bytes are unknown
		return ApplyAtari8Palette(frame);
	}

	// AP3, APV, DGP, ESC, ILC, PZM
	bool DecodeAp3!(byte[] content, int contentLength)
	{
		int gr11Offset;
		switch (contentLength) {
		case 15360:
		case 15362:
			gr11Offset = 7680;
			break;
		case 15872:
			gr11Offset = 8192;
			break;
		default:
			return false;
		}
		SetSize(320, 192, RECOILResolution.Xe4x1);
		GtiaColors[8] = 0x00;
		byte[320 * 192] frame1;
		DecodeAtari8Gr9(content, 0, 80, frame1, 0, 640, 320, 96);
		DecodeAtari8Gr11PalBlend(content, gr11Offset + 40, 80, frame1, 1);
		byte[320 * 192] frame2;
		DecodeAtari8Gr9(content, 40, 80, frame2, 320, 640, 320, 96);
		DecodeAtari8Gr11PalBlend(content, gr11Offset, 80, frame2, 0);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeBgp!(byte[] content, int contentLength)
	{
		if (contentLength < 0x27 + (2 + 239 * 40) * 2
		 || !IsStringAt(content, 0, "BUGBITER_APAC239I_PICTURE_V1.0")
		 || content[0x1e] != 0xff || content[0x1f] != 80 || content[0x20] != 239)
			return false;
		int textLength = content[0x25] + (content[0x26] << 8);
		// 0x2558 == 239 * 40
		if (contentLength != 0x27 + (2 + 239 * 40) * 2 + textLength
		 || content[0x27 + textLength] != 0x58 || content[0x28 + textLength] != 0x25
		 || content[0x27 + 2 + 239 * 40 + textLength] != 0x58 || content[0x28 + 2 + 239 * 40 + textLength] != 0x25)
			return false;
		SetSize(320, 239, RECOILResolution.Xe4x1);
		GtiaColors[8] = 0x00;
		byte[320 * 239] frame1;
		DecodeAtari8Gr9(content, 0x29 + textLength, 80, frame1, 0, 640, 320, 120);
		DecodeAtari8Gr11PalBlend(content, 0x29 + 239 * 40 + 2 + 40 + textLength, 80, frame1, 1);
		byte[320 * 239] frame2;
		DecodeAtari8Gr9(content, 0x29 + 40 + textLength, 80, frame2, 320, 640, 320, 119);
		DecodeAtari8Gr11PalBlend(content, 0x29 + 239 * 40 + 2 + textLength, 80, frame2, 0);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeHip!(byte[] content, int contentLength)
	{
		if (contentLength < 80)
			return false;
		const byte[] gr10Colors = { 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e };
		byte[320 * 240] frame1;
		byte[320 * 240] frame2;
		int frameLength = ParseAtari8ExecutableHeader(content, 0);
		if (frameLength > 0
		 && frameLength % 40 == 0
		 && 12 + frameLength * 2 == contentLength
		 && ParseAtari8ExecutableHeader(content, 6 + frameLength) == frameLength) {
			// HIP image with binary file headers.
			int height = frameLength / 40;
			if (height > 240)
				return false;
			SetSize(320, height, RECOILResolution.Xe2x1);
			LeftSkip = 1;
			SetGtiaColors(gr10Colors, 0);
			DecodeAtari8Gr10(content, 6, frame1, 0, 320, height);
			GtiaColors[8] = 0x00;
			DecodeAtari8Gr9(content, 12 + frameLength, 40, frame2, 0, 320, 320, height);
		}
		else {
			// HIP image with GR. 10 palette.
			int height = contentLength / 80;
			if (height > 240)
				return false;
			SetSize(320, height, RECOILResolution.Xe2x1);
			LeftSkip = 1;
			GtiaColors[8] = 0x00;
			DecodeAtari8Gr9(content, 0, 40, frame1, 0, 320, 320, height);
			if (contentLength % 80 == 9)
				SetGtiaColors(content, contentLength - 9);
			else
				SetGtiaColors(gr10Colors, 0);
			DecodeAtari8Gr10(content, height * 40, frame2, 0, 320, height);
		}
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeG9s!(byte[] content, int contentLength)
	{
		byte[7680] unpacked;
		SfdnStream() s;
		s.Content = content;
		s.ContentLength = contentLength;
		return s.Unpack(unpacked, unpacked.Length)
			&& DecodeGr9(unpacked, unpacked.Length);
	}

	bool DecodeIns!(byte[] content, int contentLength)
	{
		byte[16004] unpacked;
		SfdnStream() s;
		s.Content = content;
		s.ContentLength = contentLength;
		return s.Unpack(unpacked, unpacked.Length)
			&& DecodeInp(unpacked, unpacked.Length);
	}

	bool DecodePls!(byte[] content, int contentLength)
	{
		byte[7680] unpacked;
		SfdnStream() s;
		s.Content = content;
		s.ContentLength = contentLength;
		return s.Unpack(unpacked, unpacked.Length)
			&& DecodeApc(unpacked, unpacked.Length);
	}

	bool DecodeAps!(byte[] content, int contentLength)
	{
		byte[7720] unpacked;
		SfdnStream() s;
		s.Content = content;
		s.ContentLength = contentLength;
		return s.Unpack(unpacked, unpacked.Length)
			&& DecodeApc(unpacked, unpacked.Length);
	}

	bool DecodeIls!(byte[] content, int contentLength)
	{
		byte[15360] unpacked;
		SfdnStream() s;
		s.Content = content;
		s.ContentLength = contentLength;
		return s.Unpack(unpacked, unpacked.Length)
			&& DecodeAp3(unpacked, unpacked.Length);
	}

	bool DecodeApp!(byte[] content, int contentLength)
	{
		byte[15872] unpacked;
		SfdnStream() s;
		s.Content = content;
		s.ContentLength = contentLength;
		return s.Unpack(unpacked, unpacked.Length)
			&& DecodeAp3(unpacked, unpacked.Length);
	}

	bool DecodeHps!(byte[] content, int contentLength)
	{
		byte[16009] unpacked;
		SfdnStream() s;
		s.Content = content;
		s.ContentLength = contentLength;
		return s.Unpack(unpacked, unpacked.Length)
			&& DecodeHip(unpacked, unpacked.Length);
	}

	bool DecodeTip!(byte[] content, int contentLength)
	{
		if (contentLength < 129
		 || content[0] != 'T' || content[1] != 'I' || content[2] != 'P'
		 || content[3] != 1 || content[4] != 0)
			return false;
		int width = content[5];
		int height = content[6];
		if (width > 160 || (width & 3) != 0 || height > 119)
			return false;
		int contentStride = width >> 2;
		int frameLength = content[7] | content[8] << 8;
		if (frameLength != contentStride * height
		 || contentLength != 9 + 3 * frameLength)
			return false;

		SetSize(width << 1, height << 1, RECOILResolution.Xe2x2);
		LeftSkip = 1;
		const byte[] colors = { 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x00 };
		SetGtiaColors(colors, 0);
		byte[320 * 238] frame1;
		DecodeAtari8Gr9(content, 9, contentStride, frame1, width << 1, width << 2, width << 1, height);
		DecodeAtari8Gr11PalBlend(content, 9 + 2 * frameLength, contentStride, frame1, 0);
		byte[320 * 238] frame2;
		DecodeAtari8Gr10(content, 9 + frameLength, frame2, width << 1, width << 2, height);
		DecodeAtari8Gr11PalBlend(content, 9 + 2 * frameLength, contentStride, frame2, 0);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeCin!(byte[] content, int contentLength)
	{
		int height;
		switch (contentLength) {
		case 15360:
			SetGr15DefaultColors();
			height = 192;
			break;
		case 16004:
			SetBakPF012(content, 16000, 1);
			height = 200;
			break;
		case 16384:
			height = 192;
			break;
		default:
			return false;
		}
		SetSize(320, height, RECOILResolution.Xe2x1);
		byte[320 * 200] frame1;
		byte[320 * 200] frame2;
		for (int y = 0; y < height; y++) {
			if (contentLength == 16384)
				SetBakPF012(content, 0x3c00 + y, 256);
			DecodeAtari8Gr15(content, y * 40, 40, (y & 1) == 0 ? frame1 : frame2, y * 320, 320, 1);
		}
		DecodeAtari8Gr11PalBlend(content, 40 * height + 40, 80, frame1, 1);
		DecodeAtari8Gr11PalBlend(content, 40 * height, 80, frame2, 0);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeCci!(byte[] content, int contentLength)
	{
		if (contentLength < 24 || !IsStringAt(content, 0, "CIN 1.2 "))
			return false;
		CciStream() rle;
		rle.Content = content;
		rle.ContentOffset = 8;
		rle.ContentLength = contentLength;
		byte[16384] unpacked;
		if (!rle.UnpackGr15(unpacked, 0)
		 || !rle.UnpackGr15(unpacked, 40))
			return false;
		rle.ContentOffset += 4;
		rle.RepeatCount = 0; // DRACONUS.CCI
		if (!rle.UnpackColumns(unpacked, 7680, 40, 15360))
			return false;
		rle.ContentOffset += 4;
		rle.RepeatCount = 0;
		return rle.Unpack(unpacked, 15360, 1, 16384)
			&& DecodeCin(unpacked, 16384);
	}

	bool DecodeAgs!(byte[] content, int contentLength)
	{
		if (contentLength < 17 || content[0] != 'A' || content[1] != 'G' || content[2] != 'S')
			return false;
		int width = content[4];
		int height = content[5] | content[6] << 8;
		if (contentLength != 16 + (width * height << 1))
			return false;
		switch (content[3]) {
		case 0x0b:
			return DecodeMcppVariable(content, 16, 7, width << 3, height << 1);
		case 0x13:
			return DecodeGr9x4(content, 16, width << 3, height << 2);
		default:
			return false;
		}
	}

	bool UnpackRip(byte[] content, int contentOffset, int contentLength, byte[]! unpacked, int unpackedLength)
	{
		// "PCK" header (16 bytes)
		if (contentOffset + 304 > contentLength || !IsStringAt(content, contentOffset, "PCK"))
			return false;

		// 288 bytes Shannon-Fano bit lengths
		FanoTree() lengthTree;
		lengthTree.Create(content, contentOffset + 16, 64);
		FanoTree() distanceTree;
		distanceTree.Create(content, contentOffset + 16 + 32, 256);
		FanoTree() literalTree;
		literalTree.Create(content, contentOffset + 16 + 32 + 128, 256);

		// LZ77
		BitStream() bitStream;
		bitStream.Content = content;
		bitStream.ContentOffset = contentOffset + 16 + 288;
		bitStream.ContentLength = contentLength;
		for (int unpackedOffset = 0; unpackedOffset < unpackedLength; ) {
			switch (bitStream.ReadBit()) {
			case 0:
				int literal = literalTree.ReadCode(bitStream);
				if (literal < 0)
					return false;
				unpacked[unpackedOffset++] = literal;
				break;
			case 1:
				int distance = distanceTree.ReadCode(bitStream);
				if (distance < 0)
					return false;
				distance += 2;
				int count = lengthTree.ReadCode(bitStream);
				if (count < 0)
					return false;
				count += 2;
				if (count > unpackedLength - unpackedOffset)
					count = unpackedLength - unpackedOffset;
				if (!CopyPrevious(unpacked, unpackedOffset, distance, count))
					return false;
				unpackedOffset += count;
				if (unpackedOffset >= unpackedLength)
					return true;
				break;
			default:
				return false;
			}
		}
		return true;
	}

	bool DecodeRip!(byte[] content, int contentLength)
	{
		if (contentLength < 34
		 || content[0] != 'R' || content[1] != 'I' || content[2] != 'P'
		 || content[18] != 'T' || content[19] != ':')
			return false;
		int headerLength = content[11] | content[12] << 8;
		int contentStride = content[13];
		int height = content[15];
		int textLength = content[17];
		if (headerLength >= contentLength
		 || contentStride == 0 || contentStride > 80 || (contentStride & 1) != 0 || height == 0 || height > 239
		 || 33 + textLength >= contentLength
		 || content[20 + textLength] != 9
		 || !IsStringAt(content, 21 + textLength, "CM:"))
			return false;

		if (content[7] < 0x10)
			contentStride >>= 1;
		int unpackedLength = contentStride * height;
		if (content[7] == 0x30)
			unpackedLength += (height + 1 >> 1) << 3; // Multi RIP: 8 bytes of palette per two lines
		byte[84 * 239] unpacked = 0;
		switch (content[9]) {
		case 0:
			if (headerLength + unpackedLength > contentLength)
				return false;
			content.CopyTo(headerLength, unpacked, 0, unpackedLength);
			break;
		case 1:
			// Ignore errors, because many RIP files included with Atari Interlace Studio are corrupted.
			UnpackRip(content, headerLength, contentLength, unpacked, unpackedLength);
			break;
		default:
			return false;
		}

		SetGtiaColors(content, 24 + textLength);
		contentStride = content[13] >> 1;
		int width = contentStride << 3;
		byte[320 * 239] frame1;
		byte[320 * 239] frame2;
		switch (content[7]) {
		case 0x0e: // GR. 15
			SetSize(width, height, RECOILResolution.Xe2x1);
			DecodeAtari8Gr15(unpacked, 0, contentStride, frame1, 0, width, height);
			return ApplyAtari8Palette(frame1);
		case 0x0f: // GR. 8
			SetSize(width, height, RECOILResolution.Xe1x1);
			DecodeAtari8Gr8(unpacked, 0, frame1, 0, height);
			return ApplyAtari8Palette(frame1);
		case 0x4f: // GR. 9
			SetSize(width, height, RECOILResolution.Xe4x1);
			DecodeAtari8Gr9(unpacked, 0, contentStride, frame1, 0, width, width, height);
			return ApplyAtari8Palette(frame1);
		case 0x8f: // GR. 10
			SetSize(width, height, RECOILResolution.Xe4x1);
			LeftSkip = 2;
			DecodeAtari8Gr10(unpacked, 0, frame1, 0, width, height);
			return ApplyAtari8Palette(frame1);
		case 0xcf: // GR. 11
			SetSize(width, height, RECOILResolution.Xe4x1);
			DecodeAtari8Gr11(content, 0, frame1, 0, width, height);
			return ApplyAtari8Palette(frame1);
		case 0x1e: // GR. 15 blend with one palette
			SetSize(width, height, RECOILResolution.Xe2x1);
			DecodeAtari8Gr15(unpacked, 0, contentStride, frame1, 0, width, height);
			DecodeAtari8Gr15(unpacked, height * contentStride, contentStride, frame2, 0, width, height);
			return ApplyAtari8PaletteBlend(frame1, frame2);
		case 0x10: // GR. 15 blend with different palettes
			SetSize(width, height, RECOILResolution.Xe2x1);
			SetBakPF012(content, 28 + textLength, 1);
			DecodeAtari8Gr15(unpacked, 0, contentStride << 1, frame1, 0, width << 1, height >> 1);
			SetBakPF012(content, 24 + textLength, 1);
			DecodeAtari8Gr15(unpacked, contentStride, contentStride << 1, frame1, width, width << 1, height >> 1);
			DecodeAtari8Gr15(unpacked, height * contentStride, contentStride << 1, frame2, 0, width << 1, height >> 1);
			SetBakPF012(content, 28 + textLength, 1);
			DecodeAtari8Gr15(unpacked, (height + 1) * contentStride, contentStride << 1, frame2, width, width << 1, height >> 1);
			return ApplyAtari8PaletteBlend(frame1, frame2);
		case 0x20: // HIP, RIP
			SetSize(width, height, RECOILResolution.Xe2x1);
			LeftSkip = 1;
			DecodeAtari8Gr10(unpacked, 0, frame1, 0, width, height);
			GtiaColors[8] = 0x00;
			DecodeAtari8Gr9(unpacked, height * contentStride, contentStride, frame2, 0, width, width, height);
			return ApplyAtari8PaletteBlend(frame1, frame2);
		case 0x30: // Multi RIP
			SetSize(width, height, RECOILResolution.Xe2x1);
			LeftSkip = 1;
			GtiaColors[0] = 0x00;
			int colorsOffset = height * contentStride << 1;
			for (int y = 0; y < height; y += 2) {
				SetPM123PF0123Bak(unpacked, colorsOffset + (y << 2));
				DecodeAtari8Gr10(unpacked, y * contentStride, frame1, y * width, width, y + 1 < height ? 2 : 1);
			}
			GtiaColors[8] = 0x00;
			DecodeAtari8Gr9(unpacked, height * contentStride, contentStride, frame2, 0, width, width, height);
			return ApplyAtari8PaletteBlend(frame1, frame2);
		default:
			return false;
		}
	}

	bool DecodeVzi!(byte[] content, int contentLength)
	{
		if (contentLength != 16000)
			return false;
		SetSize(320, 200, RECOILResolution.Xe2x1);
		byte[320 * 200] frame1;
		LeftSkip = -1;
		DecodeAtari8Gr9(content, 0, 40, frame1, 0, 320, 320, 200);
		LeftSkip = 1;
		byte[320 * 200] frame2;
		DecodeAtari8Gr9(content, 8000, 40, frame2, 0, 320, 320, 200);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeRmUnpacked!(byte[] content, int colorsOffset, int dliOffset, byte[] bitmap, int mode, RECOILResolution resolution)
	{
		bool[192] dliPresent = false;
		for (int i = 0; i < 128; i++) {
			int y = content[dliOffset + i];
			switch (y) {
			case 0:
				break;
			case 1:
			case 2:
			case 4:
			case 5:
				return false;
			default:
				if (mode == 0) {
					if (y >= 5 + 96)
						return false;
					if (y == 3)
						y = 0;
					else
						y -= 5;
				}
				else {
					if (y == 100 || y == 101 || y >= 198)
						return false;
					if (y == 3)
						y = 1;
					else if (y < 100)
						y -= 4;
					else
						y -= 6;
				}
				dliPresent[y] = true;
				break;
			}
		}

		SetSize(320, 192, resolution);
		if (mode == 2)
			LeftSkip = 2;
		if (mode == 1)
			GtiaColors[8] = content[colorsOffset + 8] & 0xf0;
		else
			SetGtiaColors(content, colorsOffset);
		int height = mode == 0 ? 96 : 192;
		byte[320 * 192] frame;
		for (int y = 0; y < height; y++) {
			switch (mode) {
			case 0:
				DecodeAtari8Gr7(bitmap, y * 40, frame, y * 640, 1);
				break;
			case 1:
				DecodeAtari8Gr9(bitmap, y * 40, 40, frame, y * 320, 320, 320, 1);
				break;
			case 2:
				DecodeAtari8Gr10(bitmap, y * 40, frame, y * 320, 320, 1);
				break;
			case 3:
				DecodeAtari8Gr11(bitmap, y * 40, frame, y * 320, 320, 1);
				break;
			case 4:
				DecodeAtari8Gr15(bitmap, y * 40, 40, frame, y * 320, 320, 1);
				break;
			default:
				assert false;
			}
			if (dliPresent[y]) {
				int vcount = mode == 0 ? 16 + y : 16 + (y - 1 >> 1);
				int reg = content[dliOffset + 128 + vcount];
				if (reg < 9)
					SetGtiaColor(reg, content[dliOffset + 256 + vcount]);
				else if (reg != 0x80)
					return false;
			}
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeRm!(byte[] content, int contentLength, int mode, RECOILResolution resolution)
	{
		XeKoalaStream() rle;
		rle.Content = content;
		rle.ContentOffset = 0;
		rle.ContentLength = contentLength - 464;
		if (rle.UnpackWrapped(mode == 0 ? 3840 : 7680)) {
			// File written by a Rambrandt plugin ("DOS module").
			// Documentation suggests RM0-RM4 extensions.
			return DecodeRmUnpacked(content, contentLength - 464, contentLength - 384, rle.Unpacked, mode, resolution);
		}
		else if (contentLength == 8192) {
			// Rambrandt native raw format.
			// Rambrandt writes directly to disk using its own filesystem:
			// 10 pictures per disk, 32 characters filename (no extension).
			// We assume RM0-RM4 extensions even though it's a different format.
			return DecodeRmUnpacked(content, 0x1e00, 0x1e80, content, mode, resolution);
		}
		return false;
	}

	bool DecodeAgp!(byte[] content, int contentLength)
	{
		if (contentLength != 7690)
			return false;
		SetGtiaColors(content, 1);
		byte[320 * 192] frame;
		switch (content[0]) {
		case 8:
			SetSize(320, 192, RECOILResolution.Xe1x1);
			DecodeAtari8Gr8(content, 10, frame, 0, 192);
			break;
		case 9:
			SetSize(320, 192, RECOILResolution.Xe4x1);
			DecodeAtari8Gr9(content, 10, 40, frame, 0, 320, 320, 192);
			break;
		case 10:
			SetSize(320, 192, RECOILResolution.Xe4x1);
			LeftSkip = 2;
			DecodeAtari8Gr10(content, 10, frame, 0, 320, 192);
			break;
		case 11:
			SetSize(320, 192, RECOILResolution.Xe4x1);
			DecodeAtari8Gr11(content, 10, frame, 0, 320, 192);
			break;
		case 15:
			SetSize(320, 192, RECOILResolution.Xe2x1);
			DecodeAtari8Gr15(content, 10, 40, frame, 0, 320, 192);
			break;
		default:
			return false;
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeShc!(byte[] content, int contentLength)
	{
		if (contentLength != 17920)
			return false;
		SetSize(320, 192, RECOILResolution.Xe1x1);
		byte[320 * 192] frame1;
		byte[320 * 192] frame2;
		int col1 = 0x3c00;
		int col2 = 0x4100;
		for (int y = 0; y < 192; y++) {
			for (int x = 0; x < 320; x++) {
				int i = 320 * y + x;
				int bit = ~x & 7;
				switch (x) {
				// Widths measured in Atari800Win PLus 4.0 and Altirra 2.0-test47.
				case 46 + 48:
				case 46 + 48 + 48+ 24:
				case 46 + 48 + 48+ 24 + 24 + 24:
				case 46 + 48 + 48+ 24 + 24 + 24 + 24 + 24:
				case 46 + 48 + 48+ 24 + 24 + 24 + 24 + 24 + 24 + 20:
					col1++;
					break;
				case 46:
				case 46 + 48 + 48:
				case 46 + 48 + 48 + 24 + 24:
				case 46 + 48 + 48 + 24 + 24 + 24 + 24:
				case 46 + 48 + 48 + 24 + 24 + 24 + 24 + 24 + 24:
					col2++;
					break;
				default:
					break;
				}
				// COLPF1 == 0
				frame1[i] = content[col1] & ((content[i >> 3] >> bit & 1) != 0 ? 0xf0 : 0xfe);
				frame2[i] = content[col2] & ((content[7680 + (i >> 3)] >> bit & 1) != 0 ? 0xf0 : 0xfe);
			}
			col1++;
			col2++;
		}
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeMgp!(byte[] content, int contentLength)
	{
		if (contentLength != 3845)
			return false;
		SetSize(320, 192, RECOILResolution.Xe2x2);
		byte[320 * 192] frame;
		SetPF0123Bak(content, 0);
		int rainbow = content[5];

		// The file is missing the last byte of the bitmap.
		byte[3840] bitmap;
		content.CopyTo(6, bitmap, 0, 3839);
		bitmap[3839] = 0; // put background in the missing byte

		for (int y = 0; y < 96; y++) {
			if (rainbow < 4) {
				// Rainbow effect :)
				// The constant 16 is arbitrary here.
				// For correct animation it should decrease every frame.
				GtiaColors[rainbow == 0 ? 8 : 3 + rainbow] = 16 + y & 0xfe;
			}
			DecodeAtari8Gr7(bitmap, y * 40, frame, y * 640, 1);
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeGad!(byte[] content, int contentLength)
	{
		if (contentLength != 4325)
			return false;
		SetSize(320, 192, RECOILResolution.Xe2x2);
		byte[320 * 192] frame;
		SetPF0123Bak(content, 0);
		for (int y = 0; y < 96; y++) {
			DecodeAtari8Gr7(content, 5 + y * 40, frame, y * 640, 1);
			if (content[0xf05 + y] < 0x80) {
				for (int i = 0; i < 4; i++)
					GtiaColors[i == 3 ? 8 : 4 + i] = content[0xf65 + i * 96 + y] & 0xfe;
			}
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeFwa!(byte[] content, int contentLength)
	{
		if (contentLength < 0x1f18 || content[0] != 0xfe || content[1] != 0xfe
		 || content[6] != 0x70 || content[7] != 0x70 || content[8] != 0x70 || content[0xb] != 0x50 || content[0x73] != 0x60 || content[0xcd] != 0x41
		 || 0x1f18 + content[0x1f16] + (content[0x1f17] << 8) != contentLength)
			return false;
		SetSize(320, 192, RECOILResolution.Xe2x1);
		byte[320 * 192] frame;
		SetBakPF012(content, 2, 1);
		int dlOffset = 9;
		int dliOffset = 0x1f18;
		for (int y = 0; y < 192; y++) {
			DecodeAtari8Gr15(content, 0x106 + 40 * y + (y >= 102 ? 16 : 0), 40, frame, y * 320, 320, 1);
			int dlInstr = content[dlOffset];
			if (dlOffset == 9 || dlOffset == 0x71) {
				if ((dlInstr & 0x7f) != 0x4e || content[dlOffset + 1] != 0)
					return false;
				dlOffset += 3;
			}
			else {
				if ((dlInstr & 0x7f) != 0x0e)
					return false;
				dlOffset++;
			}
			if (dlInstr >= 0x80) {
				if (dliOffset + 14 > contentLength || content[dliOffset] != 0x48 || content[dliOffset + 1] != 0x8a || content[dliOffset + 2] != 0x48
				 || content[dliOffset + 3] != 0xa9 || content[dliOffset + 5] != 0x8d || content[dliOffset + 6] != 0x0a || content[dliOffset + 7] != 0xd4)
					return false;
				byte a = content[dliOffset + 4];
				dliOffset += 8;
				while (content[dliOffset] != 0x20) {
					switch (content[dliOffset]) {
					case 0xa9:
						a = content[dliOffset + 1];
						dliOffset += 2;
						break;
					case 0x8d:
						if (content[dliOffset + 2] != 0xd0)
							return false;
						int lo = content[dliOffset + 1];
						switch (lo) {
						case 0x16:
						case 0x17:
						case 0x18:
						case 0x1a:
							GtiaColors[lo - 0x12] = a & 0xfe;
							break;
						default:
							return false;
						}
						dliOffset += 3;
						break;
					default:
						return false;
					}
					if (dliOffset + 3 > contentLength)
						return false;
				}
				if (content[dliOffset + 1] != 0xca || content[dliOffset + 2] != 0x06)
					return false;
				dliOffset += 3;
			}
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAtari8Font!(byte[] characters, byte[] font, int fontOffset)
	{
		SetSize(256, 32, RECOILResolution.Xe1x1);
		byte[256 * 32] frame;
		DecodeAtari8Gr0(characters, 0, 32, font, fontOffset, frame);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAtari8Fnt!(byte[] content, int contentLength)
	{
		int contentOffset;
		switch (contentLength) {
		case 1024:
		case 1025:
		case 1026:
			contentOffset = 0;
			break;
		case 1030:
			if (ParseAtari8ExecutableHeader(content, 0) != 1024)
				return false;
			contentOffset = 6;
			break;
		default:
			return false;
		}
		return DecodeAtari8Font(null, content, contentOffset);
	}

	bool DecodeF80!(byte[] content, int contentLength)
	{
		if (contentLength != 512)
			return false;
		SetSize(128, 32, RECOILResolution.Xe1x1);
		byte[128 * 32] frame;
		DecodeAtari8Gr0(null, 0, 16, content, 0, frame);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeSxs!(byte[] content, int contentLength)
	{
		if (contentLength != 1030 || ParseAtari8ExecutableHeader(content, 0) != 1024)
			return false;
		byte[128] characters;
		// 00 01 04 05 08 09 ... 3c 3d
		// 02 03 06 07 0a 0b ... 3e 3f
		// 40 41 44 45 48 49 ... 7c 7d
		// 42 43 46 47 4a 4b ... 7e 7f
		for (int i = 0; i < 128; i++)
			characters[i] = (i & 0x41) | (i >> 4 & 2) | ((i & 0x1e) << 1);
		return DecodeAtari8Font(characters, content, 6);
	}

	bool DecodeFn2!(byte[] content, int contentLength)
	{
		if (contentLength != 2048)
			return false;
		SetSize(256, 64, RECOILResolution.Xe1x1);
		GtiaColors[6] = 0x00;
		GtiaColors[5] = 0x0e;
		byte[256 * 64] frame;
		for (int y = 0; y < 64; y += 8)
			DecodeAtari8Gr0Line(null, y >> 4 << 5, content, (y & 8) << 7, frame, y << 8, 8);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeNlq!(byte[] content, int contentLength)
	{
		if (contentLength < 19 + 90 * 4 || !IsStringAt(content, 0, "DAISY-DOT NLQ FONT") || content[18] != 0x9b)
			return false;
		SetSize(320, 96, RECOILResolution.Xe1x1);
		byte[320 * 96] frame = 0;
		int contentOffset = 19;
		for (int i = 0; i < 91; i++) {
			if (contentOffset >= contentLength)
				return false;
			int width = content[contentOffset];
			if (width == 0 || width > 19)
				return false;
			int nextContentOffset = contentOffset + (width + 1) * 2;
			if (nextContentOffset > contentLength || content[nextContentOffset - 1] != 0x9b)
				return false;
			int c = i < 64 ? i : i < 90 ? i + 1 : 92;
			for (int y = 0; y < 16; y++) {
				for (int x = 0; x < width; x++) {
					int b = content[contentOffset + 1 + (y & 1) * width + x] >> (7 - (y >> 1)) & 1;
					frame[(c & 0xf0 | y) * 320 + (c & 0xf) * 20 + x] = b == 0 ? 0x00 : 0x0e;
				}
			}
			contentOffset = nextContentOffset;
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeGr1!(byte[] content, int contentLength, int doubleHeight)
	{
		int charsLength = 480 >> doubleHeight;
		switch (contentLength - charsLength) {
		case 0:
			SetXeOsDefaultColors();
			break;
		case 5:
			SetBakPF0123(content, charsLength);
			break;
		default:
			return false;
		}
		SetSize(320, 192, doubleHeight == 0 ? RECOILResolution.Xe2x1 : RECOILResolution.Xe2x2);
		byte[320 * 192] frame;
		byte[] font = resource<byte[]>("atari8.fnt");
		for (int offset = 0; offset < charsLength; offset += 20)
			DecodeAtari8Gr1Line(content, offset, font, 0, frame, offset << 7 + doubleHeight, doubleHeight);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAcs!(byte[] content, int contentLength)
	{
		if (contentLength != 1028)
			return false;
		SetBakPF012(content, 0, 1);
		SetSize(128, 64, RECOILResolution.Xe2x1);
		byte[128 * 64] frame;
		for (int y = 0; y < 8; y++)
			DecodeAtari8Gr12Line(null, 0, content, 4 + (y << 7), frame, y << 10, 0);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeJgp!(byte[] content, int contentLength)
	{
		if (contentLength != 2054 || ParseAtari8ExecutableHeader(content, 0) != 2048)
			return false;
		SetGr15DefaultColors();
		SetSize(256, 64, RECOILResolution.Xe2x1);
		byte[256 * 64] frame;
		for (int y = 0; y < 8; y++)
			DecodeAtari8Gr12Line(null, 0, content, 6 + ((y & 6) << 7) + ((y & 1) << 10), frame, y << 11, 0);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeLeo!(byte[] content, int contentLength)
	{
		if (contentLength != 2580)
			return false;
		SetSize(256, 64, RECOILResolution.Xe2x1);
		byte[256 * 64] frame;
		byte[32] characters;
		SetPF0123Bak(content, 0xa00);
		// The last 15 file bytes are RGB colors.
		// We use the configured Atari 8-bit palette instead.
		for (int y = 0; y < 8; y++) {
			for (int x = 0; x < 32; x++)
				characters[x] = content[0x800 + ((x & 1) << 7) + ((y & 1) << 6) + ((y & 6) << 3) + (x >> 1)];
			DecodeAtari8Gr12Line(characters, 0, content, (y & 1) << 10, frame, y << 11, 0);
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeSif!(byte[] content, int contentLength)
	{
		if (contentLength != 2048)
			return false;
		SetSize(256, 32, RECOILResolution.Xe2x1);
		GtiaColors[4] = 0x4c;
		GtiaColors[5] = 0xcc;
		GtiaColors[6] = 0x8c;
		GtiaColors[8] = 0x00;
		byte[256 * 32] frame1;
		byte[256 * 32] frame2;
		for (int y = 0; y < 4; y++) {
			DecodeAtari8Gr12Line(null, 0, content, y << 8, frame1, y << 11, 0);
			DecodeAtari8Gr12Line(null, 0, content, 1024 + (y << 8), frame2, y << 11, 0);
		}
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeDlm!(byte[] content, int contentLength)
	{
		if (contentLength != 256)
			return false;
		byte[11 * 16] characters;
		for (int y = 0; y < 16; y++)
			for (int x = 0; x < 11; x++)
				characters[y * 11 + x] = ToAtari8Char(content[y * 16 + 5 + x]);
		SetSize(88, 128, RECOILResolution.Xe1x1);
		byte[88 * 128] frame;
		DecodeAtari8Gr0(characters, 0, 11, resource<byte[]>("atari8.fnt"), 0, frame);
		return ApplyAtari8Palette(frame);
	}

	void DecodeAtari8Gr0Screen!(byte[] content, byte[] font)
	{
		SetSize(320, 192, RECOILResolution.Xe1x1);
		byte[320 * 192] frame;
		DecodeAtari8Gr0(content, 0, 40, font, 0, frame);
		ApplyAtari8Palette(frame);
	}

	bool DecodeGr0!(byte[] content, int contentLength)
	{
		if (contentLength != 960)
			return false;
		DecodeAtari8Gr0Screen(content, resource<byte[]>("atari8.fnt"));
		return true;
	}

	bool DecodeSge!(byte[] content, int contentLength)
	{
		if (contentLength != 960)
			return false;
		byte[1024] font;
		resource<byte[]>("atari8.fnt").CopyTo(0, font, 0, 1024);
		for (int i = 0; i < 4; i++) {
			font[0x7d * 8 + 4 + i] = font[0x5b * 8 + i] = 0x0f;
			font[0x7d * 8 + i] = font[0x5b * 8 + 4 + i] = 0xf0;
		}
		DecodeAtari8Gr0Screen(content, font);
		return true;
	}

	bool DecodeAn2!(byte[] content, int contentLength)
	{
		if (contentLength < 3)
			return false;
		int columns = content[0] + 1;
		int rows = content[1] + 1;
		if (columns > 40 || rows > 24)
			return false;
		SetSize(columns << 3, rows << 3, RECOILResolution.Xe1x1);
		byte[320 * 192] frame;
		DecodeAtari8Gr0(content, 2, columns, resource<byte[]>("atari8.fnt"), 0, frame);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAn4!(byte[] content, int contentLength, int doubleHeight)
	{
		if (contentLength < 8)
			return false;
		int columns;
		int rows;
		int charactersOffset;
		if (contentLength << doubleHeight == 960) {
			columns = 40;
			rows = 24 >> doubleHeight;
			SetXeOsDefaultColors();
			charactersOffset = 0;
		}
		else {
			columns = content[0] + 1;
			rows = content[1] + 1;
			if (columns > 40 || rows << doubleHeight > 24)
				return false;
			SetBakPF0123(content, 2);
			charactersOffset = 7;
		}
		if (doubleHeight == 0)
			SetSize(columns << 3, rows << 3, RECOILResolution.Xe2x1);
		else
			SetSize(columns << 3, rows << 4, RECOILResolution.Xe2x2);
		byte[320 * 192] frame;
		byte[] font = resource<byte[]>("atari8.fnt");
		for (int y = 0; y < rows; y++)
			DecodeAtari8Gr12Line(content, charactersOffset + y * columns, font, 0, frame, y * columns << (6 + doubleHeight), doubleHeight);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeTl4!(byte[] content, int contentLength)
	{
		if (contentLength < 11)
			return false;
		const int maxColumns = 4;
		const int maxRows = 5;
		int columns = content[0];
		int rows = content[1];
		if (columns == 0 || columns > maxColumns || rows == 0 || rows > maxRows)
			return false;
		SetSize(columns << 3, rows << 3, RECOILResolution.Xe2x1);
		byte[maxColumns * 8 * maxRows * 8] frame;
		for (int y = 0; y < rows << 3; y++) {
			for (int x = 0; x < columns << 3; x++) {
				int offset = 2 + ((y >> 3) * columns + (x >> 3)) * 9;
				int c;
				switch (content[offset + (y & 7)] >> (~x & 6) & 3) {
				case 1:
					c = 0x28;
					break;
				case 2:
					c = 0xca;
					break;
				case 3:
					c = content[offset + 8] == 0 ? 0x94 : 0x46;
					break;
				default:
					c = 0x00;
					break;
				}
				frame[(y * columns << 3) + x] = c;
			}
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAsciiArtEditor!(byte[] content, int contentLength)
	{
		if (contentLength <= 0 || content[contentLength - 1] != 0x9b)
			return false;

		const int maxColumns = 64;
		const int maxRows = 24;
		byte[maxColumns * maxRows] characters;
		int columns = 1;
		int x = 0;
		int y = 0;
		for (int contentOffset = 0; contentOffset < contentLength; contentOffset++) {
			int ch = content[contentOffset];
			if (y >= maxRows)
				return false;
			if (ch == 0x9b) {
				if (columns < x)
					columns = x;
				while (x < maxColumns) // pad with spaces
					characters[y * maxColumns + x++] = 0x00;
				x = 0;
				y++;
			}
			else {
				if (x >= maxColumns)
					return false;
				characters[y * maxColumns + x++] = ToAtari8Char(ch);
			}
		}

		SetSize(columns << 3, y << 3, RECOILResolution.Xe1x1);
		byte[maxColumns * 8 * maxRows * 8] frame;
		DecodeAtari8Gr0(characters, 0, maxColumns, resource<byte[]>("atari8.fnt"), 0, frame);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAll!(byte[] content, int contentLength)
	{
		// "ALL" format of GRAPH.COM by Adam Bienias:
		// 24 bytes - font in line (0-7)
		// n*1024 bytes - fonts
		// 960 bytes - characters
		// 5 bytes - PF0, PF1, PF2, PF3, BAK colors

		if ((contentLength & 0x3ff) != 24 + 960 + 5)
			return false;
		SetPF0123Bak(content, contentLength - 5);
		SetSize(320, 192, RECOILResolution.Xe2x1);
		byte[320 * 192] frame;
		for (int y = 0; y < 24; y++) {
			int fontOffset = 24 + (content[y] << 10);
			if (fontOffset >= contentLength - 965)
				return false;
			DecodeAtari8Gr12Line(content, contentLength - 965 + y * 40, content, fontOffset, frame, y * (8 * 320), 0);
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeKpr!(byte[] content, int contentLength)
	{
		if (contentLength < 11 || GetAtari8ExecutableOffset(content, contentLength) != 6)
			return false;
		// The manual: http://atarionline.pl/biblioteka/materialy_ksiazkowe/Animator.djvu
		// says the format is cols,rows,frames while actually it is frames,cols,rows.
		// They are followed by tile numbers then tile graphics.
		// Tiles are like Graphics 12 characters but there might be up to 256 different tiles.
		// Tile numbers are stored in the following order: for each frame, from top to bottom row, cols tiles.
		int frames = content[8];
		int cols = content[9];
		int rows = content[10];
		int tiles = frames * cols * rows;
		if (contentLength < 11 + tiles
		 || !SetSize(frames * cols << 3, rows << 3, RECOILResolution.Xe2x1))
			return false;
		int pixelsOffset = 0;
		for (int y = 0; y < rows << 3; y++) {
			for (int f = 0; f < frames; f++) {
				for (int x = 0; x < cols << 3; x++) {
					int c = content[11 + (f * rows + (y >> 3)) * cols + (x >> 3)]; // tile number
					c = 11 + tiles + (c << 3) + (y & 7); // offset in tile graphics
					if (c >= contentLength)
						return false;
					c = content[c] >> (~x & 6) & 3; // color
					Pixels[pixelsOffset++] = Atari8Palette[c << 2];
				}
			}
		}
		return true;
	}

	bool DecodeEnvisionCommon!(byte[] content, int mode, int columns, int rows, int charactersOffset, int[] fontId2Offset)
	{
		int charWidth;
		int charHeight;
		RECOILResolution resolution;
		switch (mode) {
		case 2:
			charWidth = 8;
			charHeight = 8;
			resolution = RECOILResolution.Xe1x1;
			break;
		case 3:
			charWidth = 8;
			charHeight = 10;
			resolution = RECOILResolution.Xe1x1;
			break;
		case 4:
			charWidth = 8;
			charHeight = 8;
			resolution = RECOILResolution.Xe2x1;
			break;
		case 5:
			charWidth = 8;
			charHeight = 16;
			resolution = RECOILResolution.Xe2x2;
			break;
		case 6:
			charWidth = 16;
			charHeight = 8;
			resolution = RECOILResolution.Xe2x1;
			break;
		case 7:
			charWidth = 16;
			charHeight = 16;
			resolution = RECOILResolution.Xe2x2;
			break;
		default:
			return false;
		}
		if (!SetSize(columns * charWidth, rows * charHeight, resolution))
			return false;
		byte[]# frame = new byte[Width * Height];
		for (int row = 0; row < rows; row++) {
			int fontOffset;
			if (fontId2Offset != null) {
				fontOffset = fontId2Offset[content[8 + columns * rows + 256 + row]];
				if (fontOffset == 0)
					return false;
			}
			else {
				fontOffset = 10 + columns * rows;
			}
			int frameOffset = row * charHeight * Width;
			switch (mode >> 1) {
			case 1:
				DecodeAtari8Gr0Line(content, charactersOffset, content, fontOffset, frame, frameOffset, charHeight);
				break;
			case 2:
				DecodeAtari8Gr12Line(content, charactersOffset, content, fontOffset, frame, frameOffset, mode & 1);
				break;
			case 3:
				DecodeAtari8Gr1Line(content, charactersOffset, content, fontOffset, frame, frameOffset, mode & 1);
				break;
			default:
				assert false;
			}
			charactersOffset += columns;
		}
		ApplyAtari8Palette(frame);
		return true;
	}

	bool DecodeEnvision!(byte[] content, int contentLength)
	{
		if (contentLength < 8 + 1 + 256 + 204 + 3 + 1 + 8 + 1024)
			return false;
		int columns = content[1] + 1;
		int rows = content[2] + 1;
		if (rows > 204)
			return false;
		int fontOffset = 8 + columns * rows + (256 + 204 + 3);
		if (contentLength < fontOffset
		 || contentLength != fontOffset + content[fontOffset - 1] * (1 + 8 + 1024))
			return false;
		int[256] fontId2Offset = 0;
		for (; fontOffset < contentLength; fontOffset += 1 + 8 + 1024)
			fontId2Offset[content[fontOffset]] = fontOffset + 1 + 8;
		SetPF0123Bak(content, 3);
		return DecodeEnvisionCommon(content, content[0] & 0x7f, columns, rows, 8, fontId2Offset);
	}

	bool DecodeEnvisionPC!(byte[] content, int contentLength)
	{
		if (contentLength < 10 + 1 + 1024 || content[2] >= 0x80) // protect against columns*rows overflow
			return false;
		int columns = content[1] | content[2] << 8;
		int rows = content[3] | content[4] << 8;
		int contentOffset = 10 + columns * rows + 1024;
		while (contentOffset < contentLength) {
			switch (content[contentOffset++]) {
			case 0:
				break;
			case 1:
				if (contentOffset + 6 >= contentLength
				 || content[contentOffset + 1] >= 5 || content[contentOffset + 3] >= 5 || content[contentOffset + 5] >= 5) // protect against int overflow
					return false;
				contentOffset += (content[contentOffset] + (content[contentOffset + 1] << 8))
					* (content[contentOffset + 2] + (content[contentOffset + 3] << 8))
					* (content[contentOffset + 4] + (content[contentOffset + 5] << 8) + 1);
				break;
			case 2:
				contentOffset += columns * rows;
				break;
			case 3:
				contentOffset += 3 + 1024;
				break;
			default:
				return false;
			}
		}
		if (contentOffset > contentLength)
			return false;
		SetBakPF0123(content, 5);
		return DecodeEnvisionCommon(content, content[0], columns, rows, 10, null);
	}

	bool DecodeMcs!(byte[] content, int contentLength)
	{
		if (contentLength != 10185)
			return false;
		// "Super Bilder.atr" slideshow:
		// 9 bytes: COLPM0-3, COLPF0-3, COLBAK
		// 8192 bytes: 8 fonts (one font per 3 character lines)
		// 960 bytes: 40x24 characters
		// 640 bytes: missiles and four players
		// 384 bytes: apparently unused
		SetSize(320, 192, RECOILResolution.Xe2x1);
		byte[320 * 192] frame;
		for (int y = 0; y < 192; y++) {
			int fontOffset = 9 + (y / 24 << 10);
			for (int x = 0; x < 320; x++) {
				int ch = content[9 + 8192 + (y >> 3) * 40 + (x >> 3)];
				int c;
				switch (content[fontOffset + ((ch & 0x7f) << 3) + (y & 7)] >> (~x & 6) & 3) {
				case 0:
					// Sprites are 4x width, arranged next to each other in the following order:
					// P0 M0 P1 M1 P2 M2 P3 M3
					c = x / 80; // player/missile number
					int pmgBit = (x >> 3) % 10;
					int pmgOffset;
					if (pmgBit < 8) {
						// player
						pmgBit = 7 - pmgBit;
						pmgOffset = 9 + 8192 + 960 + 128 + 16 + (c << 7);
					}
					else {
						// missile
						pmgBit = (c << 1) | (pmgBit ^ 9);
						pmgOffset = 9 + 8192 + 960 + 16;
					}
					if ((content[pmgOffset + (y >> 1)] >> pmgBit & 1) == 0)
						c = 8; // COLBAK
					break;
				case 1:
					c = 4;
					break;
				case 2:
					c = 5;
					break;
				default: // case 3:
					c = 6 + (ch >> 7);
					break;
				}
				frame[y * 320 + x] = content[c] & 0xfe;
			}
		}
		return ApplyAtari8Palette(frame);
	}

	static int Gr12GtiaNibbleToGr8(int nibble, int ch, bool gtia10)
	{
		switch (nibble) {
		case 0:  // 000 000
		case 1:  // 000 100
		case 4:  // 100 000
		case 5:  // 100 100
			return 0;
		case 2:  // 000 101
		case 6:  // 100 101
			return 1;
		case 3:  // 000 11x
		case 7:  // 100 11x
			return (ch & 0x80) == 0 ? 2 : 3;
		case 8:  // 101 000
			return gtia10 ? 8 : 4;
		case 9:  // 101 100
			return 4;
		case 10: // 101 101
			return 5;
		case 11: // 101 11x
			return (ch & 0x80) == 0 ? 6 : 7;
		case 12: // 11x 000
			return gtia10 || (ch & 0x80) == 0 ? 8 : 12;
		case 13: // 11x 100
			return (ch & 0x80) == 0 ? 8 : 12;
		case 14: // 11x 101
			return (ch & 0x80) == 0 ? 9 : 13;
		case 15: // 11x 11x
			return (ch & 0x80) == 0 ? 10 : 15;
		default:
			// not reachable
			return 0;
		}
	}

	static int Gr12GtiaByteToGr8(int b, int ch, bool gtia10)
	{
		return Gr12GtiaNibbleToGr8(b >> 4, ch, gtia10) << 4
			| Gr12GtiaNibbleToGr8(b & 0xf, ch, gtia10);
	}

	const int IceFontFrame1 = -1;
	const int IceFontFrame2 = -2;

	void DecodeIceFrame(byte[] content, int charactersOffset, int fontOffset, byte[]! frame, IceFrameMode mode)
	{
		int doubleLine;
		switch (mode) {
		case IceFrameMode.Gr13Gtia9:
		case IceFrameMode.Gr13Gtia10:
		case IceFrameMode.Gr13Gtia11:
			doubleLine = 1;
			break;
		default:
			doubleLine = 0;
			break;
		}
		int frameOffset = 0;
		byte[40] bitmap;
		for (int y = 0; y < Height; y++) {
			for (int col = 0; col < Width >> 3; col++) {
				int ch;
				switch (charactersOffset) {
				case IceFontFrame1:
					const byte[16] row2char1 = { 0x40, 0x00, 0x20, 0x60, 0xc0, 0x80, 0xa0, 0xe0, 0x40, 0x00, 0x20, 0x60, 0xc0, 0x80, 0xa0, 0xe0 };
					ch = row2char1[y >> (3 + doubleLine)] + col;
					break;
				case IceFontFrame2:
					const byte[16] row2char2 = { 0x40, 0x00, 0x20, 0x60, 0xc0, 0x80, 0xa0, 0xe0, 0xc0, 0x80, 0xa0, 0xe0, 0x40, 0x00, 0x20, 0x60 };
					ch = row2char2[y >> (3 + doubleLine)] + col;
					break;
				default: // IRG/IR2/DIN/ICN/IMN/IPC/IP2 picture
					ch = (y / 24 << 8) + content[charactersOffset + (y >> 3) * 40 + col];
					break;
				}
				int b = content[fontOffset + ((ch & ~0x80) << 3) + (y >> doubleLine & 7)];
				switch (mode) {
				case IceFrameMode.Gr0:
				case IceFrameMode.Gr0Gtia9:
				case IceFrameMode.Gr0Gtia10:
				case IceFrameMode.Gr0Gtia11:
					if (charactersOffset < 0 && (ch & 0x80) != 0) // GR. 0 inverse only for fonts, it's disabled in CHACTL for pictures
						b ^= 0xff;
					bitmap[col] = b;
					break;
				case IceFrameMode.Gr12:
					for (int x = col == 0 ? LeftSkip : 0; x < 8; x++) {
						int c = b >> (~x & 6) & 3;
						int gr12Registers = (ch & 0x80) == 0 ? 0x6548 : 0x7548;
						frame[frameOffset + (col << 3) + x - LeftSkip] = GtiaColors[gr12Registers >> (c << 2) & 0xf];
					}
					break;
				case IceFrameMode.Gr12Gtia9:
				case IceFrameMode.Gr12Gtia11:
				case IceFrameMode.Gr13Gtia9:
				case IceFrameMode.Gr13Gtia11:
					bitmap[col] = Gr12GtiaByteToGr8(b, ch, false);
					break;
				case IceFrameMode.Gr12Gtia10:
				case IceFrameMode.Gr13Gtia10:
					bitmap[col] = Gr12GtiaByteToGr8(b, ch, true);
					break;
				}
			}
			switch (mode) {
			case IceFrameMode.Gr0:
				DecodeAtari8Gr8(bitmap, 0, frame, frameOffset, 1);
				break;
			case IceFrameMode.Gr12:
				for (int x = Width ; x < Width + LeftSkip; x++)
					frame[frameOffset + x] = GtiaColors[8];
				break;
			case IceFrameMode.Gr0Gtia9:
			case IceFrameMode.Gr12Gtia9:
			case IceFrameMode.Gr13Gtia9:
				DecodeAtari8Gr9(bitmap, 0, 0, frame, frameOffset, 0, Width, 1);
				break;
			case IceFrameMode.Gr0Gtia10:
			case IceFrameMode.Gr12Gtia10:
			case IceFrameMode.Gr13Gtia10:
				DecodeAtari8Gr10(bitmap, 0, frame, frameOffset, 0, 1);
				break;
			case IceFrameMode.Gr0Gtia11:
			case IceFrameMode.Gr12Gtia11:
			case IceFrameMode.Gr13Gtia11:
				DecodeAtari8Gr11(bitmap, 0, frame, frameOffset, 0, 1);
				break;
			}
			frameOffset += Width;
		}
	}

	bool VerifyIce!(byte[] content, int contentLength, bool font, int fontLength, int imageLength, RECOILResolution resolution)
	{
		if (font) {
			if (contentLength != fontLength)
				return false;
			SetSize(256, 128, resolution);
		}
		else {
			if (contentLength != imageLength || content[0] != 1)
				return false;
			SetSize(320, 192, resolution);
		}
		return true;
	}

	void DecodeIce20Frame(byte[] content, bool second, int fontOffset, byte[]! frame, int mode)
	{
		byte[32] bitmap;
		for (int y = 0; y < 288; y++) {
			int row = y >> 5;
			int c = (second ? row / 3 : row % 3) + 1;
			for (int col = 0; col < 32; col++) {
				int ch = ((y & 0x18) << 1) + (col >> 1);
				int b = content[fontOffset + (ch << 3) + (y & 7)];
				b = (col & 1) == 0 ? b >> 4 : b & 0xf;
				b = ((b & 8) << 3 | (b & 4) << 2 | (b & 2) << 1 | (b & 1)) * c;
				if (mode == 10) {
					// nibble %x100 must be COLBAK not COLPF0
					if ((b & 0x70) == 0x40)
						b = 0x80 + (b & 0xf);
					if ((b & 7) == 4)
						b = (b & 0xf0) + 8;
				}
				bitmap[col] = b;
			}
			switch (mode) {
			case 9:
				DecodeAtari8Gr9(bitmap, 0, 0, frame, y << 8, 0, 256, 1);
				break;
			case 10:
				DecodeAtari8Gr10(bitmap, 0, frame, y << 8, 0, 1);
				break;
			case 11:
				DecodeAtari8Gr11(bitmap, 0, frame, y << 8, 0, 1);
				break;
			default:
				assert false;
			}
		}
	}

	bool DecodeAtari8Ice!(byte[] content, int contentLength, bool font, int mode)
	{
		byte[256 * 288] frame1;
		byte[256 * 288] frame2;
		switch (mode) {
		case 0:
			if (contentLength != 5 + 2048)
				return false;
			SetSize(256, 128, RECOILResolution.Xe1x1);
			GtiaColors[5] = content[1] & 0xfe;
			GtiaColors[6] = content[3] & 0xfe;
			DecodeIceFrame(content, IceFontFrame1, 5, frame1, IceFrameMode.Gr0);
			GtiaColors[5] = content[2] & 0xfe;
			GtiaColors[6] = content[4] & 0xfe;
			DecodeIceFrame(content, IceFontFrame2, 5 + 1024, frame2, IceFrameMode.Gr0);
			break;
		case 1:
			if (!VerifyIce(content, contentLength, font, 6 + 2048, 6 + 16384 + 2 * 960, RECOILResolution.Xe2x1))
				return false;
			SetBakPF0123(content, 1);
			DecodeIceFrame(content, font ? IceFontFrame1 : 6 + 16384, 6, frame1, IceFrameMode.Gr12);
			DecodeIceFrame(content, font ? IceFontFrame2 : 6 + 16384 + 960, 6 + 1024, frame2, IceFrameMode.Gr12);
			break;
		case 2:
			if (!VerifyIce(content, contentLength, font, 10 + 2048, 10 + 16384 + 2 * 960, RECOILResolution.Xe2x1))
				return false;
			GtiaColors[8] = content[1] & 0xfe;
			SetPF0123Even(content, 2);
			DecodeIceFrame(content, font ? IceFontFrame1 : 10 + 16384, 10, frame1, IceFrameMode.Gr12);
			SetPF0123Even(content, 3);
			DecodeIceFrame(content, font ? IceFontFrame2 : 10 + 16384 + 960, 10 + 1024, frame2, IceFrameMode.Gr12);
			break;
		case 3:
			if (font) {
				if (contentLength != 7 + 2048)
					return false;
				SetSize(256, 128, RECOILResolution.Xe1x1);
			}
			else {
				if (contentLength != 7 + 16384 + 960 || content[0] != 3)
					return false;
				SetSize(320, 192, RECOILResolution.Xe1x1);
			}
			SetPF21(content, 1);
			DecodeIceFrame(content, font ? IceFontFrame1 : 7 + 16384, 7, frame1, IceFrameMode.Gr0);
			SetBakPF0123(content, 2);
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, font ? IceFontFrame2 : 7 + 16384, 7 + 1024, frame2, IceFrameMode.Gr12);
			break;
		case 4:
			if (contentLength != 10 + 2048)
				return false;
			SetSize(256, 128, RECOILResolution.Xe4x1);
			LeftSkip = 2;
			SetGtiaColors(content, 1);
			DecodeIceFrame(content, IceFontFrame1, 10, frame1, IceFrameMode.Gr0Gtia10);
			DecodeIceFrame(content, IceFontFrame2, 10 + 1024, frame2, IceFrameMode.Gr0Gtia10);
			break;
		case 5:
			if (contentLength != 17 + 2048 && contentLength != 18 + 2048)
				return false;
			SetSize(256, 128, RECOILResolution.Xe4x1);
			LeftSkip = 2;
			GtiaColors[0] = content[1] & 0xfe;
			for (int i = 0; i < 8; i++)
				SetGtiaColor(i + 1, content[2 + i * 2]);
			if (contentLength == 17 + 2048) {
				DecodeIceFrame(content, IceFontFrame1, 17, frame1, IceFrameMode.Gr0Gtia10);
				for (int i = 0; i < 7; i++)
					SetGtiaColor(i + 1, content[3 + i * 2]);
				DecodeIceFrame(content, IceFontFrame2, 17 + 1024, frame2, IceFrameMode.Gr0Gtia10);
			}
			else {
				DecodeIceFrame(content, IceFontFrame1, 18, frame1, IceFrameMode.Gr0Gtia10);
				for (int i = 0; i < 8; i++)
					SetGtiaColor(i + 1, content[3 + i * 2]);
				DecodeIceFrame(content, IceFontFrame2, 18 + 1024, frame2, IceFrameMode.Gr0Gtia10);
			}
			break;
		case 6:
			if (contentLength != 3 + 2048)
				return false;
			SetSize(256, 128, RECOILResolution.Xe4x1);
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, IceFontFrame1, 3, frame1, IceFrameMode.Gr0Gtia9);
			GtiaColors[8] = content[2] & 0xfe;
			DecodeIceFrame(content, IceFontFrame2, 3 + 1024, frame2, IceFrameMode.Gr0Gtia9);
			break;
		case 7:
			if (contentLength != 3 + 2048)
				return false;
			SetSize(256, 128, RECOILResolution.Xe4x1);
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, IceFontFrame1, 3, frame1, IceFrameMode.Gr0Gtia11);
			GtiaColors[8] = content[2] & 0xfe;
			DecodeIceFrame(content, IceFontFrame2, 3 + 1024, frame2, IceFrameMode.Gr0Gtia11);
			break;
		case 8:
			if (contentLength != 10 + 2048)
				return false;
			SetSize(256, 128, RECOILResolution.Xe2x1);
			LeftSkip = 1;
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, IceFontFrame1, 10, frame1, IceFrameMode.Gr0Gtia9);
			SetGtiaColors(content, 1);
			DecodeIceFrame(content, IceFontFrame2, 10 + 1024, frame2, IceFrameMode.Gr0Gtia10);
			break;
		case 9:
			if (contentLength != 10 + 2048)
				return false;
			SetSize(256, 128, RECOILResolution.Xe2x1);
			LeftSkip = 1;
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, IceFontFrame1, 10, frame1, IceFrameMode.Gr0Gtia11);
			GtiaColors[0] = 0x00;
			SetPM123PF0123Bak(content, 2);
			DecodeIceFrame(content, IceFontFrame2, 10 + 1024, frame2, IceFrameMode.Gr0Gtia10);
			break;
		case 10:
			if (contentLength != 3 + 2048)
				return false;
			SetSize(256, 128, RECOILResolution.Xe4x1);
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, IceFontFrame1, 3, frame1, IceFrameMode.Gr0Gtia9);
			GtiaColors[8] = content[2] & 0xfe;
			DecodeIceFrame(content, IceFontFrame2, 3 + 1024, frame2, IceFrameMode.Gr0Gtia11);
			break;
		case 11:
			if (contentLength != 3 + 2048)
				return false;
			SetSize(256, 128, RECOILResolution.Xe1x1);
			GtiaColors[6] = 0x00;
			GtiaColors[5] = content[2] & 0xfe;
			DecodeIceFrame(content, IceFontFrame1, 3, frame1, IceFrameMode.Gr0);
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, IceFontFrame2, 3 + 1024, frame2, IceFrameMode.Gr0Gtia11);
			break;
		case 12:
			if (contentLength != 3 + 2048)
				return false;
			SetSize(256, 128, RECOILResolution.Xe1x1);
			SetPF21(content, 1);
			DecodeIceFrame(content, IceFontFrame1, 3, frame1, IceFrameMode.Gr0);
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, IceFontFrame2, 3 + 1024, frame2, IceFrameMode.Gr0Gtia9);
			break;
		case 13:
			if (contentLength != 11 + 2048)
				return false;
			SetSize(256, 128, RECOILResolution.Xe1x1);
			SetPF21(content, 1);
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, IceFontFrame1, 11, frame1, IceFrameMode.Gr0);
			// In the original viewer, first frame is scrolled horizontally one pixel to the right.
			// Here, I move GR. 10 to the left.
			// This can't be done on the Atari as it doesn't support scrolling GR. 10 by half a pixel.
			// I apply same technique to ICE modes 16, 19 and IP2.
			LeftSkip = 2;
			GtiaColors[0] = content[1] & 0xfe;
			SetPM123PF0123Bak(content, 3);
			DecodeIceFrame(content, IceFontFrame2, 11 + 1024, frame2, IceFrameMode.Gr0Gtia10);
			break;
		case 14:
			if (contentLength != 6 + 2048)
				return false;
			SetSize(256, 128, RECOILResolution.Xe2x1);
			SetBakPF0123(content, 1);
			DecodeIceFrame(content, IceFontFrame2, 6 + 1024, frame2, IceFrameMode.Gr12Gtia11);
			GtiaColors[8] = 0x00;
			DecodeIceFrame(content, IceFontFrame1, 6, frame1, IceFrameMode.Gr12);
			break;
		case 15:
			if (contentLength != 6 + 2048)
				return false;
			SetSize(256, 128, RECOILResolution.Xe2x1);
			SetBakPF0123(content, 1);
			DecodeIceFrame(content, IceFontFrame1, 6, frame1, IceFrameMode.Gr12);
			DecodeIceFrame(content, IceFontFrame2, 6 + 1024, frame2, IceFrameMode.Gr12Gtia9);
			break;
		case 16:
			if (contentLength != 10 + 2048)
				return false;
			SetSize(256, 128, RECOILResolution.Xe2x1);
			LeftSkip = 2;
			SetGtiaColors(content, 1);
			DecodeIceFrame(content, IceFontFrame2, 10 + 1024, frame2, IceFrameMode.Gr12Gtia10);
			LeftSkip = 0;
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, IceFontFrame1, 10, frame1, IceFrameMode.Gr12);
			break;
		case 17:
			if (!VerifyIce(content, contentLength, font, 6 + 2048, 6 + 16384 + 960, RECOILResolution.Xe2x1))
				return false;
			SetBakPF0123(content, 1);
			DecodeIceFrame(content, font ? IceFontFrame2 : 6 + 16384, 6 + 1024, frame2, IceFrameMode.Gr0Gtia11);
			GtiaColors[8] = 0x00;
			DecodeIceFrame(content, font ? IceFontFrame1 : 6 + 16384, 6, frame1, IceFrameMode.Gr12);
			break;
		case 18:
			if (!VerifyIce(content, contentLength, font, 6 + 2048, 6 + 16384 + 960, RECOILResolution.Xe2x1))
				return false;
			SetBakPF0123(content, 1);
			DecodeIceFrame(content, font ? IceFontFrame1 : 6 + 16384, 6, frame1, IceFrameMode.Gr12);
			DecodeIceFrame(content, font ? IceFontFrame2 : 6 + 16384, 6 + 1024, frame2, IceFrameMode.Gr0Gtia9);
			break;
		case 19:
			if (!VerifyIce(content, contentLength, font, 10 + 2048, 10 + 16384 + 960, RECOILResolution.Xe2x1))
				return false;
			SetPF0123Bak(content, 5);
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, font ? IceFontFrame1 : 10 + 16384, 10, frame1, IceFrameMode.Gr12);
			LeftSkip = 2;
			SetGtiaColors(content, 1);
			DecodeIceFrame(content, font ? IceFontFrame2 : 10 + 16384, 10 + 1024, frame2, IceFrameMode.Gr0Gtia10);
			break;
		case 22:
			if (contentLength != 10 + 2048)
				return false;
			SetSize(256, 256, RECOILResolution.Xe4x2);
			LeftSkip = 2;
			SetGtiaColors(content, 1);
			DecodeIceFrame(content, IceFontFrame1, 10, frame1, IceFrameMode.Gr13Gtia10);
			DecodeIceFrame(content, IceFontFrame2, 10 + 1024, frame2, IceFrameMode.Gr13Gtia10);
			break;
		case 23:
			if (contentLength != 17 + 2048)
				return false;
			SetSize(256, 256, RECOILResolution.Xe4x2);
			LeftSkip = 2;
			GtiaColors[0] = content[1] & 0xfe;
			for (int i = 0; i < 8; i++)
				SetGtiaColor(i + 1, content[2 + i * 2]);
			DecodeIceFrame(content, IceFontFrame1, 17, frame1, IceFrameMode.Gr13Gtia10);
			for (int i = 0; i < 7; i++)
				SetGtiaColor(i + 1, content[3 + i * 2]);
			DecodeIceFrame(content, IceFontFrame2, 17 + 1024, frame2, IceFrameMode.Gr13Gtia10);
			break;
		case 24:
			if (contentLength != 3 + 2048)
				return false;
			SetSize(256, 256, RECOILResolution.Xe4x2);
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, IceFontFrame1, 3, frame1, IceFrameMode.Gr13Gtia9);
			GtiaColors[8] = content[2] & 0xfe;
			DecodeIceFrame(content, IceFontFrame2, 3 + 1024, frame2, IceFrameMode.Gr13Gtia9);
			break;
		case 25:
			if (contentLength != 3 + 2048)
				return false;
			SetSize(256, 256, RECOILResolution.Xe4x2);
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, IceFontFrame1, 3, frame1, IceFrameMode.Gr13Gtia11);
			GtiaColors[8] = content[2] & 0xfe;
			DecodeIceFrame(content, IceFontFrame2, 3 + 1024, frame2, IceFrameMode.Gr13Gtia11);
			break;
		case 26:
			if (contentLength != 10 + 2048)
				return false;
			SetSize(256, 256, RECOILResolution.Xe2x2);
			LeftSkip = 1;
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, IceFontFrame1, 10, frame1, IceFrameMode.Gr13Gtia9);
			SetGtiaColors(content, 1);
			DecodeIceFrame(content, IceFontFrame2, 10 + 1024, frame2, IceFrameMode.Gr13Gtia10);
			break;
		case 27:
			if (contentLength != 10 + 2048)
				return false;
			SetSize(256, 256, RECOILResolution.Xe2x2);
			LeftSkip = 1;
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, IceFontFrame1, 10, frame1, IceFrameMode.Gr13Gtia11);
			GtiaColors[0] = 0x00;
			SetPM123PF0123Bak(content, 2);
			DecodeIceFrame(content, IceFontFrame2, 10 + 1024, frame2, IceFrameMode.Gr13Gtia10);
			break;
		case 28:
			if (contentLength != 3 + 2048)
				return false;
			SetSize(256, 256, RECOILResolution.Xe4x2);
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIceFrame(content, IceFontFrame1, 3, frame1, IceFrameMode.Gr13Gtia9);
			GtiaColors[8] = content[2] & 0xfe;
			DecodeIceFrame(content, IceFontFrame2, 3 + 1024, frame2, IceFrameMode.Gr13Gtia11);
			break;
		case 31:
			if (contentLength != 8 + 1024)
				return false;
			SetSize(256, 288, RECOILResolution.Xe4x1);
			LeftSkip = 2;
			const byte[7] ice20Gtia11Colors = { 0, 1, 2, 3, 5, 7, 8 };
			for (int i = 0; i < 7; i++)
				SetGtiaColor(ice20Gtia11Colors[i], content[1 + i]);
			DecodeIce20Frame(content, false, 8, frame1, 10);
			DecodeIce20Frame(content, true, 8 + 512, frame2, 10);
			break;
		case 32:
			if (contentLength != 14 + 1024)
				return false;
			SetSize(256, 288, RECOILResolution.Xe4x1);
			LeftSkip = 2;
			GtiaColors[0] = content[1] & 0xfe;
			for (int i = 1; i < 7; i++)
				SetGtiaColor(ice20Gtia11Colors[i], content[i * 2]);
			DecodeIce20Frame(content, false, 14, frame1, 10);
			for (int i = 1; i < 7; i++)
				SetGtiaColor(ice20Gtia11Colors[i], content[1 + i * 2]);
			DecodeIce20Frame(content, true, 14 + 512, frame2, 10);
			break;
		case 33:
			if (contentLength != 3 + 1024)
				return false;
			SetSize(256, 288, RECOILResolution.Xe4x1);
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIce20Frame(content, false, 3, frame1, 9);
			GtiaColors[8] = content[2] & 0xfe;
			DecodeIce20Frame(content, true, 3 + 512, frame2, 9);
			break;
		case 34:
			if (contentLength != 3 + 1024)
				return false;
			SetSize(256, 288, RECOILResolution.Xe4x1);
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIce20Frame(content, false, 3, frame1, 11);
			GtiaColors[8] = content[2] & 0xfe;
			DecodeIce20Frame(content, true, 3 + 512, frame2, 11);
			break;
		case 35:
			if (contentLength != 8 + 1024)
				return false;
			SetSize(256, 288, RECOILResolution.Xe2x1);
			LeftSkip = 1;
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIce20Frame(content, false, 8, frame1, 9);
			for (int i = 0; i < 7; i++)
				SetGtiaColor(ice20Gtia11Colors[i], content[1 + i]);
			DecodeIce20Frame(content, true, 8 + 512, frame2, 10);
			break;
		case 36:
			if (contentLength != 8 + 1024)
				return false;
			SetSize(256, 288, RECOILResolution.Xe2x1);
			LeftSkip = 1;
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIce20Frame(content, false, 8, frame1, 11);
			GtiaColors[0] = 0;
			for (int i = 1; i < 7; i++)
				SetGtiaColor(ice20Gtia11Colors[i], content[1 + i]);
			DecodeIce20Frame(content, true, 8 + 512, frame2, 10);
			break;
		case 37:
			if (contentLength != 3 + 1024)
				return false;
			SetSize(256, 288, RECOILResolution.Xe4x1);
			GtiaColors[8] = content[1] & 0xfe;
			DecodeIce20Frame(content, false, 3, frame1, 9);
			GtiaColors[8] = content[2] & 0xfe;
			DecodeIce20Frame(content, true, 3 + 512, frame2, 11);
			break;
		default:
			return false;
		}
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeIp2!(byte[] content, int contentLength)
	{
		if (contentLength != 17358 || content[0] != 1)
			return false;
		SetSize(320, 192, RECOILResolution.Xe2x1);
		GtiaColors[8] = content[1] & 0xfe;
		GtiaColors[4] = content[5] & 0xfe;
		GtiaColors[5] = content[7] & 0xfe;
		GtiaColors[6] = content[9] & 0xfe;
		GtiaColors[7] = content[11] & 0xfe;
		byte[320 * 192] frame1;
		DecodeIceFrame(content, 14 + 16384, 14, frame1, IceFrameMode.Gr12);
		LeftSkip = 2; // see the comment in DecodeAtari8Ice
		for (int i = 0; i < 4; i++) {
			GtiaColors[i] = content[1 + i] & 0xfe;
			SetGtiaColor(4 + i, content[6 + i * 2]);
		}
		SetGtiaColor(8, content[13]);
		byte[320 * 192] frame2;
		DecodeIceFrame(content, 14 + 16384, 14 + 1024, frame2, IceFrameMode.Gr0Gtia10);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	void DecodeAtari8RgbScreen!(byte[] screens, int screensOffset, int color, byte[]! frame)
	{
		if (Resolution == RECOILResolution.Xe4x1) {
			GtiaColors[8] = color;
			DecodeAtari8Gr9(screens, screensOffset, 40, frame, 0, Width, Width, Height);
		}
		else {
			GtiaColors[8] = 0x00;
			GtiaColors[4] = color | 4;
			GtiaColors[5] = color | 0xa;
			GtiaColors[6] = color | 0xe;
			DecodeAtari8Gr15(screens, screensOffset, 40, frame, 0, Width, Height);
		}
	}

	bool DecodeAtari8Rgb!(byte[] content, int contentLength)
	{
		if (contentLength < 9 || !IsStringAt(content, 0, "RGB1"))
			return false;
		int titleLength = content[4];
		if (contentLength < 9 + titleLength)
			return false;
		int width = content[6 + titleLength];
		int height = content[7 + titleLength];
		if (width == 0 || (width & 1) != 0 || width > 80 || height == 0 || height > 192 || content[8 + titleLength] != 1)
			return false;
		switch (content[5 + titleLength]) {
		case 9:
			SetSize(width << 2, height, RECOILResolution.Xe4x1);
			break;
		case 15:
			SetSize(width << 2, height, RECOILResolution.Xe2x1);
			break;
		default:
			return false;
		}

		int[192] leftRgbs;
		byte[3 * 40 * 192] screens;
		RgbStream() rle;
		rle.Content = content;
		rle.ContentOffset = 9 + titleLength;
		rle.ContentLength = contentLength;
		for (int x = 0; x < width; x++) {
			for (int y = 0; y < height; y++) {
				int rgb = rle.ReadRle();
				if (rgb < 0)
					return false;
				if ((x & 1) == 0)
					leftRgbs[y] = rgb;
				else {
					int leftRgb = leftRgbs[y];
					int screenOffset = y * 40 + (x >> 1);
					screens[screenOffset] = (leftRgb >> 4 & 0xf0) | (rgb >> 8);
					screens[40 * 192 + screenOffset] = (leftRgb & 0xf0) | (rgb >> 4 & 0x0f);
					screens[2 * 40 * 192 + screenOffset] = (leftRgb << 4 & 0xf0 | rgb & 0x0f);
				}
			}
		}

		byte[320 * 192] frame1;
		DecodeAtari8RgbScreen(screens, 0, 0x30, frame1);
		byte[320 * 192] frame2;
		DecodeAtari8RgbScreen(screens, 40 * 192, 0xc0, frame2);
		byte[320 * 192] frame3;
		DecodeAtari8RgbScreen(screens, 2 * 40 * 192, 0x70, frame3);
		return ApplyAtari8PaletteBlend3(frame1, frame2, frame3);
	}

	bool DrawBlazingPaddlesVector(byte[] content, int contentLength, byte[]! frame, int frameOffset, int index, int startAddress)
	{
		if (index * 2 + 1 >= contentLength)
			return false;
		int contentOffset = content[index * 2] + (content[index * 2 + 1] << 8) - startAddress;
		if (contentOffset < 0)
			return false;
		while (contentOffset < contentLength) {
			int control = content[contentOffset++];
			if (control == 0x08)
				return true;
			// bits 7-4: length-1
			for ( ; control >= 0; control -= 16) {
				// bit 2: pen up
				if ((control & 4) == 0)
					frame[frameOffset + 1] = frame[frameOffset] = 0x0e;
				// bits 1-0: direction
				switch (control & 3) {
				case 0: // right
					frameOffset += 2;
					break;
				case 1: // left
					frameOffset -= 2;
					break;
				case 2: // up
					frameOffset -= Width;
					break;
				case 3: // down
					frameOffset += Width;
					break;
				default:
					assert false;
				}
			}
		}
		return false;
	}

	bool DecodeBlazingPaddlesVectors!(byte[] content, int contentLength, int startAddress)
	{
		// The file contains several independent shapes.
		// I layout them in reading order, so that they don't overlap,
		// the baselines are aligned and everything fits in 160x240.
		int x = 0;
		int y = 0;
		int i;
		int lineI = 0;
		int lineTop = 0;
		int lineBottom = 0;
		int[256] xs;
		int[256] ys;

		int width = 0;
		BlazingPaddlesBoundingBox() box;
		for (i = 0; i < 256; i++) {
			if (!box.Calculate(content, contentLength, i, startAddress))
				break;
			int shapeWidth = box.Right - box.Left + 2; // +1 because box.right is inclusive, +1 for space
			if (x + shapeWidth > 160) {
				// new line
				y -= lineTop;
				while (lineI < i)
					ys[lineI++] = y;
				if (width < x)
					width = x;
				x = 0;
				y += lineBottom + 2; // +1 because box.bottom is inclusive, +1 for space
				lineTop = box.Top;
				lineBottom = box.Bottom;
			}
			// place this shape at x,y
			xs[i] = x - box.Left;
			x += shapeWidth;
			if (lineTop > box.Top)
				lineTop = box.Top;
			if (lineBottom < box.Bottom)
				lineBottom = box.Bottom;
		}
		y -= lineTop;
		while (lineI < i)
			ys[lineI++] = y;
		if (width < x)
			width = x;
		y += lineBottom + 1; // +1 because box.bottom is inclusive
		if (i == 0 || y > 240)
			return false;

		// draw shapes
		SetSize(width << 1, y, RECOILResolution.Xe2x1);
		byte[320 * 240] frame = 0;
		for (i = 0; i < 256; i++) {
			if (!DrawBlazingPaddlesVector(content, contentLength, frame, (ys[i] * width + xs[i]) * 2, i, startAddress))
				break;
		}

		return ApplyAtari8Palette(frame);
	}

	bool DecodeChr!(byte[] content, int contentLength)
		=> contentLength == 3072 && DecodeBlazingPaddlesVectors(content, contentLength, 0x7000);

	bool DecodeShp!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 1024:
			return DecodeBlazingPaddlesVectors(content, contentLength, 0x7c00);
		case 4384:
			return DecodeGr7(content, 0x210, 3844);
		default:
			return false;
		}
	}

	static void DrawSpcChar(byte[]! pixels, int x1, int y1, int ch)
	{
		// The original program can print garbage from ROM.
		// We don't have the ROM, so just skip these characters.
		// FIXME: check lowercase and semigraphic.
		if (ch < 0x20 || ch > 0x5f)
			return;

		byte[] font = resource<byte[]>("atari8.fnt");
		int fontOffset = (ch - 0x20) << 3;
		for (int y = 0; y < 8 && y1 + y < 192; y++) {
			for (int x = 0; x < 4 && x1 + x < 160; x++)
				pixels[(y1 + y) * 160 + x1 + x] = font[fontOffset + y] >> (6 - x * 2) & 3;
		}
	}

	static void DrawSpcLine(byte[]! pixels, int x1, int y1, int x2, int y2, int color)
	{
		int dx = x2 - x1;
		int dy = y2 - y1;
		// FIXME: I do standard Bresenham's algorithm here,
		// but the original program does something strange involving division of dx/dy.

		// The original draws right or down, so I try it too.
		if (dx < 0)
			dx = -dx;
		if (dy < 0)
			dy = -dy;
		if (dx >= dy) {
			int e = dx;
			if (x2 < x1) {
				// swap points to draw right
				int ty = y1;
				x1 = x2;
				x2 += dx;
				y1 = y2;
				y2 = ty;
			}
			for ( ; x1 <= x2; x1++) {
				if (x1 < 160 && y1 < 192)
					pixels[160 * y1 + x1] = color;
				e -= dy * 2;
				if (e < 0) {
					e += dx * 2;
					y1 += y1 < y2 ? 1 : -1;
				}
			}
		}
		else {
			int e = dy;
			if (y2 < y1) {
				// swap points to draw down
				int tx = x1;
				x1 = x2;
				x2 = tx;
				y1 = y2;
				y2 += dy;
			}
			for ( ; y1 <= y2; y1++) {
				if (x1 < 160 && y1 < 192)
					pixels[160 * y1 + x1] = color;
				e -= dx * 2;
				if (e < 0) {
					e += dy * 2;
					x1 += x1 < x2 ? 1 : -1;
				}
			}
		}
	}

	static void PlotSpcPattern(byte[]! pixels, int x, int y, int pattern)
	{
		pixels[y * 160 + x] = pattern >> ((~y & 1) * 8 + (~x & 3) * 2) & 3;
	}

	static void DrawSpcBrush(byte[]! pixels, int x1, int y1, int brush, int pattern)
	{
		const byte[8 * 16] brushes = {
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x10, 0x38, 0x38, 0x7c, 0x7c, 0x7c, 0x7c, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x18, 0x18, 0x3c, 0x3c, 0x7e, 0x7e, 0x7e, 0x7e, 0x3c, 0x3c, 0x18, 0x18, 0x00, 0x00, 0x00,
			0x10, 0x38, 0x7c, 0x7c, 0x7c, 0xfe, 0xfe, 0xfe, 0xfe, 0x7c, 0x7c, 0x7c, 0x38, 0x10, 0x00, 0x00,
			0x00, 0x00, 0x10, 0x28, 0x28, 0x50, 0x3c, 0x78, 0x14, 0x28, 0x28, 0x10, 0x00, 0x00, 0x00, 0x00,
			0x10, 0x28, 0x54, 0x28, 0x54, 0xba, 0x7c, 0x7c, 0xba, 0x54, 0x28, 0x54, 0x28, 0x10, 0x00, 0x00
		};
		for (int y = 0; y < 16 && y1 + y < 192; y++) {
			int brushShape = brushes[brush * 16 + y];
			for (int x = 0; x < 8 && x1 + x < 160; x++) {
				if ((brushShape >> (7 - x) & 1) != 0)
					PlotSpcPattern(pixels, x, y, pattern);
			}
		}
	}

	static bool FillSpc(byte[]! pixels, int x, int y, int pattern)
	{
		if (x >= 160 || y >= 192)
			return false;
		// This is NOT real flood fill.
		while (y >= 0 && pixels[y * 160 + x] == 0)
			y--;
		while (++y < 192 && pixels[y * 160 + x] == 0) {
			do
				x--;
			while (x >= 0 && pixels[y * 160 + x] == 0);
			int x1 = x;
			while (x < 159) {
				if (pixels[y * 160 + ++x] != 0)
					break;
				PlotSpcPattern(pixels, x, y, pattern);
			}
#if true
			// the original program seems to do this
			// FIXME: probably different if borders reached
			x = x1 + ((x - x1 + 1) >> 1);
#else
			// simpler, but different from above I guess
			x -= (x - x1) >> 1;
#endif
		}
		return true;
	}

	bool DecodeAtari8Spc!(byte[] content, int contentLength)
	{
		if (contentLength < 3
		 || contentLength != content[0] + (content[1] << 8) + 3
		 || content[contentLength - 1] != 0)
			return false;

		byte[160 * 192] pixels = 0;
		int[96] lineColors = 0;
		int textX = 0;
		int textY = 0;
		int lineX = 0;
		int lineY = 0;
		int brush = 0;
		int pattern = 0x2288;
		int lineColor = 3;
		int x;
		int y;
		for (int contentOffset = 2; content[contentOffset] != 0; ) {
			switch (content[contentOffset]) {
			case 0x10:
				if (contentOffset + 3 >= contentLength)
					return false;
				textX = content[contentOffset + 1];
				textY = content[contentOffset + 2];
				contentOffset += 3;
				break;
			case 0x20:
			case 0x21:
			case 0x22:
			case 0x23:
				if (contentOffset + 1 >= contentLength)
					return false;
				lineColor = content[contentOffset] & 3;
				contentOffset++;
				break;
			case 0x30:
			case 0x50:
				if (contentOffset + 2 >= contentLength)
					return false;
				DrawSpcChar(pixels, textX, textY, content[contentOffset + 1]);
				textX += 4;
				contentOffset += 2;
				break;
			case 0x40:
			case 0x41:
			case 0x42:
			case 0x43:
			case 0x44:
			case 0x45:
			case 0x46:
			case 0x47:
				if (contentOffset + 1 >= contentLength)
					return false;
				brush = content[contentOffset] & 7;
				contentOffset++;
				break;
			case 0x60:
				if (contentOffset + 2 >= contentLength)
					return false;
				pattern = content[contentOffset + 1];
				const int[] patterns = { // ushort?
					0x0000, 0x5555, 0xaaaa, 0xffff, 0x1144, 0x2288, 0x33cc, 0x6699,
					0x77dd, 0xbbee, 0x1551, 0x2aa2, 0x3ff3, 0x4004, 0x6aa6, 0x7ff7,
					0x8008, 0x9559, 0xbffb, 0xc00c, 0xd55d, 0xeaae, 0x5588, 0x22cc,
					0x3344, 0x4499, 0x44dd, 0x7799, 0x88ee, 0x8866, 0x99ee, 0xcc77,
					0xccbb, 0xddbb, 0x1bb1, 0x1559, 0x155d, 0x955d, 0x4008, 0x400c,
					0x800c, 0x6aac, 0x2aae, 0x6aa2, 0x7ffb, 0x3ffb, 0xbff7, 0x5584,
					0x22c4, 0x3348, 0x4491, 0x44d1, 0x7791, 0x88e2, 0x8862, 0x99e1,
					0xcc73, 0xccb3, 0xddb3, 0x558c, 0x22c8, 0x334c, 0x449d, 0x44d9,
					0x779d, 0x88e6, 0x886e, 0x99e5, 0xcc7b, 0xccb7, 0xddb7
				};
				if (pattern >= patterns.Length)
					return false;
				pattern = patterns[pattern];
				contentOffset += 2;
				break;
			case 0x70:
				if (contentOffset + 7 >= contentLength)
					return false;
				for (y = content[contentOffset + 1]; y <= content[contentOffset + 2]; y++) {
					if (y >= 96)
						return false;
					lineColors[y] = contentOffset + 3;
				}
				contentOffset += 7;
				break;
			case 0x80:
				if (contentOffset + 3 >= contentLength)
					return false;
				lineX = content[contentOffset + 1];
				lineY = content[contentOffset + 2];
				contentOffset += 3;
				break;
			case 0xa0:
				if (contentOffset + 3 >= contentLength)
					return false;
				x = content[contentOffset + 1];
				y = content[contentOffset + 2];
				DrawSpcLine(pixels, lineX, lineY, x, y, lineColor);
				lineX = x;
				lineY = y;
				contentOffset += 3;
				break;
			case 0xc0:
				if (contentOffset + 3 >= contentLength)
					return false;
				DrawSpcBrush(pixels, content[contentOffset + 1], content[contentOffset + 2], brush, pattern);
				contentOffset += 3;
				break;
			case 0xe0:
				if (contentOffset + 3 >= contentLength)
					return false;
				if (!FillSpc(pixels, content[contentOffset + 1], content[contentOffset + 2], pattern))
					return false;
				contentOffset += 3;
				break;
			default:
				return false;
			}
		}

		SetSize(320, 192, RECOILResolution.Xe2x1);
		byte[320 * 192] frame;
		for (y = 0; y < 192; y++) {
			const byte[4] defaultColors = { 0x00, 0x15, 0x95, 0x36 };
			int colorsOffset = lineColors[y >> 1];
			byte[] colors = colorsOffset == 0 ? defaultColors : content;
			for (x = 0; x < 160; x++) {
				int offset = y * 320 + x * 2;
				frame[offset + 1] = frame[offset] = colors[colorsOffset + pixels[y * 160 + x]] & 0xfe;
			}
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeHcm!(byte[] content, int contentLength)
	{
		if (contentLength != 8208 || !IsStringAt(content, 0, "HCMA8") || content[5] != 1)
			return false;
		HcmRenderer() gtia;
		int leftSprite;
		switch (content[6]) {
		case 0:
			leftSprite = 2;
			gtia.Prior = 0x00;
			break;
		case 2:
			leftSprite = 1;
			gtia.Prior = 0x24;
			break;
		default:
			return false;
		}
		gtia.PlayerHpos[3] = gtia.PlayerHpos[3 - leftSprite] = 0x68;
		gtia.MissileHpos[leftSprite] = gtia.MissileHpos[0] = 0x88;
		gtia.MissileHpos[3] = gtia.MissileHpos[3 - leftSprite] = 0x90;
		for (int i = 0; i < 4; i++)
			gtia.MissileSize[i] = gtia.PlayerSize[i] = 4;
		gtia.Colors[8] = content[7] & 0xfe; // COLBAK
		gtia.Colors[3 - leftSprite] = gtia.Colors[0] = content[8] & 0xfe; // COLPM0, COLPM1/2
		gtia.Colors[3] = gtia.Colors[leftSprite] = content[9] & 0xfe; // COLPM2/1, COLPM3
		gtia.Colors[4] = content[10] & 0xfe; // COLPF0
		gtia.Colors[5] = content[11] & 0xfe; // COLPF1
		gtia.Colors[6] = content[12] & 0xfe; // COLPF2
		gtia.Content = content;
		gtia.PlayfieldColumns = 32;

		SetSize(256, 192, RECOILResolution.Xe2x1);
		byte[256 * 192] frame;
		for (int y = 0; y < 192; y++) {
			gtia.PlayerHpos[leftSprite] = gtia.PlayerHpos[0] = 0x48;
			gtia.ProcessSpriteDma(content, 0x330 + y);
			gtia.StartLine(0x40);
			gtia.DrawSpan(y, 0x40, 0x80, AnticMode.FourColor, frame, 256);
			gtia.PlayerHpos[leftSprite] = gtia.PlayerHpos[0] = 0x98;
			gtia.PlayerGraphics[0] = content[0x30 + y];
			gtia.PlayerGraphics[leftSprite] = content[0x130 + y];
			gtia.DrawSpan(y, 0x80, 0xc0, AnticMode.FourColor, frame, 256);
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeGed!(byte[] content, int contentLength)
	{
		if (contentLength != 11302
		 || content[0] != 0xff || content[1] != 0xff || content[2] != 0x30 || content[3] != 0x53 || content[4] != 0x4f || content[5] != 0x7f)
			return false;
		int cycle = content[0xcd6 + 14];
		if (cycle > 7)
			return false;

		GedRenderer() gtia;
		GtiaRenderer.SetSpriteSizes(gtia.MissileSize, content[0xcd6 + 5]); // SIZEM
		gtia.Colors[7] = content[0xcd6 + 7] & 0xfe; // COLPF3
		gtia.Colors[8] = content[0xcd6 + 8] & 0xfe; // COLBAK
		int prior = content[0xcd6 + 6];
		gtia.Prior = prior; // PRIOR
		for (int i = 0; i < 4; i++) {
			gtia.SetPlayerSize(i, content[0xcd6 + 4] >> (3 - i << 1)); // SIZEP0-3
			gtia.PlayerHpos[i] = (0x30 + content[0xcd6 + 9 + i]) & 0xff; // HPOSP0-3
			gtia.MissileHpos[i] = ((prior & 0x10) == 0 ? gtia.PlayerHpos[i] + (gtia.PlayerSize[i] << 3)
				: i == 0 ? 0x30 + content[0xcd6 + 13] : gtia.MissileHpos[i - 1] + (gtia.MissileSize[i - 1] << 1)) & 0xff; // HPOSM0-3
			gtia.Colors[i] = content[0xcd6 + i] & 0xfe; // COLPM0-3
		}

		gtia.Content = content;
		gtia.PlayfieldColumns = 40;
		SetSize(320, 200, RECOILResolution.Xe2x1);
		byte[320 * 200] frame;
		for (int y = 0; y < 200; y++) {
			gtia.ProcessSpriteDma(content, 0x7d6 + 28 + y);
			gtia.Poke(content[206 + y] & 0x1f, content[6 + y]);
			gtia.Colors[4] = content[406 + y] & 0xfe; // COLPF0
			gtia.Colors[5] = content[606 + y] & 0xfe; // COLPF1
			gtia.Colors[6] = content[806 + y] & 0xfe; // COLPF2
			gtia.StartLine(0x30);

			int hpos = gtia.DrawSpan(y, 0x30, 0x30 + 15 + (cycle << 3), AnticMode.FourColor, frame, 320);
			gtia.Colors[4] = content[1006 + y] & 0xfe;
			hpos = gtia.DrawSpan(y, hpos, cycle < 4 ? hpos + 32 : 0x30 + 75 - 16 + (cycle << 2), AnticMode.FourColor, frame, 320);
			gtia.Colors[5] = content[1206 + y] & 0xfe;
			hpos = gtia.DrawSpan(y, hpos, 0x30 + 75 + (cycle << 2), AnticMode.FourColor, frame, 320);
			gtia.Colors[6] = content[1406 + y] & 0xfe;
			hpos = gtia.DrawSpan(y, hpos, hpos + 24, AnticMode.FourColor, frame, 320);
			gtia.Colors[4] = content[1606 + y] & 0xfe;
			hpos = gtia.DrawSpan(y, hpos, hpos + 24, AnticMode.FourColor, frame, 320);
			gtia.Colors[5] = content[1806 + y] & 0xfe;
			gtia.DrawSpan(y, hpos, 0xd0, AnticMode.FourColor, frame, 320);
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodePgr!(byte[] content, int contentLength)
	{
		if (contentLength < 1776
		 || 6 + ParseAtari8ExecutableHeader(content, 0) != contentLength
		 || content[2] != 6 || content[3] != 0x82
		 || !IsStringAt(content, 8, "PowerGFX"))
			return false;
		PgrRenderer() gtia;
		for (int i = 0; i < 14; i++) {
			gtia.Poke(i, content[0x1f8 + i]);
			gtia.Poke(14 + i, content[0x2f8 + i]);
		}
		gtia.Content = content;
		int dmaCtl = content[0x306];
		switch (dmaCtl & 0xf3) {
		case 0x31:
			gtia.PlayfieldColumns = 32;
			break;
		case 0x32:
			gtia.PlayfieldColumns = 40;
			break;
		default:
			return false;
		}

		int dlOffset = 0x10;
		int rasterOffset = content[6] + (content[7] << 8) - 0x8200;
		if (rasterOffset < 0x600)
			return false;
		gtia.ScreenOffset = -1;
		int a = 0;
		byte[336 * 240] frame;
		RECOILResolution resolution = RECOILResolution.Xe4x1;
		for (int y = 0; y < 240; y++) {
			int hpos = -11;
			int dlOp = content[dlOffset++];
			switch (dlOp) {
			case 0x00:
			case 0x0e:
			case 0x0f:
				break;
			case 0x41:
				dlOffset--; // FIXME: DMA once
				break;
			case 0x4e:
			case 0x4f:
				hpos += 2 * 2; // DL LMS DMA
				gtia.ScreenOffset = content[dlOffset] + (content[dlOffset + 1] << 8) - 0x8200;
				dlOffset += 2;
				break;
			default:
				return false;
			}

			AnticMode anticMode;
			switch (dlOp & 0xf) {
			case 0xe:
				anticMode = AnticMode.FourColor;
				if (resolution == RECOILResolution.Xe4x1 && gtia.Prior < 0x40)
					resolution = RECOILResolution.Xe2x1;
				break;
			case 0xf:
				anticMode = AnticMode.HiRes;
				if (gtia.Prior < 0x40)
					resolution = RECOILResolution.Xe1x1;
				break;
			default:
				anticMode = AnticMode.Blank;
				break;
			}

			if (anticMode != AnticMode.Blank
			 && (gtia.ScreenOffset < 0x600 || gtia.ScreenOffset + 40 > contentLength))
				return false;
			gtia.StartLine(0x2c);
			if ((dmaCtl & 0xc) != 0) {
				hpos += 2; // missile DMA
				if ((dmaCtl & 4) != 0)
					gtia.MissileGraphics = content[0x108 + y];
				if ((dmaCtl & 8) != 0) {
					hpos += 4 * 2; // player DMA
					for (int i = 0; i < 4; i++)
						gtia.PlayerGraphics[i] = content[0x208 + (i << 8) + y];
				}
			}

			for (int cpuCycles = 1;;) {
				if (rasterOffset >= contentLength)
					return false;
				int rasterOp = content[rasterOffset++];
				if ((rasterOp & 0x20) != 0) {
					if (rasterOffset >= contentLength)
						return false;
					cpuCycles += 2; // LDA #
					a = content[rasterOffset++];
				}
				int addr = rasterOp & 0x1f;
				if (addr <= 0x1b) {
					int untilHpos = hpos;
					for (;;) {
						untilHpos += 2;
						int x = untilHpos - 118 >> 1;
						if ((x & 1) != 0
							? anticMode != AnticMode.Blank && x >= -gtia.PlayfieldColumns && x < gtia.PlayfieldColumns // screen DMA
							: x >= -36 && x < 0 && (x & 2) != 0) { // memory refresh
							// DMA cycle
						}
						else if (--cpuCycles == 0)
							break;
					}
					gtia.DrawSpan(y, hpos >= 0x2c ? hpos : 0x2c, untilHpos < 0xd4 ? untilHpos : 0xd4, anticMode, frame, 336);
					hpos = untilHpos;
					gtia.Poke(addr, a);
					if (rasterOp >= 0x80)
						break;
					cpuCycles = 4; // STA $D0xx
				}
				else {
					int nops = (rasterOp >> 6 & 3) | (rasterOp & 3) << 2;
					if (nops == 0)
						break;
					cpuCycles += nops << 1; // :nops NOP
				}
			}

			gtia.DrawSpan(y, hpos >= 0x2c ? hpos : 0x2c, 0xd4, anticMode, frame, 336);
			if (anticMode != AnticMode.Blank)
				gtia.ScreenOffset += gtia.PlayfieldColumns;
		}
		SetSize(336, 240, resolution);
		return ApplyAtari8Palette(frame);
	}

	static bool HasG2fRaster(byte[] content, int contentOffset, int count, int hitClr)
	{
		do {
			switch (content[contentOffset]) {
			case 0: // NOP
			case 1: // LDA #
			case 2: // LDX #
			case 3: // LDY #
			case 0x41: // LDA zp
			case 0x42: // LDX zp
			case 0x43: // LDY zp
			case 0x61: // LDA abcd
			case 0x62: // LDX abcd
			case 0x63: // LDY abcd
				break;
			case 0x81: // STA
			case 0x82: // STX
			case 0x83: // STY
				if (content[contentOffset + 1] != hitClr)
					return true;
				break;
			default: // unexpected
				return true;
			}
			contentOffset += 2;
		} while (--count > 0);
		return false;
	}

	bool DecodeMch!(byte[] content, int contentLength)
	{
		int columns;
		switch (contentLength) {
		case 30 * 32 * 9 + 5 * 240:
		case 30 * 32 * 9 + 20 * 240 + 5 * 256 + 240 * 29 * 2 + 1 + 32:
			columns = 32;
			break;
		case 30 * 40 * 9 + 5 * 240: // 12000
		case 30 * 40 * 9 + 20 * 240 + 5 * 256 + 240 * 29 * 2 + 1 + 32: // 30833
			columns = 40;
			break;
		case 30 * 48 * 9 + 5 * 240:
		case 30 * 48 * 9 + 20 * 240 + 5 * 256 + 240 * 29 * 2 + 1 + 32:
			columns = 48;
			break;
		default:
			return false;
		}
		int bitmapLength = columns * (30 * 9);
		bool sprites = contentLength > bitmapLength + 5 * 240;
		AnticMode anticMode;
		switch (content[0] & 3) {
		case 0: // GED+
			if (sprites && HasG2fRaster(content, bitmapLength + (20 * 240 + 5 * 256), 240 * 29, 0x1e))
				return false;
			anticMode = AnticMode.FiveColor;
			break;
		case 1: // DLI
			anticMode = AnticMode.FiveColor;
			break;
		case 2: // GED-
			if (sprites && HasG2fRaster(content, bitmapLength + (20 * 240 + 5 * 256), 240 * 29, 0x1e))
				return false;
			anticMode = AnticMode.FourColor;
			break;
		default: // TODO: PGR
			return false;
		}
		RECOILResolution resolution;
		int gtiaMode = 0;
		switch (content[0] & 0x3c) {
		case 0:
			anticMode = AnticMode.HiRes;
			resolution = RECOILResolution.Xe1x1;
			break;
		case 4:
			resolution = RECOILResolution.Xe2x1;
			break;
		case 8:
			anticMode = AnticMode.HiRes;
			resolution = RECOILResolution.Xe4x1;
			gtiaMode = 0x40;
			break;
		case 0x18:
			anticMode = AnticMode.HiRes;
			resolution = RECOILResolution.Xe4x1;
			gtiaMode = 0x80;
			break;
		case 0x28:
			anticMode = AnticMode.HiRes;
			resolution = RECOILResolution.Xe4x1;
			gtiaMode = 0xc0;
			break;
		default:
			return false;
		}
		SetSize(336, 240, resolution);
		byte[336 * 240] frame;
		MchRenderer() gtia;
		gtia.PlayerHpos.Fill(0);
		gtia.MissileHpos.Fill(0);
		gtia.Colors.Fill(0);
		gtia.Prior = gtiaMode;
		gtia.Content = content;
		gtia.PlayfieldColumns = columns;
		gtia.DliPlus = false;
		for (int i = 0; i < bitmapLength; i += 9) {
			if ((content[i] & 0x40) != 0) {
				gtia.DliPlus = true;
				break;
			}
		}

		for (int y = 0; y < 240; y++) {
			int colorsOffset = bitmapLength + y;
			gtia.SetG2fColors(colorsOffset, 240, sprites ? 9 : 5, gtiaMode);
			if (sprites) {
				for (int i = 0; i < 4; i++) {
					gtia.PlayerHpos[i] = content[colorsOffset + (9 + i) * 240];
					gtia.MissileHpos[i] = content[colorsOffset + (13 + i) * 240];
				}
				GtiaRenderer.SetSpriteSizes(gtia.PlayerSize, content[colorsOffset + 17 * 240]);
				GtiaRenderer.SetSpriteSizes(gtia.MissileSize, content[colorsOffset + 18 * 240]);
				gtia.Prior = gtiaMode | content[colorsOffset + 19 * 240];
				gtia.ProcessSpriteDma(content, colorsOffset + 20 * 240);
			}

			gtia.StartLine(0x2c);
			gtia.DrawSpan(y, 0x2c, 0xd4, anticMode, frame, 336);
		}
		return ApplyAtari8Palette(frame);
	}

	static bool G2fHasRaster(byte[] content, int contentOffset)
		=> HasG2fRaster(content, contentOffset, 240 * 12, content[0] < 0x80 ? 0x16 : 0x1e);

	bool DecodeG2fUnpacked!(byte[] content, int contentLength)
	{
		const int modeOffset = 30 + 33 * 256 + 2 * 240 * 290 + 256 + 240 * 24;
		if (contentLength < 3 + 30 * 32 + 1024 + modeOffset + 30)
			return false;
		int columns = content[0] & 0x7f;
		switch (columns) {
		case 32:
		case 40:
		case 48:
			break;
		default:
			return false;
		}
		int fontsOffset = 3 + 30 * columns;
		int fontNumberOffset = fontsOffset + ((content[2] & 0x7f) + 1 << 10);
		if (contentLength < fontNumberOffset + (modeOffset + 30))
			return false;
		bool charMode;
		int vbxeOffset = fontNumberOffset + (modeOffset + 256 + 1 + 5 * 256);
		int inverse2Offset = -1;
		switch (content[fontNumberOffset + (30 + 33 * 256 + 2 * 240 * 290 + 1)] & 0x7f) {
		case 1: // GED+
			if (G2fHasRaster(content, fontNumberOffset + (30 + 33 * 256 + 2 * 240 * 290 + 256)))
				return false;
			charMode = true;
			break;
		case 2: // DLI
			charMode = true;
			break;
		case 3: // GED-
			if (G2fHasRaster(content, fontNumberOffset + (30 + 33 * 256 + 2 * 240 * 290 + 256)))
				return false;
			charMode = false;
			break;
		case 0x42: // DLI+
			charMode = true;
			inverse2Offset = vbxeOffset + (3 + 48 * 240 * 12 + 1);
			if (contentLength < inverse2Offset + 30 * columns)
				return false;
			break;
		default: // TODO: PGR
			return false;
		}
		RECOILResolution resolution = RECOILResolution.Xe4x1;

		if (contentLength < vbxeOffset + (3 + 48 * 240 * 12))
			vbxeOffset = -1;
		else {
			switch (content[vbxeOffset]) {
			case 0:
				vbxeOffset = -1;
				break;
			case 1:
				if (content[vbxeOffset + 1] != 8 // TODO: different color map widths
				 || content[vbxeOffset + 2] == 0)
					return false;
				resolution = RECOILResolution.Vbxe2x1;
				break;
			default:
				return false;
			}
		}

		byte[336 * 240] frame;
		G2fRenderer() gtia;
		gtia.Content = content;
		gtia.PlayfieldColumns = columns;
		gtia.Inverse2Offset = inverse2Offset;
		gtia.VbxeOffset = vbxeOffset;
		for (int y = 0; y < 240; y++) {
			int row = y >> 3;
			gtia.FontOffset = fontsOffset + ((content[fontNumberOffset + row] & 0x7f) << 10);
			if (gtia.FontOffset >= fontNumberOffset)
				return false;

			int spriteOffset = fontNumberOffset + (30 + 9 * 256) + (y << 1);
			int prior = content[spriteOffset + 1] >> 4 & 7;
			const byte[] priors = { 4, 2, 1, 8, 0 };
			if (prior >= priors.Length)
				return false;
			prior = priors[prior] | (content[spriteOffset + 1025] & 0x30);

			AnticMode anticMode;
			switch (content[fontNumberOffset + modeOffset + row]) {
			case 1:
				resolution = resolution == RECOILResolution.Vbxe2x1 || resolution == RECOILResolution.Vbxe1x1 ? RECOILResolution.Vbxe1x1 : RECOILResolution.Xe1x1;
				anticMode = AnticMode.HiRes;
				break;
			case 2:
				if (resolution == RECOILResolution.Xe4x1)
					resolution = RECOILResolution.Xe2x1;
				anticMode = charMode ? AnticMode.FiveColor : AnticMode.FourColor;
				break;
			case 4:
				// TODO: RECOILResolution.Xe2x1 if sprites?
				const byte[8] gtiaModes = { 0x40, 0x40, 0x40, 0x40, 0x40, 0x80, 0xc0, 0x40 };
				prior |= gtiaModes[content[1] & 7];
				anticMode = AnticMode.HiRes;
				break;
			case 0xff:
				anticMode = AnticMode.Blank;
				break;
			default:
				return false;
			}

			int colorsOffset = fontNumberOffset + 30 + y;
			gtia.SetG2fColors(colorsOffset, 256, 9, prior);
			int missileGraphics = 0;
			for (int i = 0; i < 4; i++) {
				if (!G2fRenderer.SetSprite(gtia.PlayerHpos, gtia.PlayerSize, i, content, spriteOffset)
				 || !G2fRenderer.SetSprite(gtia.MissileHpos, gtia.MissileSize, i, content, spriteOffset + 512))
					return false;
				gtia.PlayerGraphics[i] = content[colorsOffset + 0x1900 + (i << 9)];
				missileGraphics |= content[colorsOffset + 0x1a00 + (i << 9)] >> 6 << (i << 1);
			}
			gtia.MissileGraphics = missileGraphics;
			gtia.Prior = prior;

			gtia.StartLine(0x2c);
			gtia.DrawSpan(y, 0x2c, 0xd4, anticMode, frame, 336);
		}
		SetSize(336, 240, resolution);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeG2f!(byte[] content, int contentLength)
	{
		if (contentLength < 11)
			return false;
		if (IsStringAt(content, 0, "G2FZLIB")) {
			const int maxUnpackedLength = 3 + 30 * 48 + 30 * 1024 + 30 + 33 * 256 + 2 * 240 * 290 + 256 + 240 * 24
				+ 256 + 1 + 5 * 256 + 3 + 48 * 240 * 12 + 1 + 30 * 48;
			byte[]# unpacked = new byte[maxUnpackedLength];
			InflateStream() stream;
			stream.Content = content;
			stream.ContentOffset = 7;
			stream.ContentLength = contentLength;
			contentLength = stream.Uncompress(unpacked, maxUnpackedLength);
			return DecodeG2fUnpacked(unpacked, contentLength);
		}
		return DecodeG2fUnpacked(content, contentLength);
	}

	bool DecodeDap!(byte[] content, int contentLength)
	{
		if (contentLength != 77568)
			return false;
		SetSize(320, 240, RECOILResolution.Vbxe1x1);
		for (int i = 0; i < 256; i++)
			ContentPalette[i] = content[0x12c00 + i] << 16 | content[0x12d00 + i] << 8 | content[0x12e00 + i];
		DecodeBytes(content, 0);
		return true;
	}

	// Tandy 1000 formats.

	bool DecodeTandyPnt!(byte[] content, int contentLength)
	{
		if (contentLength < 22 + 312 * 176 / 2 / 255 * 2 || content[0] != 0x13 || content[1] != 'P' || content[2] != 'N' || content[3] != 'T')
			return false;
		SetSize(312, 176, RECOILResolution.Tandy1x1);
		const int[16] palette = {
			0x000000, // Black
			0x000099, // Dark Blue
			0x009900, // Dark Green
			0x339999, // Dark Cyan
			0x990000, // Dark Red
			0xcc33cc, // Dark Magenta
			0xcc6600, // Orange
			0x999999, // Light Gray
			0x996633, // Dark Gray
			0x6633ff, // Light Blue
			0x33cc00, // Light Green
			0x66cccc, // Light Cyan
			0xffcccc, // Light Red
			0xff99ff, // Light Magenta
			0xffff00, // Yellow
			0xffffff  // White
		};
		if (contentLength == 22 + 312 * 176 / 2) {
			palette.CopyTo(0, ContentPalette, 0, 16);
			DecodeNibbles(content, 22, 312 / 2);
			return true;
		}
		int contentOffset = 22;
		int repeatCount = 1;
		int repeatValue = 0;
		for (int pixelsOffset = 0; pixelsOffset < 312 * 176; pixelsOffset += 2) {
			if (--repeatCount == 0) {
				if (contentOffset + 1 >= contentLength)
					return false;
				repeatCount = content[contentOffset + 1];
				if (repeatCount == 0)
					return false;
				repeatValue = content[contentOffset];
				contentOffset += 2;
			}
			Pixels[pixelsOffset] = palette[repeatValue >> 4];
			Pixels[pixelsOffset + 1] = palette[repeatValue & 0xf];
		}
		return contentOffset == contentLength;
	}

	// PC formats.

	bool DecodeHs2!(byte[] content, int contentLength)
	{
		if (contentLength % 105 != 0)
			return false;
		return SetSize(840, contentLength / 105, RECOILResolution.Pc1x1)
			&& DecodeBlackAndWhite(content, 0, contentLength, false, 0);
	}

	bool DecodeImage72Fnt!(byte[] content, int contentLength)
	{
		if (contentLength < 4 || content[0] != 0 || content[1] != 8) // TODO: wider fonts
			return false;
		int fontHeight = content[2];
		if (contentLength != 3 + (fontHeight << 8))
			return false;
		SetSize(256, fontHeight << 3, RECOILResolution.Pc1x1);
		DecodeBlackAndWhiteFont(content, 3, contentLength, fontHeight);
		return true;
	}

	bool DecodeMsp!(byte[] content, int contentLength)
	{
		if (contentLength < 32)
			return false;
		int width = content[4] | content[5] << 8;
		int height = content[6] | content[7] << 8;
		if (IsStringAt(content, 0, "DanM")) // Microsoft Paint 1
			return SetSize(width, height, RECOILResolution.Pc1x1)
				&& DecodeBlackAndWhite(content, 32, contentLength, false, 0);
		if (IsStringAt(content, 0, "LinS") && SetSize(width, height, RECOILResolution.Pc1x1)) {
			// Microsoft Paint 2
			MspStream() rle;
			rle.Content = content;
			rle.ContentOffset = 32 + (height << 1);
			rle.ContentLength = contentLength;
			return DecodeRleBlackAndWhite(rle, 0);
		}
		return false;
	}

	bool DecodeAwbmPalette!(byte[] content, int contentLength, int paletteOffset, int colors)
	{
		if (contentLength < paletteOffset + 4 + colors * 3 || !IsStringAt(content, paletteOffset, "RGB "))
			return false;
		for (int i = 0; i < colors; i++) {
			int rgb = GetR8G8B8Color(content, paletteOffset + 4 + i * 3);
			ContentPalette[i] = (rgb & 0x3f3f3f) << 2 | (rgb >> 4 & 0x030303);
		}
		return true;
	}

	bool DecodeAwbm!(byte[] content, int contentLength)
	{
		int width = content[4] | content[5] << 8;
		int height = content[6] | content[7] << 8;
		int planeStride = width + 7 >> 3;
		bool colors256;
		if (DecodeAwbmPalette(content, contentLength, 8 + width * height, 256))
			colors256 = true;
		else if (DecodeAwbmPalette(content, contentLength, 8 + (height * planeStride << 2), 16))
			colors256 = false;
		else
			return false;
		if (!SetSize(width, height, RECOILResolution.Pc1x1))
			return false;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				int c;
				if (colors256)
					c = content[8 + y * width + x];
				else {
					int offset = 8 + (y * planeStride << 2) + (x >> 3);
					c = 0;
					for (int bit = 0; bit < 4; bit++) {
						c |= (content[offset] >> (~x & 7) & 1) << bit;
						offset += planeStride;
					}
				}
				Pixels[y * width + x] = ContentPalette[c];
			}
		}
		return true;
	}

	bool DecodeEpa!(byte[] content, int contentLength)
	{
		if (contentLength < 2 + 15)
			return false;
		if (IsStringAt(content, 0, "AWBM"))
			return DecodeAwbm(content, contentLength);
		int columns = content[0];
		int rows = content[1];
		if (columns > 80 || rows > 25 || contentLength != 2 + columns * rows * 15 + 70)
			return false;
		int width = columns * 8;
		int height = rows * 14;
		SetSize(width, height, RECOILResolution.Pc1x1);
		int bitmapOffset = 2 + columns * rows;
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < width; x++) {
				int ch = y / 14 * columns + (x >> 3);
				int attribute = content[2 + ch];
				int b = content[bitmapOffset + ch * 14 + y % 14] >> (~x & 7) & 1;
				const int[16] palette = {
					0x000000,
					0x0000aa,
					0x00aa00,
					0x00aaaa,
					0xaa0000,
					0xaa00aa,
					0xaa5500,
					0xaaaaaa,
					0x555555,
					0x5555ff,
					0x55ff55,
					0x55ffff,
					0xff5555,
					0xff55ff,
					0xffff55,
					0xffffff
				};
				Pixels[y * width + x] = palette[b == 0 ? attribute >> 4 : attribute & 0xf];
			}
		}
		return true;
	}

	// Electronika BK formats.

	bool DecodeElectronika!(byte[] content)
	{
		SetSize(256, 256, RECOILResolution.Electronika1x1);
		for (int i = 0; i < 256 * 256; i++) {
			const int[4] palette = {
				0x000000,
				0x0000ff,
				0x00ff00,
				0xff0000
			};
			Pixels[i] = palette[content[i >> 2] >> ((i & 3) << 1) & 3];
		}
		return true;
	}

	// Various platform formats.

	bool DecodePi9!(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 7684:
		case 7808:
		case 7936:
			return DecodeGr9(content, 7680);
		case 7720:
			return DecodeApc(content, contentLength);
		default:
			return DecodeFuckpaint(content, contentLength);
		}
	}

	bool DecodePic!(byte[] content, int contentLength)
	{
		if (DecodePsion3Pic(content, contentLength)
		 || DecodeX68KPic(content, contentLength)
		 || DecodeAtari8Koala(content, 0, contentLength))
			return true;

		switch (contentLength) {
		case 4325:
			return DecodeGad(content, contentLength);
		case 7680:
			return DecodeGr8(content, contentLength);
		case 7681:
		case 7682:
		case 7683:
		case 7684:
		case 7685:
			return DecodeMic(null, content, contentLength);
		case 16384:
			return DecodeElectronika(content);
		case 32000:
			return DecodeDoo(content, contentLength);
		case 32768:
			return DecodeAppleIIShr(content, contentLength);
		default:
			return DecodeStPi(content, contentLength)
				|| DecodeSc8(null, content, contentLength);
		}
	}

	bool DecodeScr!(string filename, byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 960:
			return DecodeGr0(content, contentLength);
		case 1002:
			return DecodeScrCol(filename, content, contentLength);
		case 6144:
			SetZx(RECOILResolution.Spectrum1x1);
			DecodeZx(content, 0, -1, ZxAttributesNone, 0);
			return true;
		case 6912:
		case 6913: // border color - ignore
			SetZx(RECOILResolution.Spectrum1x1);
			DecodeZx(content, 0, 0x1800, ZxAttributes8x8, 0);
			return true;
		case 6976:
			SetUlaPlus(content, 0x1b00);
			DecodeZx(content, 0, 0x1800, ZxAttributes8x8, 0);
			return true;
		case 12288:
			SetZx(RECOILResolution.Timex1x1);
			DecodeZx(content, 0, 0x1800, ZxAttributesTimex, 0);
			return true;
		case 12289:
			SetSize(512, 384, RECOILResolution.Timex1x2);
			DecodeTimexHires(content, 0, 0);
			return true;
		case 12352: // untested, based on https://web.archive.org/web/20140315185332/http://www.zxshed.co.uk/sinclairfaq/index.php5?title=ULAplus
			SetUlaPlus(content, 0x3000);
			DecodeZx(content, 0, 0x1800, ZxAttributesTimex, 0);
			return true;
		case 32768:
			return DecodeAppleIIShr(content, contentLength);
		default:
			return DecodeAmstradScr(filename, content, contentLength);
		}
	}

	/// Checks whether the filename extension is supported by RECOIL.
	/// `true` doesn't necessarily mean that the file contents is valid for RECOIL.
	/// With this function you can avoid reading files which are known to be unsupported.
	public static bool IsOurFile(
		/// Name of the file to be checked.
		string filename)
	{
		switch (GetPackedExt(filename)) {
		case PackExt("256"):
		case PackExt("3"):
		case PackExt("3201"):
		case PackExt("4BT"):
		case PackExt("4MI"):
		case PackExt("4PL"):
		case PackExt("4PM"):
		case PackExt("64C"):
		case PackExt("A"):
		case PackExt("A4R"):
		case PackExt("A64"):
		case PackExt("WIG"):
		case PackExt("AAS"):
		case PackExt("IPH"):
		case PackExt("ABK"):
		case PackExt("ACS"):
		case PackExt("AFL"):
		case PackExt("AGP"):
		case PackExt("AGS"):
		case PackExt("ALL"):
		case PackExt("AMI"):
		case PackExt("AN2"):
		case PackExt("AN4"):
		case PackExt("AN5"):
		case PackExt("AP2"):
		case PackExt("AP3"):
		case PackExt("APV"):
		case PackExt("DGI"):
		case PackExt("DGP"):
		case PackExt("ESC"):
		case PackExt("ILC"):
		case PackExt("PZM"):
		case PackExt("APA"):
		case PackExt("APC"):
		case PackExt("PLM"):
		case PackExt("APL"):
		case PackExt("APP"):
		case PackExt("APS"):
		case PackExt("ART"):
		case PackExt("ARV"):
		case PackExt("ATR"):
		case PackExt("B&W"):
		case PackExt("B_W"):
		case PackExt("BB0"):
		case PackExt("BB1"):
		case PackExt("BB2"):
		case PackExt("BB4"):
		case PackExt("BB5"):
		case PackExt("BBG"):
		case PackExt("BFLI"):
		case PackExt("BG9"):
		case PackExt("BRUS"):
		case PackExt("IP"):
		case PackExt("PICT"):
		case PackExt("G09"):
		case PackExt("BGP"):
		case PackExt("BKG"):
		case PackExt("BL1"):
		case PackExt("BL2"):
		case PackExt("BL3"):
		case PackExt("BLD"):
		case PackExt("BML"):
		case PackExt("BRU"):
		case PackExt("BSC"):
		case PackExt("BMC4"):
		case PackExt("BSP"):
		case PackExt("CA1"):
		case PackExt("CA2"):
		case PackExt("CA3"):
		case PackExt("CCI"):
		case PackExt("CDU"):
		case PackExt("CE1"):
		case PackExt("CE2"):
		case PackExt("CE3"):
		case PackExt("CEL"):
		case PackExt("CH$"):
		case PackExt("CH4"):
		case PackExt("CH6"):
		case PackExt("CH8"):
		case PackExt("CHE"):
		case PackExt("CHR"):
		case PackExt("CHS"):
		case PackExt("CIN"):
		case PackExt("CLE"):
		case PackExt("CLP"):
		case PackExt("CM5"):
		case PackExt("CMP"):
		case PackExt("CP3"):
		case PackExt("CPI"):
		case PackExt("CPR"):
		case PackExt("CPT"):
		case PackExt("CRG"):
		case PackExt("CTM"):
		case PackExt("CUT"):
		case PackExt("CWG"):
		case PackExt("DA4"):
		case PackExt("DAP"):
		case PackExt("DC1"):
		case PackExt("DD"):
		case PackExt("DEL"):
		case PackExt("DG1"):
		case PackExt("DHGR"):
		case PackExt("DHR"):
		case PackExt("DIN"):
		case PackExt("DIT"):
		case PackExt("DLM"):
		case PackExt("DOL"):
		case PackExt("VID"):
		case PackExt("DOO"):
		case PackExt("DPH"):
		case PackExt("DRG"):
		case PackExt("DRL"):
		case PackExt("DLP"):
		case PackExt("DRZ"):
		case PackExt("DRP"):
		case PackExt("DU1"):
		case PackExt("DUO"):
		case PackExt("DU2"):
		case PackExt("EBD"):
		case PackExt("ECI"):
		case PackExt("ECP"):
		case PackExt("EPA"):
		case PackExt("ESM"):
		case PackExt("EZA"):
		case PackExt("F80"):
		case PackExt("FBI"):
		case PackExt("FCP"):
		case PackExt("FPT"):
		case PackExt("FD2"):
		case PackExt("FFLI"):
		case PackExt("FGE"):
		case PackExt("FLF"):
		case PackExt("FLI"):
		case PackExt("FN2"):
		case PackExt("FNT"):
		case PackExt("FP2"):
		case PackExt("FPR"):
		case PackExt("FTC"):
		case PackExt("FUL"):
		case PackExt("FUN"):
		case PackExt("FWA"):
		case PackExt("G"):
		case PackExt("G10"):
		case PackExt("G11"):
		case PackExt("G2F"):
		case PackExt("G9B"):
		case PackExt("G9S"):
		case PackExt("SFD"):
		case PackExt("GED"):
		case PackExt("GFB"):
		case PackExt("GG"):
		case PackExt("GHG"):
		case PackExt("GL5"):
		case PackExt("GL6"):
		case PackExt("GL7"):
		case PackExt("GL8"):
		case PackExt("GLA"):
		case PackExt("GLC"):
		case PackExt("GLS"):
		case PackExt("GOD"):
		case PackExt("GR0"):
		case PackExt("ASC"):
		case PackExt("GR1"):
#if FIVE_CHAR_EXT
		case PackExt("GR10P"):
#endif
		case PackExt("GR2"):
		case PackExt("GR3"):
		case PackExt("GR7"):
		case PackExt("GR8"):
		case PackExt("GR9"):
		case PackExt("GR9P"):
		case PackExt("GRP"):
		case PackExt("GS"):
		case PackExt("IIGS"):
		case PackExt("32K"):
		case PackExt("GUN"):
		case PackExt("HCM"):
		case PackExt("HED"):
		case PackExt("HFC"):
		case PackExt("HGB"):
		case PackExt("HGR"):
		case PackExt("HIM"):
		case PackExt("HIP"):
		case PackExt("HIR"):
		case PackExt("HBM"):
		case PackExt("HPI"):
		case PackExt("GIH"):
		case PackExt("FGS"):
		case PackExt("MON"):
		case PackExt("GCD"):
		case PackExt("HLF"):
		case PackExt("HLR"):
		case PackExt("HPC"):
		case PackExt("HPM"):
		case PackExt("HPS"):
		case PackExt("HR"):
		case PackExt("HR2"):
		case PackExt("HCI"):
		case PackExt("HRG"):
		case PackExt("HRM"):
		case PackExt("HRS"):
		case PackExt("HS2"):
		case PackExt("IB3"):
		case PackExt("IBI"):
		case PackExt("IC1"):
		case PackExt("IC2"):
		case PackExt("IC3"):
		case PackExt("ICE"):
		case PackExt("ICN"):
		case PackExt("IFF"):
		case PackExt("ACBM"):
		case PackExt("BEAM"):
		case PackExt("DCT"):
		case PackExt("DCTV"):
		case PackExt("DEEP"):
		case PackExt("DR"):
		case PackExt("HAM"):
		case PackExt("HAM6"):
		case PackExt("HAM8"):
		case PackExt("LBM"):
		case PackExt("ILBM"):
		case PackExt("MP"):
		case PackExt("RGB8"):
		case PackExt("RGBN"):
		case PackExt("SHAM"):
		case PackExt("IFL"):
		case PackExt("IGE"):
		case PackExt("IHE"):
		case PackExt("IIM"):
		case PackExt("ILD"):
		case PackExt("ILS"):
		case PackExt("IMG"):
		case PackExt("TIMG"):
		case PackExt("XIMG"):
		case PackExt("IMN"):
		case PackExt("INFO"):
		case PackExt("ING"):
		case PackExt("INP"):
		case PackExt("INS"):
		case PackExt("INT"):
		case PackExt("IP2"):
		case PackExt("IPC"):
		case PackExt("IPT"):
		case PackExt("IR2"):
		case PackExt("IRG"):
		case PackExt("ISH"):
		case PackExt("ISM"):
		case PackExt("IST"):
		case PackExt("JGP"):
		case PackExt("JJ"):
		case PackExt("KFX"):
		case PackExt("KID"):
		case PackExt("KLA"):
		case PackExt("KOA"):
		case PackExt("GIG"):
		case PackExt("RPM"):
		case PackExt("KPR"):
		case PackExt("KSS"):
		case PackExt("LDM"):
		case PackExt("LEO"):
		case PackExt("LP3"):
		case PackExt("LPK"):
		case PackExt("MPK"):
		case PackExt("HPK"):
		case PackExt("LUM"):
		case PackExt("MAC"):
		case PackExt("PNTG"):
		case PackExt("MAG"):
		case PackExt("MKI"):
		case PackExt("MAP"):
		case PackExt("MAX"):
		case PackExt("MBG"):
		case PackExt("MC"):
		case PackExt("MCH"):
		case PackExt("MCI"):
		case PackExt("MCP"):
		case PackExt("MCPP"):
		case PackExt("MCS"):
		case PackExt("MG1"):
		case PackExt("MG2"):
		case PackExt("MG4"):
		case PackExt("MG8"):
		case PackExt("MGA"):
		case PackExt("MGP"):
		case PackExt("MIC"):
		case PackExt("MIG"):
		case PackExt("MIL"):
		case PackExt("MIS"):
		case PackExt("ML1"):
		case PackExt("MLE"):
		case PackExt("MLT"):
		case PackExt("MPL"):
		case PackExt("MPP"):
		case PackExt("MSL"):
		case PackExt("MSP"):
		case PackExt("MUR"):
		case PackExt("MX1"):
		case PackExt("NEO"):
		case PackExt("NL3"):
		case PackExt("NLQ"):
		case PackExt("NXI"):
		case PackExt("OCP"):
		case PackExt("P"):
		case PackExt("P11"):
		case PackExt("P3C"):
		case PackExt("P41"):
		case PackExt("GRF"):
		case PackExt("P4I"):
		case PackExt("P64"):
		case PackExt("PA3"):
		case PackExt("PAC"):
		case PackExt("PBX"):
		case PackExt("PC1"):
		case PackExt("PC2"):
		case PackExt("PC3"):
		case PackExt("PCI"):
		case PackExt("PCS"):
		case PackExt("PCT"):
		case PackExt("PET"):
		case PackExt("PG1"):
		case PackExt("PG2"):
		case PackExt("PG3"):
		case PackExt("PGC"):
		case PackExt("PGF"):
		case PackExt("PGR"):
		case PackExt("PI"):
		case PackExt("PI1"):
		case PackExt("PI2"):
		case PackExt("PI3"):
		case PackExt("PI5"):
		case PackExt("PI6"):
		case PackExt("SUH"):
		case PackExt("PI4"):
		case PackExt("PI7"):
		case PackExt("PI8"):
		case PackExt("PI9"):
		case PackExt("PIC"):
		case PackExt("PIX"):
		case PackExt("PL4"):
		case PackExt("PLA"):
		case PackExt("PLS"):
		case PackExt("PMD"):
		case PackExt("PMG"):
		case PackExt("PNT"):
		case PackExt("PP"):
		case PackExt("PPH"):
		case PackExt("PPP"):
		case PackExt("PSC"):
		case PackExt("PSF"):
		case PackExt("Q4"):
		case PackExt("RAG"):
		case PackExt("RAP"):
		case PackExt("RAW"):
		case PackExt("RGB"):
		case PackExt("RGH"):
		case PackExt("RIP"):
		case PackExt("RLE"):
		case PackExt("RM0"):
		case PackExt("RM1"):
		case PackExt("RM2"):
		case PackExt("RM3"):
		case PackExt("RM4"):
		case PackExt("RP"):
		case PackExt("RWH"):
		case PackExt("RWL"):
		case PackExt("RYS"):
		case PackExt("SAR"):
		case PackExt("CL0"):
		case PackExt("CL1"):
		case PackExt("CL2"):
		case PackExt("PG0"):
		case PackExt("SC0"):
		case PackExt("SC1"):
		case PackExt("SC2"):
		case PackExt("SC3"):
		case PackExt("SC4"):
		case PackExt("SC5"):
		case PackExt("GE5"):
		case PackExt("SC6"):
		case PackExt("SC7"):
		case PackExt("GE7"):
		case PackExt("SC8"):
		case PackExt("GE8"):
		case PackExt("SR8"):
		case PackExt("SCA"):
		case PackExt("SCC"):
		case PackExt("SD0"):
		case PackExt("SD1"):
		case PackExt("SD2"):
		case PackExt("SRS"):
		case PackExt("YJK"):
		case PackExt("SCR"):
		case PackExt("SCS4"):
		case PackExt("SS4"):
		case PackExt("SG3"):
		case PackExt("SGE"):
		case PackExt("SGX"):
		case PackExt("SH3"):
		case PackExt("3200"):
		case PackExt("SHC"):
		case PackExt("SHP"):
		case PackExt("SHR"):
		case PackExt("SIF"):
		case PackExt("SKP"):
		case PackExt("SPC"):
		case PackExt("SPD"):
		case PackExt("SPR"):
		case PackExt("SPS"):
		case PackExt("SPU"):
		case PackExt("SPX"):
		case PackExt("SR5"):
		case PackExt("SR6"):
		case PackExt("SR7"):
		case PackExt("SRI"):
		case PackExt("SRT"):
		case PackExt("SSB"):
		case PackExt("SSX"):
		case PackExt("STL"):
		case PackExt("STP"):
		case PackExt("SXG"):
		case PackExt("SXS"):
		case PackExt("TCP"):
		case PackExt("TG1"):
		case PackExt("TIM"):
		case PackExt("TIP"):
		case PackExt("TL4"):
		case PackExt("TN1"):
		case PackExt("TN2"):
		case PackExt("TN3"):
		case PackExt("TN4"):
		case PackExt("TN5"):
		case PackExt("TN6"):
		case PackExt("TNY"):
		case PackExt("TPI"):
		case PackExt("TRE"):
		case PackExt("TRP"):
		case PackExt("TRU"):
		case PackExt("TX0"):
		case PackExt("TXE"):
		case PackExt("TXS"):
		case PackExt("VBM"):
		case PackExt("BM"):
		case PackExt("VIC"):
		case PackExt("VZI"):
		case PackExt("WIN"):
		case PackExt("WND"):
		case PackExt("XGA"):
		case PackExt("XLP"):
		case PackExt("ZIM"):
		case PackExt("ZM4"):
		case PackExt("ZP1"):
		case PackExt("ZXP"):
			return true;
		default:
			return false;
		}
	}

	/// Decodes a picture file to an RGB bitmap.
	/// Returns `true` on success.
	public bool Decode!(
		/// Name of the file to decode. Only the extension is processed, for format recognition.
		string filename,
		/// File contents.
		byte[] content,
		/// File length.
		int contentLength)
	{
		switch (GetPackedExt(filename)) {
		case PackExt("256"):
			return DecodeIff(content, contentLength, RECOILResolution.Amiga1x1)
				|| Decode256(content, contentLength);
		case PackExt("3"):
			return Decode3(content, contentLength);
		case PackExt("3201"):
			return Decode3201(content, contentLength);
		case PackExt("4BT"):
			return Decode4bt(content, contentLength);
		case PackExt("4MI"):
			return Decode4mi(content, contentLength);
		case PackExt("4PL"):
			return Decode4pl(content, contentLength);
		case PackExt("4PM"):
			return Decode4pm(content, contentLength);
		case PackExt("64C"):
			return Decode64c(content, contentLength);
		case PackExt("A"):
			return DecodeA(content, contentLength);
		case PackExt("A4R"):
			return DecodeA4r(content, contentLength);
		case PackExt("A64"):
		case PackExt("WIG"):
			return contentLength == 10242 && DecodeC64Multicolor(320, content, 2, 0x2002, 0x2402, content[0x2801]);
		case PackExt("AAS"):
		case PackExt("IPH"):
			return DecodeIph(content, contentLength);
		case PackExt("ABK"):
			return DecodeAbk(content, contentLength);
		case PackExt("ACS"):
			return DecodeAcs(content, contentLength);
		case PackExt("AFL"):
			return DecodeAfl(content, contentLength);
		case PackExt("AGP"):
			return DecodeAgp(content, contentLength);
		case PackExt("AGS"):
			return DecodeAgs(content, contentLength);
		case PackExt("ALL"):
			return DecodeAll(content, contentLength);
		case PackExt("AMI"):
			return DecodeAmi(content, contentLength);
		case PackExt("AN2"):
			return DecodeAn2(content, contentLength);
		case PackExt("AN4"):
			return DecodeAn4(content, contentLength, 0);
		case PackExt("AN5"):
			return DecodeAn4(content, contentLength, 1);
		case PackExt("AP2"):
			return Decode256(content, contentLength);
		case PackExt("AP3"):
		case PackExt("APV"):
		case PackExt("DGI"):
		case PackExt("DGP"):
		case PackExt("ESC"):
		case PackExt("ILC"):
		case PackExt("PZM"):
			return DecodeAp3(content, contentLength);
		case PackExt("APA"):
		case PackExt("APC"):
		case PackExt("PLM"):
			return DecodeApc(content, contentLength);
		case PackExt("APL"):
			return DecodeApl(content, contentLength);
		case PackExt("APP"):
			return DecodeApp(content, contentLength);
		case PackExt("APS"):
			return DecodeAps(content, contentLength);
		case PackExt("ART"):
			return DecodeIph(content, contentLength) // contentLength == 9009
				|| DecodeArtDirector(content, contentLength) // contentLength == 32512
				|| DecodeGfaArtist(content, contentLength) // contentLength == 32032
				|| DecodePaletteMaster(content, contentLength) // contentLength == 36864
				|| DecodeAtari8Artist(content, contentLength) // contentLength == 3206
				|| DecodeMonoArt(content, contentLength) // dimensions in the file, largest known file is 639 bytes
				|| DecodeAsciiArtEditor(content, contentLength); // ends with 0x9b
		case PackExt("ARV"):
			return DecodeArtMaster88(content, contentLength);
		case PackExt("ATR"):
			return DecodeAtr(content, contentLength);
		case PackExt("B&W"):
		case PackExt("B_W"):
			return DecodeBw(content, contentLength);
		case PackExt("BB0"):
			return DecodeBb0(content, contentLength, BbcPalette1Bit);
		case PackExt("BB1"):
			return DecodeBb1(content, contentLength, BbcPalette2Bit);
		case PackExt("BB2"):
			return DecodeBb2(content, contentLength, BbcPalette);
		case PackExt("BB4"):
			return DecodeBb4(content, contentLength, BbcPalette1Bit);
		case PackExt("BB5"):
			return DecodeBb5(content, contentLength, BbcPalette2Bit);
		case PackExt("BBG"):
			return DecodeBbg(content, contentLength);
		case PackExt("BFLI"):
			return DecodeBfli(content, contentLength);
		case PackExt("BG9"):
		case PackExt("G09"):
			return DecodeG09(content, contentLength);
		case PackExt("BGP"):
			return DecodeBgp(content, contentLength);
		case PackExt("BKG"):
			return DecodeBkg(content, contentLength);
		case PackExt("BRUS"):
		case PackExt("IP"):
		case PackExt("PICT"):
			return DecodeBrus(content, contentLength);
		case PackExt("BL1"):
		case PackExt("BL2"):
		case PackExt("BL3"):
			return DecodeIff(content, contentLength, RECOILResolution.St1x1);
		case PackExt("BLD"):
			return DecodeBld(content, contentLength);
		case PackExt("BML"):
			return DecodeBml(content, contentLength);
		case PackExt("BRU"):
			return DecodeBru(content, contentLength);
		case PackExt("BSC"):
		case PackExt("BMC4"):
			return DecodeBsc(content, contentLength);
		case PackExt("BSP"):
			return DecodeBsp(content, contentLength);
		case PackExt("CA1"):
		case PackExt("CA2"):
		case PackExt("CA3"):
			return DecodeCa(content, contentLength);
		case PackExt("CCI"):
			return DecodeCci(content, contentLength);
		case PackExt("CDU"):
			return contentLength == 10277 && DecodeC64Multicolor(320, content, 0x113, 0x2053, 0x243b, content[0x2823]);
		case PackExt("CE1"):
		case PackExt("CE2"):
		case PackExt("CE3"):
			return DecodeCe(content, contentLength);
		case PackExt("CEL"):
			return DecodeCel(content, contentLength);
		case PackExt("CH$"):
			return DecodeChrd(content, contentLength);
		case PackExt("CH4"):
		case PackExt("CH6"):
		case PackExt("CH8"):
			return DecodeCh8(content, contentLength);
		case PackExt("CHE"):
			return contentLength == 20482 && DecodeC64Multicolor(320, content, 2, 0x4202, 0x4802, content[0x4fff]);
		case PackExt("CHR"):
			return DecodeChr(content, contentLength);
		case PackExt("CHS"):
			return DecodeChs(content, contentLength);
		case PackExt("CIN"):
			return DecodeCin(content, contentLength);
		case PackExt("CLE"):
			return DecodeCle(content, contentLength);
		case PackExt("CLP"):
			return DecodeClp(content, contentLength);
		case PackExt("CM5"):
			return DecodeCm5(filename, content, contentLength);
		case PackExt("CMP"):
			return DecodeDdGraph(filename, content, contentLength)
				|| DecodeStCmp(content, contentLength);
		case PackExt("CP3"):
			return DecodeCp3(content, contentLength);
		case PackExt("CPI"):
			return DecodeCpi(content, contentLength);
		case PackExt("CPR"):
			return DecodeCpr(content, contentLength);
		case PackExt("CPT"):
			return DecodeCpt(filename, content, contentLength);
		case PackExt("CRG"):
			return DecodeCrg(content, contentLength);
		case PackExt("CTM"):
			return DecodeCtm(content, contentLength);
		case PackExt("CUT"):
			return DecodeGr8Raw(content, contentLength, 96, 99);
		case PackExt("CWG"):
			return contentLength == 10007 && DecodeC64Multicolor(320, content, 2, 0x1f42, 0x232a, content[0x2713]);
		case PackExt("DA4"):
			return DecodeDa4(content, contentLength);
		case PackExt("DAP"):
			return DecodeDap(content, contentLength);
		case PackExt("DC1"):
			return DecodeDc1(content, contentLength);
		case PackExt("DD"):
			return DecodeDd(content, contentLength);
		case PackExt("DEL"):
			return DecodeDel(content, contentLength);
		case PackExt("DG1"):
			return DecodeDg1(content, contentLength);
		case PackExt("DHGR"):
			return DecodeAppleIIDhr(content, contentLength);
		case PackExt("DHR"):
			return DecodeIff(content, contentLength, RECOILResolution.Amiga1x1)
				|| DecodeAppleIIDhr(content, contentLength);
		case PackExt("DIN"):
			return DecodeAtari8Ice(content, contentLength, false, 3);
		case PackExt("DIT"):
			return DecodeDit(content, contentLength);
		case PackExt("DLM"):
			return DecodeDlm(content, contentLength);
		case PackExt("DOL"):
		case PackExt("VID"):
			return DecodeDol(content, contentLength);
		case PackExt("DOO"):
			return DecodeDoo(content, contentLength);
		case PackExt("DPH"):
			return DecodeDph(content, contentLength);
		case PackExt("DRG"):
			return DecodeDrg(content, contentLength);
		case PackExt("DRL"):
		case PackExt("DLP"):
			return DecodeDrl(content, contentLength);
		case PackExt("DRZ"):
		case PackExt("DRP"):
			return DecodeDrz(content, contentLength);
		case PackExt("DU1"):
		case PackExt("DUO"):
			return DecodeDuo(content, contentLength);
		case PackExt("DU2"):
			return DecodeDu2(content, contentLength);
		case PackExt("EBD"):
			return DecodeEbd(content, contentLength);
		case PackExt("ECI"):
			return DecodeEci(content, contentLength);
		case PackExt("ECP"):
			return DecodeEcp(content, contentLength);
		case PackExt("EPA"):
			return DecodeEpa(content, contentLength);
		case PackExt("ESM"):
			return DecodeEsm(content, contentLength);
		case PackExt("EZA"):
			return DecodeEza(content, contentLength);
		case PackExt("F80"):
			return DecodeF80(content, contentLength);
		case PackExt("FBI"):
			return DecodeFbi(content, contentLength);
		case PackExt("FCP"):
		case PackExt("FPT"):
			return contentLength == 10004 && DecodeC64Multicolor(320, content, 2, 0x1f42, 0x232a, content[0x2712]);
		case PackExt("FD2"):
			return DecodeFli(content, contentLength);
		case PackExt("FFLI"):
			return DecodeFfli(content, contentLength);
		case PackExt("FGE"):
			return DecodeFge(content, contentLength);
		case PackExt("FLF"):
			return DecodeFlf(content, contentLength);
		case PackExt("FLI"):
			return DecodeFli(content, contentLength)
				|| DecodeBml(content, contentLength);
		case PackExt("FN2"):
			return DecodeFn2(content, contentLength);
		case PackExt("FNT"):
			return DecodePct(content, contentLength)
				|| DecodeGdosFnt(content, contentLength)
				|| DecodeAtari8Fnt(content, contentLength)
				|| DecodeStFnt(content, contentLength)
				|| DecodeAmstradFnt(content, contentLength)
				|| DecodeImage72Fnt(content, contentLength);
		case PackExt("FP2"):
			return DecodeC64Fun(content, contentLength);
		case PackExt("FPR"):
			return DecodeFpr(content, contentLength);
		case PackExt("FTC"):
			return DecodeFtc(content, contentLength);
		case PackExt("FUL"):
			return DecodeFul(content, contentLength);
		case PackExt("FUN"):
			return DecodeC64Fun(content, contentLength)
				|| DecodeFalconFun(content, contentLength);
		case PackExt("FWA"):
			return DecodeFwa(content, contentLength);
		case PackExt("G"):
			return DecodeG(content, contentLength);
		case PackExt("G10"):
			return DecodeG10(content, contentLength);
		case PackExt("G11"):
			return DecodeG11(content, contentLength);
		case PackExt("G2F"):
			return DecodeG2f(content, contentLength);
		case PackExt("G9B"):
			return DecodeG9b(content, contentLength);
		case PackExt("G9S"):
		case PackExt("SFD"):
			return DecodeG9s(content, contentLength);
		case PackExt("GED"):
			return DecodeGed(content, contentLength);
		case PackExt("GFB"):
			return DecodeGfb(content, contentLength);
		case PackExt("GG"):
			return DecodeGg(content, contentLength);
		case PackExt("GHG"):
			return DecodeGhg(content, contentLength);
		case PackExt("GL5"):
			return DecodeGl5(filename, content, contentLength);
		case PackExt("GL6"):
			return DecodeGl6(filename, content, contentLength);
		case PackExt("GL7"):
			return DecodeGl7(filename, content, contentLength);
		case PackExt("GL8"):
			return DecodeGl8(content, contentLength);
		case PackExt("GLA"):
			return DecodeGlYjk(filename, content, contentLength);
		case PackExt("GLC"):
		case PackExt("GLS"):
			return DecodeGlYjk(null, content, contentLength);
		case PackExt("GOD"):
			return DecodeGod(content, contentLength);
		case PackExt("GR0"):
		case PackExt("ASC"):
			return DecodeGr0(content, contentLength);
		case PackExt("GR1"):
			return DecodeGr1(content, contentLength, 0);
#if FIVE_CHAR_EXT
		case PackExt("GR10P"):
			return DecodeGr10p(content, contentLength);
#endif
		case PackExt("GR2"):
			return DecodeGr1(content, contentLength, 1);
		case PackExt("GR3"):
			return DecodeGr3(content, contentLength);
		case PackExt("GR7"):
			return DecodeGr7(content, 0, contentLength);
		case PackExt("GR8"):
			return DecodeGr8(content, contentLength);
		case PackExt("GR9"):
			return DecodeGr9(content, contentLength);
		case PackExt("GR9P"):
			return DecodeGr9p(content, contentLength);
		case PackExt("GRP"):
			return DecodeSc2(content, contentLength);
		case PackExt("GS"):
		case PackExt("IIGS"):
		case PackExt("32K"):
			return DecodeApfShr(content, contentLength);
		case PackExt("GUN"):
			return DecodeGun(content, contentLength);
		case PackExt("HCM"):
			return DecodeHcm(content, contentLength);
		case PackExt("HED"):
			return contentLength == 9218 && DecodeIsh(content);
		case PackExt("HFC"):
			return DecodeHfc(content, contentLength);
		case PackExt("HGB"):
			return DecodeHgb(content, contentLength);
		case PackExt("HGR"):
			return DecodeHgr(content, contentLength);
		case PackExt("HIM"):
			return DecodeHim(content, contentLength);
		case PackExt("HIP"):
			return DecodeHip(content, contentLength);
		case PackExt("HIR"):
			return DecodeFalconHir(content, contentLength)
				|| DecodeC64Hir(content, contentLength)
				|| DecodeHrs(content, contentLength);
		case PackExt("HBM"):
		case PackExt("HPI"):
		case PackExt("GIH"):
		case PackExt("FGS"):
		case PackExt("MON"):
		case PackExt("GCD"):
			return DecodeC64Hir(content, contentLength);
		case PackExt("HLF"):
			return DecodeHlf(content, contentLength);
		case PackExt("HLR"):
			return DecodeHlr(content, contentLength);
		case PackExt("HPC"):
			return DecodeIph(content, contentLength);
		case PackExt("HPM"):
			return DecodeHpm(content, contentLength);
		case PackExt("HPS"):
			return DecodeHps(content, contentLength);
		case PackExt("HR"):
			return DecodeTrsHr(content, contentLength)
				|| DecodeAtari8Hr(content, contentLength);
		case PackExt("HR2"):
		case PackExt("HCI"):
			return DecodeHr2(content, contentLength);
		case PackExt("HRG"):
			return DecodeHrg(content, contentLength);
		case PackExt("HRM"):
			return DecodeHrm(content, contentLength);
		case PackExt("HRS"):
			return DecodeHrs(content, contentLength);
		case PackExt("HS2"):
			return DecodeHs2(content, contentLength);
		case PackExt("IB3"):
		case PackExt("IBI"):
			return DecodeIbi(content, contentLength);
		case PackExt("IC1"):
		case PackExt("IC2"):
		case PackExt("IC3"):
			return DecodeIc(content, contentLength);
		case PackExt("ICE"):
			return contentLength > 1024 && DecodeAtari8Ice(content, contentLength, true, content[0]);
		case PackExt("ICN"):
			return DecodeStIcn(content, contentLength)
				|| DecodePsion3Pic(content, contentLength)
				|| DecodeAtari8Ice(content, contentLength, false, 17);
		case PackExt("IFF"):
		case PackExt("ACBM"):
		case PackExt("BEAM"):
		case PackExt("DCT"):
		case PackExt("DCTV"):
		case PackExt("DEEP"):
		case PackExt("DR"):
		case PackExt("HAM"):
		case PackExt("HAM6"):
		case PackExt("HAM8"):
		case PackExt("LBM"):
		case PackExt("ILBM"):
		case PackExt("MP"):
		case PackExt("RGB8"):
		case PackExt("RGBN"):
		case PackExt("SHAM"):
			return DecodeIff(content, contentLength, RECOILResolution.Amiga1x1);
		case PackExt("IFL"):
			return DecodeGun(content, contentLength)
				|| DecodeZxIfl(content, contentLength);
		case PackExt("IGE"):
			return DecodeIge(content, contentLength);
		case PackExt("IHE"):
			return DecodeIhe(content, contentLength);
		case PackExt("IIM"):
			return DecodeIim(content, contentLength);
		case PackExt("ILD"):
			return DecodeIld(content, contentLength);
		case PackExt("ILS"):
			return DecodeIls(content, contentLength);
		case PackExt("IMG"):
			return DecodeStImg(content, contentLength)
				|| DecodeZxImg(content, contentLength)
				|| DecodeArtMaster88(content, contentLength)
				|| DecodeDaVinci(content, contentLength);
		case PackExt("TIMG"):
		case PackExt("XIMG"):
			return DecodeStImg(content, contentLength);
		case PackExt("IMN"):
			return DecodeAtari8Ice(content, contentLength, false, 18);
		case PackExt("INFO"):
			return DecodeInfo(content, contentLength);
		case PackExt("ING"):
		case PackExt("INP"):
			return DecodeInp(content, contentLength);
		case PackExt("INS"):
			return DecodeIns(content, contentLength);
		case PackExt("INT"):
			return DecodeInt(content, contentLength)
				|| DecodeInp(content, contentLength);
		case PackExt("IP2"):
			return DecodeIp2(content, contentLength);
		case PackExt("IPC"):
			return DecodeAtari8Ice(content, contentLength, false, 19);
		case PackExt("IPT"):
			return contentLength == 10003 && DecodeC64Multicolor(320, content, 2, 0x1f42, 0x232a, content[0x2712]);
		case PackExt("IR2"):
			return DecodeAtari8Ice(content, contentLength, false, 2);
		case PackExt("IRG"):
			return DecodeAtari8Ice(content, contentLength, false, 1);
		case PackExt("ISH"):
			return contentLength == 9194 && DecodeIsh(content);
		case PackExt("ISM"):
			return contentLength == 10218 && DecodeC64Multicolor(320, content, 0x402, 0x2402, 2, content[0x2401]);
		case PackExt("IST"):
			return DecodeIst(content, contentLength);
		case PackExt("JGP"):
			return DecodeJgp(content, contentLength);
		case PackExt("JJ"):
			return DecodeJj(content, contentLength);
		case PackExt("KFX"):
			return DecodeGr8Raw(content, contentLength, 56, 60);
		case PackExt("KID"):
			return DecodeKid(content, contentLength);
		case PackExt("KLA"):
		case PackExt("KOA"):
		case PackExt("GIG"):
		case PackExt("RPM"):
			return DecodeKoa(content, contentLength);
		case PackExt("KPR"):
			return DecodeKpr(content, contentLength);
		case PackExt("KSS"):
			return DecodeKss(content, contentLength);
		case PackExt("LDM"):
			return DecodeLdm(content, contentLength);
		case PackExt("LEO"):
			return DecodeLeo(content, contentLength);
		case PackExt("LP3"):
			return DecodeLp3(content, contentLength);
		case PackExt("LPK"):
			return DecodeDaliCompressed(content, contentLength, 0);
		case PackExt("MPK"):
			return DecodeDaliCompressed(content, contentLength, 1);
		case PackExt("HPK"):
			return DecodeDaliCompressed(content, contentLength, 2);
		case PackExt("LUM"):
			return DecodeLum(filename, content, contentLength);
		case PackExt("MAC"):
		case PackExt("PNTG"):
			return DecodeMac(content, contentLength);
		case PackExt("MAG"):
		case PackExt("MKI"):
			return DecodeMag(content, contentLength);
		case PackExt("MAP"):
			return DecodeEnvision(content, contentLength)
				|| DecodeEnvisionPC(content, contentLength);
		case PackExt("MAX"):
			return DecodeMag(content, contentLength)
				|| DecodeAtari8Max(content, contentLength)
				|| DecodeCocoMax(content, contentLength);
		case PackExt("MBG"):
			return DecodeGr8Raw(content, contentLength, 512, 256);
		case PackExt("MC"):
			return DecodeMcMlt(content, contentLength, ZxBitmapLinear);
		case PackExt("MCH"):
			return DecodeMch(content, contentLength);
		case PackExt("MCI"):
			return DecodeMci(content, contentLength);
		case PackExt("MCP"):
			return DecodeMcp(content, contentLength);
		case PackExt("MCPP"):
			return DecodeMcpp(content, contentLength);
		case PackExt("MCS"):
			return DecodeMcs(content, contentLength);
		case PackExt("MG1"):
		case PackExt("MG2"):
		case PackExt("MG4"):
		case PackExt("MG8"):
			return DecodeMg(content, contentLength);
		case PackExt("MGA"):
			return DecodeMga(content, contentLength);
		case PackExt("MGP"):
			return DecodeMgp(content, contentLength);
		case PackExt("MIC"):
			return DecodeMic(filename, content, contentLength);
		case PackExt("MIG"):
			return DecodeMig(content, contentLength);
		case PackExt("MIL"):
			return contentLength == 10022 && DecodeC64Multicolor(320, content, 0x7e6, 0x16, 0x3fe, 0);
		case PackExt("MIS"):
			return DecodeMis(content, contentLength);
		case PackExt("ML1"):
			return DecodeMl1(content, contentLength);
		case PackExt("MLE"):
			return DecodeMle(content, contentLength);
		case PackExt("MLT"):
			return DecodeMcMlt(content, contentLength, 0);
		case PackExt("MPL"):
			return DecodeMpl(content, contentLength);
		case PackExt("MPP"):
			return DecodeMpp(content, contentLength);
		case PackExt("MSL"):
			return DecodeMsl(content, contentLength);
		case PackExt("MSP"):
			return DecodeMsp(content, contentLength);
		case PackExt("MUR"):
			return DecodeMur(filename, content, contentLength);
		case PackExt("MX1"):
			return DecodeMx1(content, contentLength);
		case PackExt("NEO"):
			return DecodeNeo(filename, content, contentLength)
				|| DecodeIff(content, contentLength, RECOILResolution.Ste1x1);
		case PackExt("NL3"):
			return DecodeNl3(content, contentLength);
		case PackExt("NLQ"):
			return DecodeNlq(content, contentLength);
		case PackExt("NXI"):
			return DecodeNxi(content, contentLength);
		case PackExt("OCP"):
			return DecodeOcp(content, contentLength);
		case PackExt("P"):
			return DecodeP(content, contentLength);
		case PackExt("P11"):
			return DecodeP11(content, contentLength);
		case PackExt("P3C"):
			return DecodeP3c(content, contentLength);
		case PackExt("P41"):
		case PackExt("GRF"):
			return DecodeCocoMax(content, contentLength);
		case PackExt("P4I"):
			return DecodeP4i(content, contentLength);
		case PackExt("P64"):
			return contentLength == 10050 && DecodeC64Multicolor(320, content, 0x802, 0x402, 2, content[0x801]);
		case PackExt("PA3"):
			return DecodeStPpp(content, contentLength);
		case PackExt("PAC"):
			return DecodePac(content, contentLength);
		case PackExt("PBX"):
			return DecodePbx(content, contentLength);
		case PackExt("PC1"):
		case PackExt("PC2"):
		case PackExt("PC3"):
			return DecodePc(content, contentLength);
		case PackExt("PCI"):
			return DecodePci(content, contentLength);
		case PackExt("PCS"):
			return DecodePcs(content, contentLength);
		case PackExt("PCT"):
			return DecodePct(content, contentLength);
		case PackExt("PET"):
			return DecodePet(content, contentLength);
		case PackExt("PG1"):
		case PackExt("PG2"):
			return DecodeSc(content, contentLength)
				|| DecodeGraphicsProcessor(content, contentLength);
		case PackExt("PG3"):
			return DecodeGraphicsProcessor(content, contentLength);
		case PackExt("PGC"):
			return DecodePgc(content, contentLength);
		case PackExt("PGF"):
			return DecodePgf(content, contentLength);
		case PackExt("PGR"):
			return DecodePgr(content, contentLength);
		case PackExt("PI"):
			return DecodePi(content, contentLength)
				|| (contentLength == 10242 && DecodeC64Multicolor(320, content, 2, 0x2002, 0x2402, content[0x1f82]));
		case PackExt("PI1"):
		case PackExt("PI2"):
		case PackExt("PI3"):
		case PackExt("PI5"):
		case PackExt("PI6"):
		case PackExt("SUH"):
			return DecodeStPi(content, contentLength);
		case PackExt("PI4"):
			return DecodeFuckpaint(content, contentLength)
				|| DecodeStPi(content, contentLength);
		case PackExt("PI7"):
			return DecodeFuckpaint(content, contentLength);
		case PackExt("PI8"):
			return DecodePi8(content, contentLength);
		case PackExt("PI9"):
			return DecodePi9(content, contentLength);
		case PackExt("PIC"):
			return DecodePic(content, contentLength);
		case PackExt("PIX"):
			return DecodeFalconPix(content, contentLength)
				|| DecodeCocoMax(content, contentLength)
				|| DecodeAtari8Pix(content, contentLength);
		case PackExt("PL4"):
			return DecodePl4(content, contentLength);
		case PackExt("PLA"):
			return DecodePla(content, contentLength);
		case PackExt("PLS"):
			return DecodePls(content, contentLength);
		case PackExt("PMD"):
			return DecodePmd(content, contentLength);
		case PackExt("PMG"):
			return DecodePmg(content, contentLength);
		case PackExt("PNT"):
			return DecodeFalconPnt(content, contentLength)
				|| DecodeTandyPnt(content, contentLength)
				|| DecodeApfShr(content, contentLength)
				|| DecodeMac(content, contentLength)
				|| DecodeAppleIIShr(content, contentLength)
				|| DecodePaintworks(content, contentLength);
		case PackExt("PP"):
			return DecodePp(content, contentLength);
		case PackExt("PPH"):
			return DecodePph(filename, content, contentLength);
		case PackExt("PPP"):
			return DecodeStPpp(content, contentLength)
				|| DecodePp(content, contentLength);
		case PackExt("PSC"):
			return DecodePsc(content, contentLength);
		case PackExt("PSF"):
			return DecodePsf(content, contentLength);
		case PackExt("Q4"):
			return DecodeQ4(content, contentLength);
		case PackExt("RAG"):
			return DecodeRag(content, contentLength);
		case PackExt("RAP"):
			return DecodeRap(content, contentLength);
		case PackExt("RAW"):
			return DecodeZx81Raw(content, contentLength)
				|| DecodeAtari8Raw(content, contentLength)
				|| DecodeRw(content, contentLength);
		case PackExt("RGB"):
			return DecodeStRgb(content, contentLength)
				|| DecodeAtari8Rgb(content, contentLength)
				|| DecodeZxRgb(content, contentLength);
		case PackExt("RGH"):
			return DecodeRgh(content, contentLength);
		case PackExt("RIP"):
			return DecodeRip(content, contentLength);
		case PackExt("RLE"):
			return DecodeRle(content, contentLength);
		case PackExt("RM0"):
			return DecodeRm(content, contentLength, 0, RECOILResolution.Xe2x2);
		case PackExt("RM1"):
			return DecodeRm(content, contentLength, 1, RECOILResolution.Xe4x1);
		case PackExt("RM2"):
			return DecodeRm(content, contentLength, 2, RECOILResolution.Xe4x1);
		case PackExt("RM3"):
			return DecodeRm(content, contentLength, 3, RECOILResolution.Xe4x1);
		case PackExt("RM4"):
			return DecodeRm(content, contentLength, 4, RECOILResolution.Xe2x1);
		case PackExt("RP"):
			return contentLength == 10242 && DecodeC64Multicolor(320, content, 0x402, 2, 0x2402, 0);
		case PackExt("RWH"):
		case PackExt("RWL"):
			return DecodeRw(content, contentLength);
		case PackExt("RYS"):
			return DecodeRys(content, contentLength);
		case PackExt("SAR"):
			return contentLength == 10219 && DecodeC64Multicolor(320, content, 0x402, 2, 0x2402, content[0x3f2]);
		case PackExt("CL0"):
		case PackExt("CL1"):
		case PackExt("CL2"):
		case PackExt("PG0"):
		case PackExt("SC0"):
		case PackExt("SC1"):
			return DecodeSc(content, contentLength);
		case PackExt("SC2"):
			return DecodeSc(content, contentLength)
				|| DecodeSc2(content, contentLength);
		case PackExt("SC3"):
			return DecodeSc3(content, contentLength);
		case PackExt("SC4"):
			return DecodeSc4(content, contentLength);
		case PackExt("SC5"):
		case PackExt("GE5"):
			return DecodeSc5(filename, content, contentLength);
		case PackExt("SC6"):
			return DecodeSc6(filename, content, contentLength);
		case PackExt("SC7"):
		case PackExt("GE7"):
			return DecodeSc7(filename, content, contentLength);
		case PackExt("SC8"):
		case PackExt("GE8"):
		case PackExt("SR8"):
			return DecodeSc8(filename, content, contentLength);
		case PackExt("SCA"):
			return DecodeSca(filename, content, contentLength);
		case PackExt("SCC"):
		case PackExt("SRS"):
		case PackExt("YJK"):
			return DecodeScc(filename, content, contentLength);
		case PackExt("SCR"):
			return DecodeScr(filename, content, contentLength);
		case PackExt("SCS4"):
		case PackExt("SS4"):
			return DecodeScs4(content, contentLength);
		case PackExt("SD0"):
			return DecodeSd(content, contentLength, 0);
		case PackExt("SD1"):
			return DecodeSd(content, contentLength, 1);
		case PackExt("SD2"):
			return DecodeSd(content, contentLength, 2);
		case PackExt("SG3"):
			return DecodeSg3(content, contentLength);
		case PackExt("SGE"):
			return DecodeSge(content, contentLength);
		case PackExt("SGX"):
			return DecodeSgx(content, contentLength);
		case PackExt("SH3"):
		case PackExt("3200"):
			return DecodeApfShr(content, contentLength)
				|| Decode3201(content, contentLength)
				|| DecodeSh3(content, contentLength)
				|| DecodeAppleIIShr(content, contentLength);
		case PackExt("SHC"):
			return DecodeShc(content, contentLength);
		case PackExt("SHP"):
			return DecodeShp(content, contentLength);
		case PackExt("SHR"):
			return DecodeApfShr(content, contentLength)
				|| DecodeAppleIIShr(content, contentLength)
				|| DecodeSh3(content, contentLength)
				|| DecodeTrsShr(content, contentLength);
		case PackExt("SIF"):
			return DecodeSif(content, contentLength);
		case PackExt("SKP"):
			return DecodeSkp(content, contentLength);
		case PackExt("SPC"):
			return DecodeStSpc(content, contentLength)
				|| DecodeAtari8Spc(content, contentLength);
		case PackExt("SPD"):
			return DecodeSpd(content, contentLength);
		case PackExt("SPR"):
			return DecodeAppleSpr(content, contentLength)
				|| DecodeAtari8Spr(content, contentLength);
		case PackExt("SPS"):
			return DecodeSps(content, contentLength);
		case PackExt("SPU"):
			return DecodeSpu(content, contentLength);
		case PackExt("SPX"):
			return DecodeSpx(content, contentLength);
		case PackExt("SR5"):
			return DecodeSr5(filename, content, contentLength);
		case PackExt("SR6"):
			return DecodeSr6(filename, content, contentLength);
		case PackExt("SR7"):
			return DecodeSr7(filename, content, contentLength);
		case PackExt("SRI"):
			return DecodeSri(filename, content, contentLength);
		case PackExt("SRT"):
			return DecodeSrt(content, contentLength);
		case PackExt("SSB"):
			return DecodeSsb(content, contentLength);
		case PackExt("SSX"):
			return DecodeSsx(content, contentLength);
		case PackExt("STL"):
			return DecodeStl(content, contentLength);
		case PackExt("STP"):
			return DecodeGl6(null, content, contentLength);
		case PackExt("SXG"):
			return DecodeSxg(content, contentLength);
		case PackExt("SXS"):
			return DecodeSxs(content, contentLength);
		case PackExt("TCP"):
			return DecodeTcp(content, contentLength);
		case PackExt("TG1"):
			return DecodeTg1(content, contentLength);
		case PackExt("TIM"):
			return DecodeTim(content, contentLength);
		case PackExt("TIP"):
			return DecodeTip(content, contentLength);
		case PackExt("TL4"):
			return DecodeTl4(content, contentLength);
		case PackExt("TN1"):
		case PackExt("TN2"):
		case PackExt("TN3"):
		case PackExt("TN4"):
		case PackExt("TN5"):
		case PackExt("TN6"):
		case PackExt("TNY"):
			return DecodeTny(content, contentLength);
		case PackExt("TPI"):
			return DecodeFalconPnt(content, contentLength);
		case PackExt("TRE"):
			return DecodeTre(content, contentLength);
		case PackExt("TRP"):
			return DecodeTrp(content, contentLength);
		case PackExt("TRU"):
			return DecodeTru(content, contentLength);
		case PackExt("TX0"):
			return DecodeTx0(content, contentLength);
		case PackExt("TXE"):
			return DecodeTxe(content, contentLength);
		case PackExt("TXS"):
			return DecodeTxs(content, contentLength);
		case PackExt("VBM"):
		case PackExt("BM"):
			return DecodeVbm(content, contentLength);
		case PackExt("VIC"):
			return DecodeVic(content, contentLength);
		case PackExt("VZI"):
			return DecodeVzi(content, contentLength);
		case PackExt("WIN"):
			return DecodeWin(filename, content, contentLength);
		case PackExt("WND"):
			return DecodeWnd(content, contentLength);
		case PackExt("XGA"):
			return DecodeXga(content, contentLength);
		case PackExt("XLP"):
			return DecodeXlp(content, contentLength);
		case PackExt("ZIM"):
			return DecodeZim(content, contentLength);
		case PackExt("ZM4"):
			return DecodeZm4(content, contentLength);
		case PackExt("ZP1"):
			return DecodeZp1(content, contentLength);
		case PackExt("ZXP"):
			return DecodeZxp(content, contentLength);
		default:
			return false;
		}
	}

	/// Returns decoded image width.
	public int GetWidth() => Width;

	/// Returns decoded image height.
	public int GetHeight() => Height;

	/// Returns pixels of the decoded image, top-down, left-to-right.
	/// Each pixel is a 24-bit integer 0xRRGGBB.
	public int[] GetPixels() => Pixels;

	/// Returns the computer family of the decoded file format.
	public string GetPlatform()
	{
		switch (Resolution) {
		case RECOILResolution.Amiga1x1:
		case RECOILResolution.Amiga2x1:
		case RECOILResolution.Amiga4x1:
		case RECOILResolution.Amiga8x1:
		case RECOILResolution.Amiga1x2:
		case RECOILResolution.Amiga1x4:
			return "Amiga";
		case RECOILResolution.AmigaDctv1x1:
		case RECOILResolution.AmigaDctv1x2:
			return "Amiga DCTV";
		case RECOILResolution.AmigaHame1x1:
		case RECOILResolution.AmigaHame2x1:
			return "Amiga HAM-E";
		case RECOILResolution.Amstrad1x1:
		case RECOILResolution.Amstrad2x1:
		case RECOILResolution.Amstrad1x2:
			return "Amstrad CPC";
		case RECOILResolution.AppleII1x1:
			return "Apple II";
		case RECOILResolution.AppleIIe1x2:
			return "Apple IIe";
		case RECOILResolution.AppleIIGS1x1:
		case RECOILResolution.AppleIIGS1x2:
			return "Apple IIGS";
		case RECOILResolution.Macintosh1x1:
			return "Apple Macintosh";
		case RECOILResolution.Xe1x1:
		case RECOILResolution.Xe2x1:
		case RECOILResolution.Xe4x1:
		case RECOILResolution.Xe2x2:
		case RECOILResolution.Xe4x2:
		case RECOILResolution.Xe4x4:
		case RECOILResolution.Xe8x8:
			return "Atari 8-bit";
		case RECOILResolution.Vbxe1x1:
		case RECOILResolution.Vbxe2x1:
			return "Atari 8-bit VBXE";
		case RECOILResolution.Portfolio1x1:
			return "Atari Portfolio";
		case RECOILResolution.St1x1:
		case RECOILResolution.St1x2:
			return "Atari ST";
		case RECOILResolution.Ste1x1:
		case RECOILResolution.Ste1x2:
			return "Atari STE";
		case RECOILResolution.Tt1x1:
		case RECOILResolution.Tt2x1:
			return "Atari TT";
		case RECOILResolution.Falcon1x1:
		case RECOILResolution.Falcon2x1:
			return "Atari Falcon";
		case RECOILResolution.Bbc1x1:
		case RECOILResolution.Bbc2x1:
		case RECOILResolution.Bbc1x2:
			return "BBC Micro";
		case RECOILResolution.Vic202x1:
			return "Commodore VIC-20";
		case RECOILResolution.C161x1:
		case RECOILResolution.C162x1:
			return "Commodore 16";
		case RECOILResolution.C641x1:
		case RECOILResolution.C642x1:
			return "Commodore 64";
		case RECOILResolution.C1281x1:
			return "Commodore 128";
		case RECOILResolution.Electronika1x1:
			return "Electronika BK";
		case RECOILResolution.FmTowns1x1:
			return "FM Towns";
		case RECOILResolution.Msx11x1:
		case RECOILResolution.Msx14x4:
			return "MSX";
		case RECOILResolution.Msx21x1:
		case RECOILResolution.Msx21x2:
		case RECOILResolution.Msx21x1i:
		case RECOILResolution.Msx22x1i:
			return "MSX2";
		case RECOILResolution.Msx2Plus1x1:
		case RECOILResolution.Msx2Plus2x1i:
			return "MSX2+";
		case RECOILResolution.MsxV99901x1:
			return "MSX V9990 VDP";
		case RECOILResolution.Oric1x1:
			return "Oric";
		case RECOILResolution.Pc1x1:
			return "PC";
		case RECOILResolution.Pc801x2:
			return "NEC PC-80";
		case RECOILResolution.Pc881x2:
			return "NEC PC-88";
		case RECOILResolution.Pc88Va1x1:
			return "NEC PC-88 VA";
		case RECOILResolution.Pc981x1:
			return "NEC PC-98";
		case RECOILResolution.PlayStation1x1:
			return "PlayStation";
		case RECOILResolution.Psion31x1:
			return "Psion Series 3";
		case RECOILResolution.SamCoupe1x1:
		case RECOILResolution.SamCoupe1x2:
			return "SAM Coupe";
		case RECOILResolution.X68K1x1:
			return "Sharp X68000";
		case RECOILResolution.Tandy1x1:
			return "Tandy 1000";
		case RECOILResolution.Spectrum1x1:
		case RECOILResolution.Spectrum4x4:
			return "ZX Spectrum";
		case RECOILResolution.SpectrumUlaPlus1x1:
			return "ZX Spectrum ULAplus";
		case RECOILResolution.ZxEvolution1x1:
			return "ZX Evolution";
		case RECOILResolution.SpectrumNext1x1:
			return "ZX Spectrum Next";
		case RECOILResolution.Timex1x1:
		case RECOILResolution.Timex1x2:
			return "Timex 2048";
		case RECOILResolution.Trs1x1:
		case RECOILResolution.Trs1x2:
			return "TRS-80";
		case RECOILResolution.Coco1x1:
		case RECOILResolution.Coco2x2:
			return "TRS-80 Color Computer";
		case RECOILResolution.Zx811x1:
			return "ZX81";
		default:
			return "Unknown";
		}
	}

	/// Returns original width of the decoded image (informational).
	public int GetOriginalWidth()
	{
		switch (Resolution) {
		case RECOILResolution.Amiga2x1:
		case RECOILResolution.AmigaHame2x1:
		case RECOILResolution.Amstrad2x1:
		case RECOILResolution.Xe2x1:
		case RECOILResolution.Xe2x2:
		case RECOILResolution.Vbxe2x1:
		case RECOILResolution.Tt2x1:
		case RECOILResolution.Falcon2x1:
		case RECOILResolution.Bbc2x1:
		case RECOILResolution.Vic202x1:
		case RECOILResolution.C162x1:
		case RECOILResolution.C642x1:
		case RECOILResolution.Coco2x2:
		case RECOILResolution.Msx22x1i:
		case RECOILResolution.Msx2Plus2x1i:
			return Width >> 1;
		case RECOILResolution.Amiga4x1:
		case RECOILResolution.Msx14x4:
		case RECOILResolution.Spectrum4x4:
		case RECOILResolution.Xe4x1:
		case RECOILResolution.Xe4x2:
		case RECOILResolution.Xe4x4:
			return Width >> 2;
		case RECOILResolution.Amiga8x1:
		case RECOILResolution.Xe8x8:
			return Width >> 3;
		default:
			return Width;
		}
	}

	/// Returns original height of the decoded image (informational).
	public int GetOriginalHeight()
	{
		switch (Resolution) {
		case RECOILResolution.Amiga1x2:
		case RECOILResolution.Amstrad1x2:
		case RECOILResolution.AppleIIe1x2:
		case RECOILResolution.AppleIIGS1x2:
		case RECOILResolution.Xe2x2:
		case RECOILResolution.Xe4x2:
		case RECOILResolution.St1x2:
		case RECOILResolution.Ste1x2:
		case RECOILResolution.Bbc1x2:
		case RECOILResolution.Msx21x2:
		case RECOILResolution.Pc801x2:
		case RECOILResolution.Pc881x2:
		case RECOILResolution.SamCoupe1x2:
		case RECOILResolution.Timex1x2:
		case RECOILResolution.Trs1x2:
		case RECOILResolution.Coco2x2:
			return Height >> 1;
		case RECOILResolution.Amiga1x4:
		case RECOILResolution.Msx14x4:
		case RECOILResolution.Spectrum4x4:
		case RECOILResolution.Xe4x4:
			return Height >> 2;
		case RECOILResolution.Xe8x8:
			return Height >> 3;
		default:
			return Height;
		}
	}

	// Vertical pixel density per meter for a 12 inch TV assuming interlaced picture.
	// 640x480 yields 800 virtual diagonal pixels.
	// Divide by 12 inches to calculate the DPI.
	// Divide by 0.0254 to convert inches to meters.
	const int PalTvYPixelsPerMeter = 800 * 10000 / (12 * 254);
	const int NtscTvYPixelsPerMeter = 800 * 10000 / (12 * 254); // FIXME

	// Dot clock for square pixels in the PAL and NTSC systems.
	const int PalSquareDotClock = 14750000;
	const int NtscSquareDotClock = 12272727;

	// http://www.atari.org.pl/forum/viewtopic.php?id=17147
	const int PortfolioPixelsPerMeter = 240 * 1000 / 113;

	/// Returns horizontal pixel density per meter or zero if unknown.
	public int GetXPixelsPerMeter()
	{
		switch (Resolution) {
		case RECOILResolution.AppleII1x1:
			// https://pineight.com/mw/index.php?title=Dot_clock_rates
			return NtscTvYPixelsPerMeter * 7 / 12;
		case RECOILResolution.Xe1x1:
		case RECOILResolution.Xe2x1:
		case RECOILResolution.Xe4x1:
		case RECOILResolution.Xe2x2:
		case RECOILResolution.Xe4x2:
		case RECOILResolution.Xe4x4:
		case RECOILResolution.Xe8x8:
		case RECOILResolution.Vbxe1x1:
		case RECOILResolution.Vbxe2x1:
			// https://pineight.com/mw/index.php?title=Dot_clock_rates
			// http://virtualdub.org/downloads/Altirra%20Hardware%20Reference%20Manual.pdf
			return Ntsc ? NtscTvYPixelsPerMeter * 7 / 12
				: PalTvYPixelsPerMeter * (1773447 * 4 / 1000) / (PalSquareDotClock / 1000);
		case RECOILResolution.Portfolio1x1:
			return PortfolioPixelsPerMeter;
		case RECOILResolution.C641x1:
		case RECOILResolution.C642x1:
			// https://codebase64.org/doku.php?id=base:cpu_clocking
			// https://codebase64.org/doku.php?id=base:pixel_aspect_ratio
			return Ntsc ? NtscTvYPixelsPerMeter * 2 / 3
				: PalTvYPixelsPerMeter * (17734475 * 8 / 18000) / (PalSquareDotClock / 1000);
		case RECOILResolution.Msx11x1:
		case RECOILResolution.Msx14x4:
		case RECOILResolution.Msx21x1:
		case RECOILResolution.Msx2Plus1x1:
			// https://pineight.com/mw/index.php?title=Dot_clock_rates
			return NtscTvYPixelsPerMeter * 7 / 16;
		case RECOILResolution.Msx21x2:
		case RECOILResolution.Msx21x1i:
		case RECOILResolution.Msx22x1i:
		case RECOILResolution.Msx2Plus2x1i:
			// https://pineight.com/mw/index.php?title=Dot_clock_rates
			return NtscTvYPixelsPerMeter * 7 / 8;
		// TODO: other platforms
		default:
			return 0;
		}
	}

	/// Returns vertical pixel density per meter or zero if unknown.
	public int GetYPixelsPerMeter()
	{
		switch (Resolution) {
		case RECOILResolution.AppleII1x1:
			return NtscTvYPixelsPerMeter / 2;
		case RECOILResolution.Xe1x1:
		case RECOILResolution.Xe2x1:
		case RECOILResolution.Xe4x1:
		case RECOILResolution.Xe2x2:
		case RECOILResolution.Xe4x2:
		case RECOILResolution.Xe4x4:
		case RECOILResolution.Xe8x8:
		case RECOILResolution.Vbxe1x1:
		case RECOILResolution.Vbxe2x1:
			return Ntsc ? NtscTvYPixelsPerMeter / 2 : PalTvYPixelsPerMeter / 2;
		case RECOILResolution.Portfolio1x1:
			return PortfolioPixelsPerMeter;
		case RECOILResolution.C641x1:
		case RECOILResolution.C642x1:
			return Ntsc ? NtscTvYPixelsPerMeter / 2 : PalTvYPixelsPerMeter / 2;
		case RECOILResolution.Msx11x1:
		case RECOILResolution.Msx14x4:
		case RECOILResolution.Msx21x1:
		case RECOILResolution.Msx2Plus1x1:
			// TODO: PAL?
			return NtscTvYPixelsPerMeter / 2;
		case RECOILResolution.Msx21x2:
		case RECOILResolution.Msx21x1i:
		case RECOILResolution.Msx22x1i:
		case RECOILResolution.Msx2Plus2x1i:
			return NtscTvYPixelsPerMeter;
		// TODO: other platforms
		default:
			return 0;
		}
	}

	/// Returns horizontal pixel density per inch or zero if unknown.
	public float GetXPixelsPerInch() => GetXPixelsPerMeter() * 0.0254;

	/// Returns vertical pixel density per inch or zero if unknown.
	public float GetYPixelsPerInch() => GetYPixelsPerMeter() * 0.0254;

	/// Returns the number of alternating frames the pictures is composed of.
	/// * 1 means the picture doesn't flicker.
	/// * 2 means the picture is displayed by quickly alternating two sub-pictures.
	/// * 3 means the picture is displayed by alternating three sub-pictures.
	public int GetFrames() => Frames;

	// One bit for each RGB value.
	byte[]# ColorInUse = null;

	// Number of unique colors in `pixels`.
	int Colors;
	const int UnknownColors = -1;

	// Unique colors.
	// Values are in ascending order for the sake of binary search.
	int[256] Palette;

	byte[]# Indexes = null;
	int IndexesLength = 0;

	/// Calculates palette for the decoded picture.
	void CalculatePalette!()
	{
		const int colorInUseLength = 256 * 256 * 256 / 8;
		if (ColorInUse == null)
			ColorInUse = new byte[colorInUseLength];
		ColorInUse.Fill(0, 0, colorInUseLength);
		Colors = 0;
		Palette.Fill(0);
		int pixelsCount = Width * Height;
		for (int pixelsOffset = 0; pixelsOffset < pixelsCount; pixelsOffset++) {
			int rgb = Pixels[pixelsOffset];
			int i = rgb >> 3;
			int mask = 1 << (rgb & 7);
			if ((ColorInUse[i] & mask) == 0) {
				ColorInUse[i] |= mask;
				if (Colors < 256)
					Palette[Colors] = rgb;
				Colors++;
			}
		}
	}

	/// Returns number of unique colors in the decoded picture.
	public int GetColors!()
	{
		if (Colors == UnknownColors)
			CalculatePalette();
		return Colors;
	}

	/// Find the index of the `rgb` color in the sorted palette.
	int FindInSortedPalette(int rgb)
	{
		int left = 0;
		int right = Colors;
		while (left < right) {
			int index = (left + right) >> 1;
			int paletteRgb = Palette[index];
			if (rgb == paletteRgb)
				return index;
			if (rgb < paletteRgb)
				right = index;
			else
				left = index + 1;
		}
		return 0; // throw "Internal error";
	}

	/// Converts the decoded picture to palette-indexed.
	/// Returns palette of 256 0xRRGGBB entries.
	/// Call `GetColors()` for the actual number of colors.
	/// Returns `null` if conversion fails,
	/// because there are more than 256 colors.
	public int[] ToPalette!()
	{
		if (Colors == UnknownColors)
			CalculatePalette();
		if (Colors > 256)
			return null;
		Palette.Sort(0, Colors);
		int pixelsLength = Width * Height;
		if (IndexesLength < pixelsLength) {
			IndexesLength = pixelsLength;
			Indexes = null; // free first
			Indexes = new byte[pixelsLength];
		}
		for (int i = 0; i < pixelsLength; i++)
			Indexes[i] = FindInSortedPalette(Pixels[i]);
		return Palette;
	}

	/// Returns the palette-indexed picture,
	/// as a bitmap of `GetHeight()` rows of `GetWidth()` pixels.
	/// Call after `ToPalette()` returns non-null.
	public byte[] GetIndexes() => Indexes;
}
