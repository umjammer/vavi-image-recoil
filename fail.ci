// fail.ci - FAIL core
//
// Copyright (C) 2009-2013  Piotr Fusik and Adrian Matoga
//
// This file is part of FAIL (First Atari Image Library),
// see http://fail.sourceforge.net
//
// FAIL is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published
// by the Free Software Foundation; either version 2 of the License,
// or (at your option) any later version.
//
// FAIL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FAIL; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

/// Platform and pixel ratio.
enum FAILResolution
{
	Xe1x1,
	Xe2x1,
	Xe4x1,
	Xe2x2,
	Xe4x2,
	St1x1,
	St1x2,
	Ste1x1,
	Ste1x2,
	Falcon1x1,
	Portfolio1x1,
	Amiga1x1
}

/// Readable in-memory stream of bits, most-significant bit first.
class BitStream
{
	byte[] Content;
	int ContentOffset;
	int ContentLength;
	int Bits; // 8 bits sliding left with a trailing 1

	BitStream()
	{
		// Make sure we fetch a byte on first read.
		// 0x80 would do just as well.
		Bits = 0;
	}

	/// Reads one bit (0 or 1).
	/// Returns -1 on end of stream.
	int ReadBit()
	{
		if ((Bits & 0x7f) == 0) {
			if (ContentOffset >= ContentLength)
				return -1;
			Bits = Content[ContentOffset++] << 1 | 1;
		}
		else
			Bits <<= 1;
		return Bits >> 8 & 1;
	}

	/// Reads the requested number of bits and returns them
	/// as an unsigned integer with the first bit read as the most significant.
	/// Returns -1 on end of stream.
	int ReadBits(int count)
	{
		int result = 0;
		while (--count >= 0) {
			int bit = ReadBit();
			if (bit < 0)
				return -1;
			result = result << 1 | bit;
		}
		return result;
	}
}

/// Readable in-memory Run-Length-Encoded stream.
/// This class contains the compression logic.
/// Subclasses must implement `ReadCommand()`
/// and are allowed to override `ReadValue()`.
abstract class RleStream : BitStream
{
	/// Block length.
	int RepeatCount;

	/// Value for an RLE block, -1 for a block of literals.
	int RepeatValue;

	RleStream()
	{
		// Start with a new block.
		RepeatCount = 0;
	}

	int ReadByte()
	{
		if (ContentOffset >= ContentLength)
			return -1;
		return Content[ContentOffset++];
	}

	/// Decodes a block from the stream.
	/// Fills `RepeatCount` with the length of the block.
	/// Sets `RepeatValue` to the RLE value
	/// or -1 if the block consists of `RepeatCount` literals.
	/// Returns `false` on end of stream.
	abstract bool ReadCommand();

	virtual int ReadValue()
	{
		return ReadByte();
	}

	int ReadRle()
	{
		while (RepeatCount == 0) {
			if (!ReadCommand())
				return -1;
		}
		RepeatCount--;
		if (RepeatValue >= 0)
			return RepeatValue;
		return ReadValue();
	}

	/// Uncompresses `unpackedCount` bytes to `unpacked` at `unpackedOffset`.
	/// If `unpackedStride` equals one, bytes are laid out sequentially.
	/// Otherwise bytes are laid out vertically column by column,
	/// `unpackedStride` being line width.
	bool Unpack(byte[] unpacked, int unpackedOffset, int unpackedStride, int unpackedCount)
	{
		for (int offset = 0; ; ) {
			int b = ReadRle();
			if (b < 0)
				return false;
			unpacked[unpackedOffset + offset] = b;
			offset += unpackedStride;
			if (offset >= unpackedCount) {
				if (unpackedStride > 1)
					offset -= unpackedCount - 1;
				if (offset >= unpackedStride)
					return true;
			}
		}
	}
}

class HpmStream : RleStream
{
	override bool ReadCommand()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b == 0) {
			RepeatValue = ReadByte();
			RepeatCount = ReadByte();
		}
		else {
			RepeatCount = b;
			RepeatValue = -1;
		}
		return true;
	}
}

class PgcStream : RleStream
{
	override bool ReadCommand()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			RepeatCount = b;
			RepeatValue = -1;
		}
		else {
			RepeatCount = b - 128;
			RepeatValue = ReadByte();
		}
		return true;
	}
}

class CciStream : RleStream
{
	override bool ReadCommand()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			RepeatCount = b + 1;
			RepeatValue = -1;
		}
		else {
			RepeatCount = b - 127;
			RepeatValue = ReadByte();
		}
		return true;
	}

	bool UnpackGr15(byte[] unpacked, int unpackedOffset)
	{
		ContentOffset += 4;
		RepeatCount = 0;
		for (int offset = 0; ; ) {
			int b = ReadRle();
			if (b < 0)
				return false;
			unpacked[unpackedOffset + offset] = b;
			offset += 80;
			if (offset >= 7680) {
				offset -= 7679;
				if (offset >= 40)
					return true;
			}
		}
	}
}

class PackBitsStream : RleStream
{
	override bool ReadCommand()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			RepeatCount = b + 1;
			RepeatValue = -1;
		}
		else if (b > 128) {
			RepeatCount = 257 - b;
			RepeatValue = ReadByte();
		}
		else
			RepeatCount = 0;
		return true;
	}
}

class SpcStream : RleStream
{
	override bool ReadCommand()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			RepeatCount = b + 1;
			RepeatValue = -1;
		}
		else {
			RepeatCount = 258 - b;
			RepeatValue = ReadByte();
		}
		return true;
	}
}

class SpsStream : RleStream
{
	override bool ReadCommand()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			RepeatCount = b + 3;
			RepeatValue = ReadByte();
		}
		else {
			RepeatCount = b - 127;
			RepeatValue = -1;
		}
		return true;
	}
}

class PacStream : RleStream
{
	override bool ReadCommand()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b == Content[4]) {
			b = ReadByte();
			if (b < 0)
				return false;
			RepeatCount = b + 1;
			RepeatValue = Content[5];
		}
		else if (b == Content[6]) {
			RepeatValue = ReadByte();
			if (RepeatValue < 0)
				return false;
			b = ReadByte();
			if (b < 0)
				return false;
			RepeatCount = b + 1;
		}
		else {
			RepeatCount = 1;
			RepeatValue = b;
		}
		return true;
	}
}

class XlpStream : RleStream
{
	override bool ReadCommand()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		bool rle;
		if (b < 128)
			rle = false;
		else {
			b -= 128;
			rle = true;
		}
		RepeatCount = b;
		if (b >= 0x40) {
			b = ReadByte();
			if (b < 0)
				return false;
			RepeatCount = RepeatCount - 0x40 << 8 | b;
		}
		RepeatValue = rle ? ReadByte() : -1;
		return true;
	}
}

class KoalaStream : RleStream
{
	override bool ReadCommand()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		bool rle;
		if (b < 128)
			rle = true;
		else {
			b -= 128;
			rle = false;
		}
		if (b == 0) {
			int hi = ReadByte();
			if (hi < 0)
				return false;
			b = ReadByte();
			if (b < 0)
				return false;
			b |= hi << 8;
		}
		RepeatCount = b;
		RepeatValue = rle ? ReadByte() : -1;
		return true;
	}

	static bool UnpackKoala(int type, byte[] content, int contentOffset, int contentLength, byte[] unpacked, int unpackedLength)
	{
		KoalaStream() rle;
		rle.Content = content;
		rle.ContentOffset = contentOffset;
		rle.ContentLength = contentLength;
		switch (type) {
		case 0:
			if (contentLength - contentOffset != unpackedLength)
				return false;
			content.CopyTo(contentOffset, unpacked, 0, unpackedLength);
			return true;
		case 1:
			for (int x = 0; x < 40; x++) {
				for (int offset = x; offset < 80; offset += 40) {
					for (int unpackedOffset = offset; unpackedOffset < unpackedLength; unpackedOffset += 80) {
						int b = rle.ReadRle();
						if (b < 0)
							return false;
						unpacked[unpackedOffset] = b;
					}
				}
			}
			return true;
		case 2:
			return rle.Unpack(unpacked, 0, 1, unpackedLength);
		default:
			return false;
		}
	}

	static bool UnpackKoalaWrapped(byte[] content, int contentLength, byte[] unpacked, int unpackedLength)
	{
		return contentLength >= 26
			&& content[0] == 0xff && content[1] == 0x80 && content[2] == 0xc9 && content[3] == 0xc7
			&& content[4] >= 26 && content[4] < contentLength
			&& content[5] == 0
			&& content[6] == 1 && content[8] == 0x0e
			&& content[9] == 0 && content[10] == 40
			&& content[11] == 0 && content[12] == 192
			&& content[20] == 0 && content[21] == 0
			&& UnpackKoala(content[7], content, content[4] + 1, contentLength, unpacked, unpackedLength);
	}
}

class CaStream : RleStream
{
	int EscapeByte;
	int DefaultValue;

	override bool ReadCommand()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b != EscapeByte) {
			RepeatCount = 1;
			RepeatValue = b;
			return true;
		}
		int c = ReadByte();
		if (c < 0)
			return false;
		if (c == EscapeByte) {
			RepeatCount = 1;
			RepeatValue = c;
			return true;
		}
		b = ReadByte();
		if (b < 0)
			return false;
		switch (c) {
		case 0:
			RepeatCount = b + 1;
			RepeatValue = ReadByte();
			break;
		case 1:
			c = ReadByte();
			if (c < 0)
				return false;
			RepeatCount = (b << 8) + c + 1;
			RepeatValue = ReadByte();
			break;
		case 2:
			if (b == 0)
				RepeatCount = 32000; // end decompression
			else {
				c = ReadByte();
				if (c < 0)
					return false;
				RepeatCount = (b << 8) + c + 1;
			}
			RepeatValue = DefaultValue;
			break;
		default:
			RepeatCount = c + 1;
			RepeatValue = b;
			break;
		}
		return true;
	}

	static bool UnpackCa(byte[] content, int contentOffset, int contentLength, byte[] unpacked, int unpackedOffset)
	{
		if (contentOffset + 4 > contentLength)
			return false;
		CaStream() rle;
		rle.Content = content;
		rle.ContentOffset = contentOffset + 4;
		rle.ContentLength = contentLength;
		rle.EscapeByte = content[contentOffset];
		rle.DefaultValue = content[contentOffset + 1];
		int unpackedStep = content[contentOffset + 2] << 8 | content[contentOffset + 3];
		if (unpackedStep >= 32000)
			return false;
		if (unpackedStep == 0) {
			rle.RepeatCount = 32000;
			rle.RepeatValue = rle.DefaultValue;
			unpackedStep = 1;
		}
		byte[32000] isFilled = 0;
		for (int offset = 0; ; ) {
			int b = rle.ReadRle();
			if (b < 0)
				return false;
			unpacked[unpackedOffset + offset] = b;
			isFilled[offset] = 1;
			offset += unpackedStep;
			if (offset >= 32000) {
				for (offset = 1; isFilled[offset] != 0; offset++)
					if (offset >= unpackedStep)
						return true;
			}
		}
	}

	static bool UnpackDel(byte[] content, int contentLength, byte[] unpacked, int blocks)
	{
		int contentOffset = blocks << 2;
		if (contentOffset >= contentLength)
			return false;
		int unpackedOffset = 0;
		for (int block = 0; block < blocks; block++) {
			int nextContentOffset = contentOffset + FAIL.Get32BigEndian(content, block << 2);
			if (!UnpackCa(content, contentOffset, nextContentOffset, unpacked, unpackedOffset))
				return false;
			contentOffset = nextContentOffset;
			unpackedOffset += 32000;
		}
		if (blocks == 2) {
			// Actually three blocks, but the length of the third block is implicit.
			if (!UnpackCa(content, contentOffset, contentLength, unpacked, unpackedOffset))
				return false;
		}
		return true;
	}
}

class RgbStream : RleStream
{
	override int ReadValue()
	{
		return ReadBits(12);
	}

	override bool ReadCommand()
	{
		int b = ReadBits(4);
		if (b < 0)
			return false;
		bool rle;
		if (b < 8)
			rle = true;
		else {
			b -= 8;
			rle = false;
		}
		if (b == 0) {
			b = ReadBits(4);
			if (b < 0)
				return false;
			b += 7;
		}
		if (rle) {
			RepeatValue = ReadValue();
			b++;
		}
		else
			RepeatValue = -1;
		RepeatCount = b;
		return true;
	}
}

// TNY and PCS use identical control bytes.
abstract class TnyPcsStream : RleStream
{
	override bool ReadCommand()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			if (b == 0 || b == 1) {
				if (ContentOffset + 1 >= ContentLength)
					return false;
				RepeatCount = Content[ContentOffset] << 8 | Content[ContentOffset + 1];
				ContentOffset += 2;
			}
			else
				RepeatCount = b;
			RepeatValue = b == 1 ? -1 : ReadValue();
		}
		else {
			RepeatCount = 256 - b;
			RepeatValue = -1;
		}
		return true;
	}
}

// In TNY values don't mix with control bytes.
class TnyStream : TnyPcsStream
{
	int ValueOffset;
	int ValueLength;

	override int ReadValue()
	{
		if (ValueOffset + 1 >= ValueLength)
			return -1;
		int value = Content[ValueOffset] << 8 | Content[ValueOffset + 1];
		ValueOffset += 2;
		return value;
	}
}

class PcsStream : TnyPcsStream
{
	bool Palette;

	override int ReadValue()
	{
		// one byte for bitmap
		if (!Palette)
			return ReadByte();

		// one word for palette
		if (ContentOffset + 1 >= ContentLength)
			return -1;
		int value = Content[ContentOffset] << 8 | Content[ContentOffset + 1];
		ContentOffset += 2;
		return value;
	}

	const int UnpackedLength = 32000 + 9616 * 2;

	bool UnpackPcs(byte[] unpacked)
	{
		// bitmap
		ContentOffset += 2;
		Palette = false;
		for (int unpackedOffset = 0; unpackedOffset < 32000; unpackedOffset++) {
			int b = ReadRle();
			if (b < 0)
				return false;
			unpacked[unpackedOffset] = b;
		}
		if (RepeatCount != 0)
			return false;

		// palettes
		ContentOffset += 2;
		Palette = true;
		for (int unpackedOffset = 32000; unpackedOffset < UnpackedLength; unpackedOffset += 2) {
			int b = ReadRle();
			if (b < 0)
				return false;
			unpacked[unpackedOffset] = b >> 8;
			unpacked[unpackedOffset + 1] = b.LowByte;
		}
		// Don't check RepeatCount: "PhotoChrome files with a few extra entries have been found".
		return true;
	}
}

// Similar to TNY. Differences:
// 1. Word-sized counts belong to data, not commands.
// 2. Commands 0 and 1 are swapped.
class VdatStream : TnyStream
{
	override bool ReadCommand()
	{
		int b = ReadByte();
		if (b < 0)
			return false;
		if (b < 128) {
			if (b == 0 || b == 1) {
				RepeatCount = ReadValue();
				if (RepeatCount < 0)
					return false;
			}
			else
				RepeatCount = b;
			RepeatValue = b == 0 ? -1 : ReadValue();
		}
		else {
			RepeatCount = 256 - b;
			RepeatValue = -1;
		}
		return true;
	}
}

// FlashPack 2.1
class A4rStream
{
	byte[] Content;
	int ContentOffset;
	int ContentLength;
	int OuterFlags;
	int InnerFlags;

	A4rStream()
	{
		OuterFlags = InnerFlags = 0;
	}

	int ReadByte()
	{
		if (ContentOffset >= ContentLength)
			return -1;
		return Content[ContentOffset++];
	}

	int ReadFlag()
	{
		if ((InnerFlags & 0x7f) == 0) {
			if ((OuterFlags & 0x7f) == 0) {
				if (ContentOffset >= ContentLength)
					return -1;
				OuterFlags = Content[ContentOffset++] << 1 | 1;
			}
			else
				OuterFlags <<= 1;
			if ((OuterFlags & 0x100) == 0)
				InnerFlags = 1;
			else {
				if (ContentOffset >= ContentLength)
					return -1;
				InnerFlags = Content[ContentOffset++] << 1 | 1;
			}
		}
		else
			InnerFlags <<= 1;
		return InnerFlags >> 8 & 1;
	}

	const int MinAddress = 0x4e10;
	const int MaxAddress = 0x79ff;
	const int UnpackedLength = MaxAddress - MinAddress + 1;

	byte[UnpackedLength] Unpacked;
	int UnpackedOffset;

	bool StoreByte(int value)
	{
		if (UnpackedOffset < 0 || UnpackedOffset >= UnpackedLength)
			return false;
		Unpacked[UnpackedOffset++] = value;
		return true;
	}

	bool CopyBlock(int distance, int length)
	{
		if (distance > UnpackedOffset)
			return false;
		do {
			if (!StoreByte(Unpacked[UnpackedOffset - distance]))
				return false;
		} while (--length > 0);
		return true;
	}

	bool UnpackA4r()
	{
		Unpacked.Clear();
		UnpackedOffset = -1;
		for (;;) {
			int b;
			switch (ReadFlag()) {
			case -1:
				return false;
			case 0:
				// literal byte
				b = ReadByte();
				if (b < 0)
					return false;
				if (!StoreByte(b))
					return false;
				break;
			case 1:
				b = ReadByte();
				switch (b) {
				case -1:
					return false;
				case 0:
					// new address, fist byte literal
					if (ContentOffset + 2 >= ContentLength)
						return false;
					b = ReadByte();
					UnpackedOffset = b + (ReadByte() << 8) + 0x80 - MinAddress;
					if (!StoreByte(ReadByte()))
						return false;
					break;
				case 1:
					b = ReadByte();
					switch (b) {
					case -1:
						return false;
					case 0:
						// end of stream
						return true;
					default:
						// RLE
						if (!CopyBlock(1, b + 2))
							return false;
						break;
					}
					break;
				default:
					// 2- or 3-byte LZ77
					if (!CopyBlock(0x80 - (b >> 1), 2 + (b & 1)))
						return false;
					break;
				}
				break;
			}
		}
	}
}

class FanoTree
{
	/// Count[n] == number of codes of bit length n.
	int[16] Count;
	/// Values sorted by code length.
	byte[256] Values;

	void Create(byte[] content, int contentOffset, int codeCount)
	{
		Count.Clear();
		for (int code = 0; code < codeCount; code++) {
			int bits = content[contentOffset + (code >> 1)];
			bits = (code & 1) == 0 ? bits >> 4 : bits & 0xf;
			Count[bits]++;
		}
		int[16] positions;
		int position = 0;
		for (int bits = 0; bits < 16; bits++) {
			positions[bits] = position;
			position += Count[bits];
		}
		for (int code = 0; code < codeCount; code++) {
			int bits = content[contentOffset + (code >> 1)];
			bits = (code & 1) == 0 ? bits >> 4 : bits & 0xf;
			Values[positions[bits]++] = code;
		}
	}

	int ReadCode(BitStream bitStream)
	{
		int code = 0;
		int valuesOffset = Count[0];
		for (int bits = 1; bits < 16; bits++) {
			int bit = bitStream.ReadBit();
			if (bit < 0)
				return -1;
			code = code << 1 | bit;
			int count = Count[bits];
			if (code < count)
				return Values[valuesOffset + code];
			code -= count;
			valuesOffset += count;
		}
		return -1;
	}
}

class BlazingPaddlesBoundingBox
{
	int Left;
	int Top;
	int Right;
	int Bottom;

	bool Calculate(byte[] content, int contentLength, int index, int startAddress)
	{
		if (index * 2 + 1 >= contentLength)
			return false;
		int contentOffset = content[index * 2] + (content[index * 2 + 1] << 8) - startAddress;
		if (contentOffset < 0)
			return false;
		Left = Top = Right = Bottom = 0;
		int x = 0;
		int y = 0;
		while (contentOffset < contentLength) {
			int control = content[contentOffset++];
			if (control == 0x08)
				return true;
			// bits 7-4: length-1
			int len = (control >> 4) + 1;
			// bits 1-0: direction
			switch (control & 3) {
			case 0: // right
				x += len;
				if (Right < x)
					Right = x;
				break;
			case 1: // left
				x -= len;
				if (Left > x)
					Left = x;
				break;
			case 2: // up
				y -= len;
				if (Top > y)
					Top = y;
				break;
			case 3: // down
				y += len;
				if (Bottom < y)
					Bottom = y;
				break;
			}
		}
		return false;
	}
}

public class FAIL
{
	/// FAIL version - major part.
	public const int VersionMajor = 2;
	/// FAIL version - minor part.
	public const int VersionMinor = 0;
	/// FAIL version - micro part.
	public const int VersionMicro = 0;
	/// FAIL version as a string.
	public const string Version = VersionMajor + "." + VersionMinor + "." + VersionMicro;

	/// Years FAIL was created in.
	public const string Years = "2009-2013";

	/// Short credits for FAIL.
	public const string Credits = "First Atari Image Library (C) 2009-2013 Piotr Fusik and Adrian Matoga\n";

	/// Short license notice.
	/// Display after the credits.
	public const string Copyright = 
		"This program is free software; you can redistribute it and/or modify\n" +
		"it under the terms of the GNU General Public License as published\n" +
		"by the Free Software Foundation; either version 2 of the License,\n" +
		"or (at your option) any later version.";

	public FAIL()
	{
		SetAtari8Palette(null);
	}

	/// Maximum length of a supported input file.
	/// You may assume that files longer than this are not supported by FAIL.
	public const int MaxContentLength = 350000;

	/// Maximum width of a decoded image.
	public const int MaxWidth = 640;
	/// Maximum height of a decoded image.
	public const int MaxHeight = 560;
	/// Maximum number of pixels in a decoded image.
	public const int MaxPixelsLength = 640 * 560;

	/// Decoded image width.
	int Width;
	/// Decoded image height.
	int Height;
	/// Decoded image pixels as 0xRRGGBB.
	int[MaxPixelsLength] Pixels;
	/// Platform and pixel ratio.
	FAILResolution Resolution;
	/// Number of frames (normally 1; 2 or 3 for flickering pictures).
	int Frames;

	/// Returns decoded image width.
	public int GetWidth()
	{
		return Width;
	}

	/// Returns decoded image height.
	public int GetHeight()
	{
		return Height;
	}

	/// Returns pixels of the decoded image, top-down, left-to-right.
	/// Each pixel is a 24-bit integer 0xRRGGBB.
	public int[] GetPixels()
	{
		return Pixels;
	}

	/// Maximum length of a string returned by `GetPlatform()`.
	public const int MaxPlatformLength = "Atari Portfolio".Length;

	/// Returns the computer family of the decoded file format.
	public string GetPlatform()
	{
		switch (Resolution) {
		case FAILResolution.Xe1x1:
		case FAILResolution.Xe2x1:
		case FAILResolution.Xe4x1:
		case FAILResolution.Xe2x2:
		case FAILResolution.Xe4x2:
			return "Atari 8-bit";
		case FAILResolution.St1x1:
		case FAILResolution.St1x2:
			return "Atari ST";
		case FAILResolution.Ste1x1:
		case FAILResolution.Ste1x2:
			return "Atari STE";
		case FAILResolution.Falcon1x1:
			return "Atari Falcon";
		case FAILResolution.Portfolio1x1:
			return "Atari Portfolio";
		case FAILResolution.Amiga1x1:
			return "Amiga";
		default:
			throw "Unknown";
		}
	}

	/// Returns original width of the decoded image (informational).
	public int GetOriginalWidth()
	{
		switch (Resolution) {
		case FAILResolution.Xe2x1:
		case FAILResolution.Xe2x2:
			return Width >> 1;
		case FAILResolution.Xe4x1:
		case FAILResolution.Xe4x2:
			return Width >> 2;
		default:
			return Width;
		}
	}

	/// Returns original height of the decoded image (informational).
	public int GetOriginalHeight()
	{
		switch (Resolution) {
		case FAILResolution.Xe2x2:
		case FAILResolution.Xe4x2:
		case FAILResolution.St1x2:
		case FAILResolution.Ste1x2:
			return Height >> 1;
		default:
			return Height;
		}
	}

	/// Returns the number of alternating frames the pictures is composed of.
	/// * 1 means the picture doesn't flicker.
	/// * 2 means the picture is displayed by quickly alternating two sub-pictures.
	/// * 3 means the picture is displayed by alternating three sub-pictures.
	public int GetFrames()
	{
		return Frames;
	}

	/// Initializes decoded image size and resolution.
	void SetSize(int width, int height, FAILResolution resolution)
	{
		Width = width;
		Height = height;
		Resolution = resolution;
		Frames = 1;
		Colors = UnknownColors;
		GtiaLeftSkip = 0;
	}

	void SetSizeStOrFalcon(int width, int height, int bitplanes)
	{
		SetSize(width, height, (bitplanes == 1 && width <= 640 && height <= 400)
			|| (bitplanes <= 4 && width <= 320 && height <= 200)
			? FAILResolution.St1x1 : FAILResolution.Falcon1x1);
	}

	/// Reads a 32-bit big endian integer from a byte array.
	static int Get32BigEndian(byte[] content, int contentOffset)
	{
		return content[contentOffset] << 24
			| content[contentOffset + 1] << 16
			| content[contentOffset + 2] << 8
			| content[contentOffset + 3];
	}

	static bool IsStringAt(byte[] content, int contentOffset, string s)
	{
		int length = s.Length;
		for (int i = 0; i < length; i++)
			if (content[contentOffset + i] != s[i])
				return false;
		return true;
	}

	bool DecodeBru(byte[] content, int contentLength)
	{
		if (contentLength != 64)
			return false;
		SetSize(8, 8, FAILResolution.St1x1);
		for (int i = 0; i < 64; i++) {
			switch (content[i]) {
			case 0:
				Pixels[i] = 0x000000;
				break;
			case 1:
				Pixels[i] = 0xffffff;
				break;
			default:
				return false;
			}
		}
		return true;
	}

	/// Atari ST/Falcon/Portfolio palette.
	/// Unlike Atari 8-bit, this palette is always decoded from the image file.
	int[256] Atari16Palette;

	/// Decodes Atari ST/Falcon interleaved bitplanes.
	/// Each 16 pixels are encoded in N consecutive 16-bit words.
	void DecodeBitplanes(byte[] content, int contentOffset, int bitplanes, int pixelsOffset, int pixelsCount)
	{
		for (int i = 0; i < pixelsCount; i++) {
			int offset = contentOffset + (i >> 3 & ~1) * bitplanes + (i >> 3 & 1);
			int bit = ~i & 7;
			int c = 0;
			for (int bitplane = bitplanes; --bitplane >= 0; )
				c = c << 1 | content[offset + (bitplane << 1)] >> bit & 1;
			Pixels[pixelsOffset + i] = Atari16Palette[c];
		}
	}

	void DecodeBlackAndWhite(byte[] content, int contentOffset, int width, int height, FAILResolution resolution)
	{
		SetSize(width, height, resolution);
		Atari16Palette[0] = 0xffffff;
		Atari16Palette[1] = 0x000000;
		DecodeBitplanes(content, contentOffset, 1, 0, width * height);
	}

	// Atari Portfolio formats.

	bool DecodePgf(byte[] content, int contentLength)
	{
		if (contentLength != 1920)
			return false;
		DecodeBlackAndWhite(content, 0, 240, 64, FAILResolution.Portfolio1x1);
		return true;
	}

	bool DecodePgc(byte[] content, int contentLength)
	{
		if (contentLength < 33
		 || content[0] != 'P' || content[1] != 'G' || content[2] != 1)
			return false;
		PgcStream() rle;
		rle.Content = content;
		rle.ContentOffset = 3;
		rle.ContentLength = contentLength;
		byte[1920] unpacked;
		for (int unpackedOffset = 0; unpackedOffset < 1920; unpackedOffset++) {
			int b = rle.ReadRle();
			if (b < 0) {
				if (unpackedOffset == 1919) // IRAQ.PGC
					b = 0;
				else
					return false;
			}
			unpacked[unpackedOffset] = b;
		}
		return DecodePgf(unpacked, 1920);
	}

	// Atari ST formats.

	bool DecodeDoo(byte[] content, int contentLength)
	{
		if (contentLength != 32000)
			return false;
		DecodeBlackAndWhite(content, 0, 640, 400, FAILResolution.St1x1);
		return true;
	}

	bool DecodePac(byte[] content, int contentLength)
	{
		if (contentLength < 8
		 || content[0] != 'p' || content[1] != 'M' || content[2] != '8')
			return false;
		int unpackedStride;
		switch (content[3]) {
		case '5':
			unpackedStride = 1;
			break;
		case '6':
			unpackedStride = 80;
			break;
		default:
			return false;
		}
		PacStream() rle;
		rle.Content = content;
		rle.ContentOffset = 7;
		rle.ContentLength = contentLength;
		byte[32000] unpacked;
		if (!rle.Unpack(unpacked, 0, unpackedStride, 32000))
			return false;
		return DecodeDoo(unpacked, 32000);
	}

	static bool IsStePalette(byte[] content, int contentOffset, int colors)
	{
		while (--colors >= 0) {
			if ((content[contentOffset] & 8) != 0 || (content[contentOffset + 1] & 0x88) != 0)
				return true;
			contentOffset += 2;
		}
		return false;
	}

	int GetStColor(byte[] content, int contentOffset)
	{
		int r = content[contentOffset];
		int gb = content[contentOffset + 1];
		int rgb;
		switch (Resolution) {
		case FAILResolution.Ste1x1:
		case FAILResolution.Ste1x2:
			// STE 4096 colors
			// xxxxrRRR gGGGbBBB -> 0000RRRr0000GGGg0000BBBb
			rgb = (r & 7) << 17 | (r & 8) << 13
				| (gb & 0x70) << 5 | (gb & 0x87) << 1 | (gb & 8) >> 3;
			return rgb << 4 | rgb;
		default:
			// ST 512 colors
			// xxxx0RRR 0GGG0BBB -> 00000RRR00000GGG00000BBB
			rgb = (r & 7) << 16
				| (gb & 0x70) << 4
				| (gb & 7);
			return rgb << 5 | rgb << 2 | (rgb >> 1 & 0x030303);
		}
	}

	void SetStPalette(byte[] content, int contentOffset, int colors)
	{
		for (int c = 0; c < colors; c++)
			Atari16Palette[c] = GetStColor(content, contentOffset + c * 2);
	}

	bool DecodeStLow(byte[] bitmap, int bitmapOffset, byte[] palette, int paletteOffset, int width, int height)
	{
		SetSize(width, height, IsStePalette(palette, paletteOffset, 16) ? FAILResolution.Ste1x1 : FAILResolution.St1x1);
		SetStPalette(palette, paletteOffset, 16);
		DecodeBitplanes(bitmap, bitmapOffset, 4, 0, width * height);
		return true;
	}

	void DecodeStMedium(byte[] bitmap, int bitmapOffset, byte[] palette, int paletteOffset)
	{
		SetSize(640, 400, IsStePalette(palette, paletteOffset, 4) ? FAILResolution.Ste1x2 : FAILResolution.St1x2);
		SetStPalette(palette, paletteOffset, 4);
		for (int y = 0; y < 200; y++) {
			for (int x = 0; x < 640; x++) {
				int offset = bitmapOffset + y * 160 + (x >> 2 & ~3) + (x >> 3 & 1);
				int bit = ~x & 7;
				int c = bitmap[offset] >> bit & 1 | (bitmap[offset + 2] >> bit & 1) << 1;
				int pixelsOffset = y * 1280 + x;
				Pixels[pixelsOffset + 640] = Pixels[pixelsOffset] = Atari16Palette[c];
			}
		}
	}

	bool DecodeSt(byte[] bitmap, int bitmapOffset, byte[] palette, int paletteOffset, int mode)
	{
		switch (mode) {
		case 0:
			return DecodeStLow(bitmap, bitmapOffset, palette, paletteOffset, 320, 200);
		case 1:
			DecodeStMedium(bitmap, bitmapOffset, palette, paletteOffset);
			return true;
		case 2:
			DecodeBlackAndWhite(bitmap, bitmapOffset, 640, 400, FAILResolution.St1x1);
			return true;
		default:
			return false;
		}
	}

	bool DecodePi(byte[] content, int contentLength)
	{
		if (contentLength < 32034 || content[0] != 0)
			return false;
		switch (contentLength) {
		case 32034: // DEGAS
		case 32066: // DEGAS Elite
		case 32128: // TROUBLE.PI1
			return DecodeSt(content, 34, content, 2, content[1]);
		case 44834: // 280 lines overscan
			if (content[1] != 0)
				return false;
			return DecodeStLow(content, 34, content, 2, 320, 280);
		case 116514: // 416x560 FORESTV.PI1
			if (content[1] != 0)
				return false;
			return DecodeStLow(content, 34, content, 2, 416, 560);
		default:
			return false;
		}
	}

	bool DecodePc(byte[] content, int contentLength)
	{
		if (contentLength < 68 || content[0] != 0x80 || content[1] > 2)
			return false;
		int bitplanes = 4 >> content[1];
		PackBitsStream() rle;
		rle.Content = content;
		rle.ContentOffset = 34;
		rle.ContentLength = contentLength;
		byte[32000] unpacked;
		for (int y = 0; y < 200; y++) {
			for (int bitplane = 0; bitplane < bitplanes; bitplane++) {
				for (int x = 0; x < 40 << content[1]; x++) {
					int b = rle.ReadRle();
					if (b < 0)
						return false;
					unpacked[y * 160 + (x & ~1) * bitplanes + (bitplane << 1) + (x & 1)] = b;
				}
			}
		}
		return DecodeSt(unpacked, 0, content, 2, content[1]);
	}

	bool DecodeNeo(byte[] content, int contentLength)
	{
		if (contentLength != 32128 || content[0] != 0 || content[1] != 0 || content[2] != 0)
			return false;
		return DecodeSt(content, 128, content, 4, content[3]);
	}

	bool DecodeArtDirector(byte[] content, int contentLength)
	{
		if (contentLength != 32512)
			return false;
		return DecodeStLow(content, 0, content, 32000, 320, 200);
	}

	bool DecodeGfb(byte[] content, int contentLength)
	{
		if (contentLength < 20 || !IsStringAt(content, 0, "GF25"))
			return false;
		int bitplanes;
		switch (Get32BigEndian(content, 4)) {
		case   2: bitplanes = 1; break;
		case   4: bitplanes = 2; break;
		case  16: bitplanes = 4; break;
		case 256: bitplanes = 8; break;
		default: return false;
		}
		int width = Get32BigEndian(content, 8);
		if (width <= 0 || width > MaxWidth || (width & 15) != 0)
			return false;
		int height = Get32BigEndian(content, 12);
		if (height <= 0 || height > MaxHeight)
			return false;
		int bitmapLength = Get32BigEndian(content, 16);
		if (1556 + bitmapLength != contentLength || bitmapLength != (width >> 3) * bitplanes * height)
			return false;

		for (int i = 0; i < 1 << bitplanes; i++) {
			int j;
			switch (i) {
			case   1: j = (1 << bitplanes) - 1; break;
			case   2: j = 1; break;
			case   3: j = 2; break;
			case   5: j = 6; break;
			case   6: j = 3; break;
			case   7: j = 5; break;
			case   8: j = 7; break;
			case   9: j = 8; break;
			case  10: j = 9; break;
			case  11: j = 10; break;
			case  13: j = 14; break;
			case  14: j = 11; break;
			case  15: j = 13; break;
			case 255: j = 15; break;
			default:  j = i; break;
			}
			int rgb = 0;
			for (int k = 0; k < 3; k++) {
				int offset = 20 + bitmapLength + (i * 3 + k) * 2;
				int c = content[offset] << 8 | content[offset + 1];
				if (c > 1000)
					return false;
				rgb = rgb << 8 | c * 255 / 1000;
			}
			Atari16Palette[j] = rgb;
		}

		SetSizeStOrFalcon(width, height, bitplanes);
		DecodeBitplanes(content, 20, bitplanes, 0, width * height);
		return true;
	}

	bool DecodeCa(byte[] content, int contentLength)
	{
		if (contentLength < 8
		 || content[0] != 'C' || content[1] != 'A')
			return false;
		int contentOffset;
		switch (content[3]) {
		case 0:
			contentOffset = 4 + 32;
			break;
		case 1:
			contentOffset = 4 + 8;
			break;
		case 2:
			contentOffset = 4;
			break;
		default:
			return false;
		}
		switch (content[2]) {
		case 0:
			if (contentOffset + 32000 != contentLength)
				return false;
			return DecodeSt(content, contentOffset, content, 4, content[3]);
		case 1:
			byte[32000] unpacked;
			if (!CaStream.UnpackCa(content, contentOffset, contentLength, unpacked, 0))
				return false;
			return DecodeSt(unpacked, 0, content, 4, content[3]);
		default:
			return false;
		}
	}

	bool DecodeTny(byte[] content, int contentLength)
	{
		if (contentLength < 42)
			return false;
		int mode = content[0];
		int contentOffset;
		if (mode > 2) {
			if (mode > 5)
				return false;
			mode -= 3;
			contentOffset = 4;
		}
		else
			contentOffset = 0;

		int controlLength = content[contentOffset + 33] << 8 | content[contentOffset + 34];
		int valueLength = (content[contentOffset + 35] << 8 | content[contentOffset + 36]) << 1;
		if (contentOffset + 37 + controlLength + valueLength > contentLength)
			return false;
		TnyStream() rle;
		rle.Content = content;
		rle.ContentOffset = contentOffset + 37;
		rle.ValueOffset = rle.ContentLength = contentOffset + 37 + controlLength;
		rle.ValueLength = contentOffset + 37 + controlLength + valueLength;

		byte[32000] unpacked;
		for (int bitplane = 0; bitplane < 8; bitplane += 2) {
			for (int x = bitplane; x < 160; x += 8) {
				for (int unpackedOffset = x; unpackedOffset < 32000; unpackedOffset += 160) {
					int b = rle.ReadRle();
					if (b < 0)
						return false;
					unpacked[unpackedOffset] = b >> 8;
					unpacked[unpackedOffset + 1] = b.LowByte;
				}
			}
		}

		return DecodeSt(unpacked, 0, content, contentOffset + 1, mode);
	}

	bool DecodeCpt(byte[] content, int contentLength)
	{
		if (contentLength < 40 || content[32] != 0 || content[33] > 2)
			return false;
		int bitplanes = 4 >> content[33];
		byte[32000] unpacked;
		byte[16000] isFilled = 0;
		int contentOffset = 34;

		// RLE
		for (;;) {
			int nextContentOffset = contentOffset + 4 + bitplanes * 2;
			if (nextContentOffset > contentLength)
				return false;
			int repeatCount = content[contentOffset] << 8 | content[contentOffset + 1];
			if (repeatCount == 0xffff) {
				contentOffset = nextContentOffset;
				break;
			}
			int offset = (content[contentOffset + 2] << 8 | content[contentOffset + 3]) * bitplanes;
			do {
				if (offset >= 16000)
					return false;
				for (int bitplane = 0; bitplane < bitplanes; bitplane++) {
					unpacked[offset * 2] = content[contentOffset + 4 + bitplane * 2];
					unpacked[offset * 2 + 1] = content[contentOffset + 4 + bitplane * 2 + 1];
					isFilled[offset++] = 1;
				}
			} while (--repeatCount >= 0);
			contentOffset = nextContentOffset;
		}

		// fill in holes
		for (int offset = 0; offset < 16000; offset++) {
			if (isFilled[offset] == 0) {
				if (contentOffset + 1 >= contentLength)
					return false;
				unpacked[offset * 2] = content[contentOffset++];
				unpacked[offset * 2 + 1] = content[contentOffset++];
			}
		}

		return DecodeSt(unpacked, 0, content, 0, content[33]);
	}

	bool DecodeSpu(byte[] content, int contentLength)
	{
		if (contentLength != 51104)
			return false;
		SetSize(320, 199, IsStePalette(content, 32000, 199 * 3 * 16) ? FAILResolution.Ste1x1 : FAILResolution.St1x1);
		int pixelsOffset = 0;
		for (int y = 0; y < 199; y++) {
			for (int x = 0; x < 320; x++) {
				int bitmapOffset = 160 + (pixelsOffset >> 1 & ~7) + (x >> 3 & 1);
				int bit = ~x & 7;
				int c = (content[bitmapOffset] >> bit & 1) << 1
					| (content[bitmapOffset + 2] >> bit & 1) << 2
					| (content[bitmapOffset + 4] >> bit & 1) << 3
					| (content[bitmapOffset + 6] >> bit & 1) << 4;
				// http://www.atari-forum.com/wiki/index.php?title=ST_Picture_Formats
				int x1 = c * 5 + 1 - (c & 2) * 3;
				if (x >= x1 + 160)
					c += 64;
				else if (x >= x1)
					c += 32;
				Pixels[pixelsOffset++] = GetStColor(content, 32000 + y * 96 + c);
			}
		}
		return true;
	}

	static bool UnpackSpc(RleStream rle, byte[] unpacked)
	{
		for (int bitplane = 0; bitplane < 8; bitplane += 2) {
			for (int unpackedOffset = 160 + bitplane; unpackedOffset < 32000; unpackedOffset += 8) {
				for (int x = 0; x < 2; x++) {
					int b = rle.ReadRle();
					if (b < 0)
						return false;
					unpacked[unpackedOffset + x] = b;
				}
			}
		}
		return true;
	}

	bool DecodeStSpc(byte[] content, int contentLength)
	{
		if (contentLength < 12
		 || content[0] != 'S' || content[1] != 'P')
			return false;
		byte[51104] unpacked;

		// bitmap
		SpcStream() rle;
		rle.Content = content;
		rle.ContentOffset = 12;
		rle.ContentLength = contentLength;
		if (!UnpackSpc(rle, unpacked))
			return false;

		// palettes
		int contentOffset = 12 + Get32BigEndian(content, 4);
		for (int unpackedOffset = 32000; unpackedOffset < 51104; ) {
			if (contentOffset + 1 >= contentLength)
				return false;
			int got = content[contentOffset] << 8 | content[contentOffset + 1];
			contentOffset += 2;
			for (int i = 0; i < 16; i++) {
				if ((got >> i & 1) == 0) {
					unpacked[unpackedOffset] = 0;
					unpacked[unpackedOffset + 1] = 0;
				}
				else {
					if (contentOffset + 1 >= contentLength)
						return false;
					unpacked[unpackedOffset] = content[contentOffset];
					unpacked[unpackedOffset + 1] = content[contentOffset + 1];
					contentOffset += 2;
				}
				unpackedOffset += 2;
			}
		}

		return DecodeSpu(unpacked, 51104);
	}

	bool DecodeSps(byte[] content, int contentLength)
	{
		if (contentLength < 13
		 || content[0] != 'S' || content[1] != 'P' || content[2] != 0 || content[3] != 0)
			return false;
		byte[51104] unpacked;

		// bitmap
		SpsStream() rle;
		rle.Content = content;
		rle.ContentOffset = 12;
		rle.ContentLength = contentLength;
		if ((content[contentLength - 1] & 1) == 0) {
			for (int bitplane = 0; bitplane < 8; bitplane += 2) {
				for (int x = 0; x < 40; x++) {
					for (int unpackedOffset = 160 + ((x & ~1) << 2) + bitplane + (x & 1); unpackedOffset < 32000; unpackedOffset += 160) {
						int b = rle.ReadRle();
						if (b < 0)
							return false;
						unpacked[unpackedOffset] = b;
					}
				}
			}
		}
		else {
			if (!UnpackSpc(rle, unpacked))
				return false;
		}

		// palettes
		BitStream() bitStream;
		bitStream.Content = content;
		bitStream.ContentOffset = 12 + Get32BigEndian(content, 4);
		bitStream.ContentLength = contentLength;
		for (int unpackedOffset = 32000; unpackedOffset < 51104; ) {
			int got = bitStream.ReadBits(14);
			if (got < 0)
				return false;
			got <<= 1;
			for (int i = 15; i >= 0; i--) {
				int rgb;
				if ((got >> i & 1) == 0)
					rgb = 0;
				else {
					rgb = bitStream.ReadBits(9);
					if (rgb < 0)
						return false;
				}
				// RRRGGGBBB -> 00000RRR 0GGG0BBB
				unpacked[unpackedOffset] = rgb >> 6;
				unpacked[unpackedOffset + 1] = (rgb & 0x3f) + (rgb & 0x38);
				unpackedOffset += 2;
			}
		}

		return DecodeSpu(unpacked, 51104);
	}

	void DecodePcsScreen(byte[] unpacked, int pixelsOffset)
	{
		for (int y = 0; y < 199; y++) {
			for (int x = 0; x < 320; x++) {
				int bitmapOffset = 40 + y * 40 + (x >> 3);
				int bit = ~x & 7;
				int c = (unpacked[bitmapOffset] >> bit & 1) << 1
					| (unpacked[8000 + bitmapOffset] >> bit & 1) << 2
					| (unpacked[16000 + bitmapOffset] >> bit & 1) << 3
					| (unpacked[24000 + bitmapOffset] >> bit & 1) << 4;
				// http://www.atari-forum.com/wiki/index.php?title=ST_Picture_Formats
				if (x >= c * 2) {
					if (c < 14 * 2) {
						if (x >= c * 2 + 76) {
							if (x >= 176 + c * 5 - (c & 2) * 3)
								c += 32;
							c += 32;
						}
					}
					else if (x >= c * 2 + 92)
						c += 32;
					c += 32;
				}
				Pixels[pixelsOffset++] = GetStColor(unpacked, 32000 + y * 96 + c);
			}
		}
	}

	bool DecodePcs(byte[] content, int contentLength)
	{
		if (contentLength < 18
		 || content[0] != 0x01 || content[1] != 0x40 || content[2] != 0x00 || content[3] != 0xc8)
			return false;

		PcsStream() rle;
		rle.Content = content;
		rle.ContentOffset = 6;
		rle.ContentLength = contentLength;
		byte[PcsStream.UnpackedLength] unpacked1;
		if (!rle.UnpackPcs(unpacked1))
			return false;
		// FIXME: I only check if first screen's colors are STE
		SetSize(320, 199, IsStePalette(unpacked1, 32000, 9616) ? FAILResolution.Ste1x1 : FAILResolution.St1x1);
		DecodePcsScreen(unpacked1, 0);
		if (content[4] == 0)
			return true; // single screen

		// alternating screens
		Frames = 2;
		rle.RepeatCount = 0; // ignore possible overrun from first picture palettes
		byte[PcsStream.UnpackedLength] unpacked2;
		if (!rle.UnpackPcs(unpacked2))
			return false;
		if ((content[4] & 1) == 0) {
			for (int i = 0; i < 32000; i++)
				unpacked2[i] ^= unpacked1[i];
		}
		if ((content[4] & 2) == 0) {
			for (int i = 32000; i < PcsStream.UnpackedLength; i++)
				unpacked2[i] ^= unpacked1[i];
		}
		DecodePcsScreen(unpacked2, 320 * 199);

		for (int i = 0; i < 320 * 199; i++) {
			int rgb1 = Pixels[i];
			int rgb2 = Pixels[320 * 199 + i];
			// This clever formula just computes the byte-by-byte averages.
			Pixels[i] = (rgb1 & rgb2) + ((rgb1 ^ rgb2) >> 1 & 0x7f7f7f);
		}
		return true;
	}

	// Atari Falcon formats.

	void SetFalconPalette(byte[] content, int contentOffset)
	{
		for (int i = 0; i < 256; i++) {
			int offset = contentOffset + (i << 2);
			Atari16Palette[i] = content[offset] << 16 | content[offset + 1] << 8 | content[offset + 3];
		}
	}

	void DecodeFalconPalette320(byte[] content, int bitplanesOffset, int paletteOffset, int height)
	{
		SetFalconPalette(content, paletteOffset);
		SetSize(320, height, FAILResolution.Falcon1x1);
		DecodeBitplanes(content, bitplanesOffset, 8, 0, 320 * height);
	}

	bool DecodePi4(byte[] content, int contentLength)
	{
		int height;
		switch (contentLength) {
		case 65024:
			height = 200;
			break;
		case 77824:
			height = 240;
			break;
		default:
			return false;
		}
		DecodeFalconPalette320(content, 1024, 0, height);
		return true;
	}

	bool DecodeDgu(byte[] content, int contentLength)
	{
		if (contentLength != 65032
		 || content[0] != 'D' || content[1] != 'G' || content[2] != 'U' || content[3] != 1
		 || content[4] != 1 || content[5] != 64 || content[6] != 0 || content[7] != 200)
			return false;
		DecodeFalconPalette320(content, 1032, 8, 200);
		return true;
	}

	bool DecodeDgc(byte[] content, int contentLength)
	{
		if (contentLength < 1042
		 || content[0] != 'D' || content[1] != 'G' || content[2] != 'C' || content[3] > 3
		 || content[4] != 1 || content[5] != 64 || content[6] != 0 || content[7] != 200)
			return false;
		if (content[3] == 0) {
			if (contentLength != 65034)
				return false;
			DecodeFalconPalette320(content, 1034, 10, 200);
			return true;
		}

		byte[64000] unpacked;
		int contentOffset = 1038;
		int valueBytes = 1 << content[3] - 1; // 1, 2 or 4
		int repeatCount = 0;
		for (int bitplane = 0; bitplane < 16; bitplane += 2) {
			for (int unpackedOffset = bitplane; unpackedOffset < 64000; unpackedOffset += 16) {
				for (int x = 0; x < 2; x++) {
					if (repeatCount == 0) {
						int nextContentOffset = contentOffset + content[3] * 2;
						if (nextContentOffset > contentLength)
							return false;
						switch (content[3]) {
						case 1:
							repeatCount = content[contentOffset] + 1;
							break;
						case 2:
							repeatCount = (content[contentOffset] << 8) + content[contentOffset + 1] + 1 << 1;
							break;
						case 3:
							repeatCount = (content[contentOffset] << 8) + content[contentOffset + 1] + 1 << 2;
							break;
						}
						contentOffset = nextContentOffset;
					}
					repeatCount--;
					unpacked[unpackedOffset + x] = content[contentOffset - valueBytes + (~repeatCount & valueBytes - 1)];
				}
			}
		}

		SetFalconPalette(content, 10);
		SetSize(320, 200, FAILResolution.Falcon1x1);
		DecodeBitplanes(unpacked, 0, 8, 0, 320 * 200);
		return true;
	}

	bool DecodeDel(byte[] content, int contentLength)
	{
		byte[96000] unpacked;
		if (!CaStream.UnpackDel(content, contentLength, unpacked, 2))
			return false;
		return DecodePi4(unpacked, 77824);
	}

	bool DecodeDph(byte[] content, int contentLength)
	{
		byte[] unpacked = new byte[320000];
		if (!CaStream.UnpackDel(content, contentLength, unpacked, 10)) {
			delete unpacked;
			return false;
		}
		SetFalconPalette(unpacked, 0);
		SetSize(640, 480, FAILResolution.Falcon1x1);
		for (int y = 0; y < 240; y++) {
			// Combine four 320x240 quarters:
			// 1 2
			// 3 4
			DecodeBitplanes(unpacked, 1024 + y * 320, 8, y * 640, 320);
			DecodeBitplanes(unpacked, 1024 + 76800 + y * 320, 8, y * 640 + 320, 320);
			DecodeBitplanes(unpacked, 1024 + 2 * 76800 + y * 320, 8, (240 + y) * 640, 320);
			DecodeBitplanes(unpacked, 1024 + 3 * 76800 + y * 320, 8, (240 + y) * 640 + 320, 320);
		}
		delete unpacked;
		return true;
	}

	bool DecodeFalconTrueColor(byte[] content, int contentLength, int contentOffset, int width, int height)
	{
		int pixelsCount = width * height;
		if (contentOffset + pixelsCount * 2 != contentLength)
			return false;
		SetSize(width, height, FAILResolution.Falcon1x1);
		for (int i = 0; i < pixelsCount; i++) {
			int rg = content[contentOffset + i * 2];
			int gb = content[contentOffset + i * 2 + 1];
			int r = rg & 0xf8 | rg >> 5;
			int g = (rg & 7) << 3 | gb >> 5;
			g = g << 2 | g >> 4;
			int b = gb & 0x1f;
			b = b << 3 | b >> 2;
			Pixels[i] = r << 16 | g << 8 | b;
		}
		return true;
	}

	bool DecodeFalconTrueColorVariable(byte[] content, int contentLength, int widthOffset, int dataOffset)
	{
		int width = content[widthOffset] << 8 | content[widthOffset + 1];
		int height = content[widthOffset + 2] << 8 | content[widthOffset + 3];
		if (width > MaxWidth || height > MaxHeight) // TODO: resolution limits unknown
			return false;
		return DecodeFalconTrueColor(content, contentLength, dataOffset, width, height);
	}

	bool DecodeFtc(byte[] content, int contentLength)
	{
		return DecodeFalconTrueColor(content, contentLength, 0, 384, 240);
	}

	bool DecodeGod(byte[] content, int contentLength)
	{
		return contentLength > 6 && DecodeFalconTrueColorVariable(content, contentLength, 2, 6);
	}

	bool DecodeTrp(byte[] content, int contentLength)
	{
		if (contentLength < 9 || !IsStringAt(content, 0, "TRUP"))
			return false;
		return DecodeFalconTrueColorVariable(content, contentLength, 4, 8);
	}

	bool DecodeTru(byte[] content, int contentLength)
	{
		if (contentLength < 256 || !IsStringAt(content, 0, "Indy"))
			return false;
		return DecodeFalconTrueColorVariable(content, contentLength, 4, 256);
	}

	void DecodeHam(byte[] unpacked, int width, int height, int bitplanes)
	{
		int holdBits = bitplanes > 6 ? 6 : 4;
		int i = 0;
		for (int y = 0; y < height; y++) {
			int rgb = Atari16Palette[0];
			for (int x = 0; x < width; x++) {
				int offset = (i >> 3 & ~1) * bitplanes + (i >> 3 & 1);
				int bit = ~i & 7;
				int c = 0;
				for (int bitplane = bitplanes; --bitplane >= 0; )
					c = c << 1 | unpacked[offset + (bitplane << 1)] >> bit & 1;

				switch (c >> holdBits) {
				case 0:
					rgb = Atari16Palette[c];
					break;
				case 1: // blue
					c = c << 8 - holdBits & 0xff;
					c |= c >> holdBits;
					rgb = (rgb & 0xffff00) | c;
					break;
				case 2: // red
					c = c << 8 - holdBits & 0xff;
					c |= c >> holdBits;
					rgb = (rgb & 0x00ffff) | c << 16;
					break;
				case 3: // green
					c = c << 8 - holdBits & 0xff;
					c |= c >> holdBits;
					rgb = (rgb & 0xff00ff) | c << 8;
					break;
				}
				Pixels[i++] = rgb;
			}
		}
	}

	void DecodeIffUnpacked(byte[] unpacked, int width, int height, int bitplanes, int colors, int camg)
	{
		int pixelsCount = width * height;
		if (camg != 0)
			SetSize(width, height, FAILResolution.Amiga1x1);
		else
			SetSizeStOrFalcon(width, height, bitplanes);

		if (bitplanes <= 8) {
			if (colors == 0) {
				// grayscale
				colors = 1 << bitplanes;
				for (int c = 0; c < colors; c++)
					Atari16Palette[c] = c * 255 / colors * 0x010101;
			}
			else if ((camg & 0x880) == 0x80 && bitplanes == 6 && colors < 64) {
				// Amiga Extra Half-Brite
				// atarist.c by Hans Wessels says bitplanes check is necessary.
				// I also check if we don't already have 64 colors,
				// because I found such EHB files.
				for (int c = 0; c < 32; c++)
					Atari16Palette[32 + c] = Atari16Palette[c] >> 1 & 0x7f7f7f;
			}
			if ((camg & 0x800) != 0) {
				// Amiga Hold-And-Modify
				DecodeHam(unpacked, width, height, bitplanes);
			}
			else {
				// palette
				DecodeBitplanes(unpacked, 0, bitplanes, 0, pixelsCount);
			}
		}
		else {
			// 24-bit or 32-bit true color
			for (int i = 0; i < pixelsCount; i++) {
				int offset = (i >> 3 & ~1) * bitplanes + (i >> 3 & 1);
				int bit = ~i & 7;
				int c = 0;
				for (int bitplane = 24; --bitplane >= 0; )
					c = c << 1 | unpacked[offset + (bitplane << 1)] >> bit & 1;
				// 0xBBGGRR -> 0xRRGGBB
				Pixels[i] = (c & 0xff) << 16 | (c & 0xff00) | c >> 16;
			}
		}
		delete unpacked;
	}

	bool DecodeIff(byte[] content, int contentLength)
	{
		if (contentLength < 56 || !IsStringAt(content, 0, "FORM"))
			return false;
		int contentOffset = 8;
		if (IsStringAt(content, 8, "DPSTDPAH") && Get32BigEndian(content, 16) == 24 && IsStringAt(content, 44, "FORM"))
			contentOffset = 52;
		if (!IsStringAt(content, contentOffset, "ILBM") && !IsStringAt(content, contentOffset, "ACBM"))
			return false;
		contentOffset += 4;

		int width = 0;
		int height = 0;
		int bitplanes = 0;
		bool hasMask = false;
		int compression = 0;
		int colors = 0;
		int camg = 0;
		while (contentOffset + 7 < contentLength) {
			int chunkLength = Get32BigEndian(content, contentOffset + 4);
			if (contentOffset + 8 + chunkLength > contentLength)
				break;
			if (IsStringAt(content, contentOffset, "BMHD") && chunkLength >= 11) {
				width = content[contentOffset + 8] << 8 | content[contentOffset + 9];
				height = content[contentOffset + 10] << 8 | content[contentOffset + 11];
				bitplanes = content[contentOffset + 16];
				hasMask = content[contentOffset + 17] == 1;
				compression = content[contentOffset + 18];
				if (width == 0 || width > MaxWidth
				 || height == 0 || height > MaxHeight
				 || bitplanes == 0 || (bitplanes > 8 && bitplanes != 24 && bitplanes != 32)
				 || compression > 2)
					return false;
				// FIXME: round up to 16 pixels; we shouldn't show the extra pixels
				width = width + 15 & ~15;
			}
			else if (IsStringAt(content, contentOffset, "CMAP")) {
				colors = chunkLength / 3;
				if (colors > 256)
					return false;
				int c;
				for (c = 0; c < colors; c++) {
					int offset = contentOffset + 8 + c * 3;
					Atari16Palette[c] = content[offset] << 16 | content[offset + 1] << 8 | content[offset + 2];
				}
				for ( ; c < 256; c++)
					Atari16Palette[c] = 0;
			}
			else if (IsStringAt(content, contentOffset, "CAMG") && chunkLength >= 4)
				camg = Get32BigEndian(content, contentOffset + 8);
			else if (IsStringAt(content, contentOffset, "BODY")) {
				if (width == 0)
					return false;
				int bytesPerLine = (width >> 3) * bitplanes;
				byte[] unpacked = new byte[bytesPerLine * height];
				if (compression == 2) {
					VdatStream() rle;
					rle.Content = content;
					rle.ContentOffset = contentOffset + 8;
					for (int bitplane = 0; bitplane < bitplanes; bitplane++) {
						if (rle.ContentOffset + 14 > contentLength || !IsStringAt(content, rle.ContentOffset, "VDAT"))
							return false;
						int nextContentOffset = rle.ContentOffset + 8 + Get32BigEndian(content, rle.ContentOffset + 4);
						if (nextContentOffset > contentOffset + 8 + chunkLength)
							return false;
						rle.ValueOffset = rle.ContentLength = rle.ContentOffset + 8 + (content[rle.ContentOffset + 8] << 8) + content[rle.ContentOffset + 9];
						rle.ValueLength = nextContentOffset;
						rle.ContentOffset += 10;
						for (int x = bitplane << 1; x < bytesPerLine; x += bitplanes << 1) {
							int unpackedOffset = x;
							for (int y = 0; y < height; y++) {
								int b = rle.ReadRle();
								if (b < 0)
									return false;
								unpacked[unpackedOffset] = b >> 8;
								unpacked[unpackedOffset + 1] = b.LowByte;
								unpackedOffset += bytesPerLine;
							}
						}
						rle.ContentOffset = nextContentOffset;
					}
				}
				else {
					PackBitsStream() rle;
					rle.Content = content;
					rle.ContentOffset = contentOffset + 8;
					rle.ContentLength = contentOffset + 8 + chunkLength;
					for (int y = 0; y < height; y++) {
						for (int bitplane = 0; bitplane < bitplanes; bitplane++) {
							for (int w = bitplane << 1; w < bytesPerLine; w += bitplanes << 1) {
								for (int x = 0; x < 2; x++) {
									int b = compression == 0 ? rle.ReadByte() : rle.ReadRle();
									if (b < 0)
										return false;
									unpacked[y * bytesPerLine + w + x] = b;
								}
							}
						}
						if (hasMask) {
							// ignore transparency mask
							for (int x = 0; x < width; x += 8) {
								int b = compression == 0 ? rle.ReadByte() : rle.ReadRle();
								if (b < 0)
									return false;
							}
						}
					}
				}
				DecodeIffUnpacked(unpacked, width, height, bitplanes, colors, camg);
				return true;
			}
			else if (IsStringAt(content, contentOffset, "ABIT")) {
				if (width == 0 || compression != 0 || chunkLength != (width >> 3) * height * bitplanes)
					return false;
				contentOffset += 8;
				byte[] unpacked = new byte[chunkLength];
				for (int bitplane = 0; bitplane < bitplanes; bitplane++) {
					for (int unpackedOffset = bitplane << 1; unpackedOffset < chunkLength; unpackedOffset += bitplanes << 1) {
						for (int x = 0; x < 2; x++)
							unpacked[unpackedOffset + x] = content[contentOffset++];
					}
				}
				DecodeIffUnpacked(unpacked, width, height, bitplanes, colors, camg);
				return true;
			}
			contentOffset += 8 + (chunkLength + 1 & ~1); // round up to even bytes
		}
		return false;
	}

	// Atari 8-bit formats.

	int[256] Atari8Palette;

	/// Sets Atari 8-bit palette from a 768-byte array (256 times RGB).
	public void SetAtari8Palette(byte[] content)
	{
		if (content == null)
			content = BinaryResource("jakub.act");
		for (int i = 0; i < 256; i++)
			Atari8Palette[i] = content[i * 3] << 16 | content[i * 3 + 1] << 8 | content[i * 3 + 2];
	}

	static int ParseAtari8ExecutableHeader(byte[] content, int contentOffset)
	{
		if (content[contentOffset] != 0xff || content[contentOffset + 1] != 0xff)
			return -1;
		int startAddress = content[contentOffset + 2] | content[contentOffset + 3] << 8;
		int endAddress = content[contentOffset + 4] | content[contentOffset + 5] << 8;
		return endAddress - startAddress + 1;
	}

	static int GetAtari8ExecutableOffset(byte[] content, int contentLength)
	{
		if (contentLength >= 7) {
			int blockLength = ParseAtari8ExecutableHeader(content, 0);
			if (blockLength > 0 && 6 + blockLength == contentLength)
				return 6;
		}
		return 0;
	}

	bool SetAtari8RawSize(byte[] content, int contentLength, FAILResolution resolution)
	{
		int contentOffset = GetAtari8ExecutableOffset(content, contentLength);
		int height = (contentLength - contentOffset) / 40;
		if (height == 0 || height > 240)
			return false;
		SetSize(320, height, resolution);
		return true;
	}

	byte[16] GtiaColors;

	void SetGtiaColor(int reg, int value)
	{
		value &= 0xfe;
		switch (reg) {
		case 0:
		case 1:
		case 2:
		case 3:
			GtiaColors[reg] = value;
			break;
		case 4:
		case 5:
		case 6:
		case 7:
			GtiaColors[8 + reg] = GtiaColors[reg] = value;
			break;
		case 8:
			GtiaColors[11] = GtiaColors[10] = GtiaColors[9] = GtiaColors[8] = value;
			break;
		}
	}

	void SetPM123PF0123Bak(byte[] content, int contentOffset)
	{
		for (int i = 0; i < 8; i++)
			SetGtiaColor(1 + i, content[contentOffset + i]);
	}

	void SetGtiaColors(byte[] content, int contentOffset)
	{
		GtiaColors[0] = content[contentOffset] & 0xfe;
		SetPM123PF0123Bak(content, contentOffset + 1);
	}

	void SetPF21(byte[] content, int contentOffset)
	{
		GtiaColors[6] = content[contentOffset] & 0xfe;
		GtiaColors[5] = content[contentOffset + 1] & 0xfe;
	}

	void SetGr15DefaultColors()
	{
		GtiaColors[8] = 0x00;
		GtiaColors[4] = 0x04;
		GtiaColors[5] = 0x08;
		GtiaColors[6] = 0x0c;
	}

	void SetBakPF012(byte[] content, int contentOffset, int contentStride)
	{
		for (int i = 0; i < 4; i++)
			GtiaColors[i == 0 ? 8 : 3 + i] = content[contentOffset + i * contentStride] & 0xfe;
	}

	void SetPF012Bak(byte[] content, int contentOffset)
	{
		for (int i = 0; i < 4; i++)
			GtiaColors[i == 3 ? 8 : 4 + i] = content[contentOffset + i] & 0xfe;
	}

	void SetPF0123Bak(byte[] content, int contentOffset)
	{
		for (int i = 0; i < 5; i++)
			GtiaColors[4 + i] = content[contentOffset + i] & 0xfe;
	}

	void DecodeAtari8Gr8(byte[] content, int contentOffset, byte[] frame)
	{
		byte[2] colors;
		colors[0] = GtiaColors[6];
		colors[1] = GtiaColors[6] & 0xf0 | GtiaColors[5] & 0x0e;
		int pixelsLength = Width * Height;
		for (int i = 0; i < pixelsLength; i++) {
			int c = content[contentOffset + (i >> 3)] >> (~i & 7) & 1;
			frame[i] = colors[c];
		}
	}

	void DecodeAtari8Gr15(byte[] content, int contentOffset, int contentStride, byte[] frame, int frameOffset, int frameStride, int height)
	{
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < Width; x++) {
				int c = content[contentOffset + (x >> 3)] >> (~x & 6) & 3;
				frame[frameOffset + x] = GtiaColors[c == 0 ? 8 : c + 3];
			}
			contentOffset += contentStride;
			frameOffset += frameStride;
		}
	}

	void DecodeAtari8Gr7(byte[] content, int contentOffset, byte[] frame, int frameOffset, int height)
	{
		for (int y = 0; y < height; y++) {
			for (int x = 0; x < Width; x++) {
				int c = content[contentOffset + (x >> 3)] >> (~x & 6) & 3;
				frame[frameOffset + x + Width] = frame[frameOffset + x] = GtiaColors[c == 0 ? 8 : c + 3];
			}
			contentOffset += Width >> 3;
			frameOffset += Width << 1;
		}
	}

	int GtiaLeftSkip;

	void DecodeAtari8Gr9(byte[] content, int contentOffset, int contentStride, byte[] frame, int frameOffset, int frameStride, int width, int height)
	{
		frameOffset -= GtiaLeftSkip;
		for (int y = 0; y < height; y++) {
			int x;
			for (x = GtiaLeftSkip; x < width; x++) {
				int c = content[contentOffset + (x >> 3)] >> (~x & 4) & 0x0f;
				frame[frameOffset + x] = GtiaColors[8] | c;
			}
			for ( ; x < width + GtiaLeftSkip; x++)
				frame[frameOffset + x] = GtiaColors[8];
			contentOffset += contentStride;
			frameOffset += frameStride;
		}
	}

	void DecodeAtari8Gr11(byte[] content, int contentOffset, byte[] frame, int frameOffset, int frameStride, int height)
	{
		frameOffset -= GtiaLeftSkip;
		for (int y = 0; y < height; y++) {
			int x;
			for (x = GtiaLeftSkip; x < Width; x++) {
				int c = content[contentOffset + (x >> 3)] << (x & 4) & 0xf0;
				c = c == 0 ? GtiaColors[8] & 0xf0 : GtiaColors[8] | c;
				frame[frameOffset + x] = c;
			}
			for ( ; x < Width + GtiaLeftSkip; x++)
				frame[frameOffset + x] = GtiaColors[8] & 0xf0;
			contentOffset += Width >> 3;
			frameOffset += frameStride;
		}
	}

	void DecodeAtari8Gr10(byte[] content, int contentOffset, byte[] frame, int frameOffset, int frameStride, int height)
	{
		frameOffset += 2 - GtiaLeftSkip;
		for (int y = 0; y < height; y++) {
			int x;
			for (x = GtiaLeftSkip - 2; x < 0; x++)
				frame[frameOffset + x] = GtiaColors[0];
			for ( ; x < Width + GtiaLeftSkip - 2; x++) {
				int c = content[contentOffset + (x >> 3)] >> (~x & 4) & 0x0f;
				frame[frameOffset + x] = GtiaColors[c];
			}
			contentOffset += Width >> 3;
			frameOffset += frameStride;
		}
	}

	void DecodeAtari8Gr11PalBlend(byte[] content, int contentOffset, int contentStride, byte[] frame, int y)
	{
		for ( ; y < Height; y += 2) {
			int frameOffset = y * Width - GtiaLeftSkip;
			int x;
			for (x = GtiaLeftSkip; x < Width; x++) {
				int c = content[contentOffset + (x >> 3)] << (x & 4) & 0xf0;
				// Average intensity from neighboring lines. This doesn't happen on real hardware,
				// but avoids ugly aliasing with non-integer zoom factors.
				int i =
					((y == 0 ? 0 : frame[frameOffset - Width + x] & 0x0f) +
					(y == Height - 1 ? 0 : frame[frameOffset + Width + x] & 0x0f)) >> 1;
				frame[frameOffset + x] = c | i;
				// Copy hue to the next line emulating PAL color resolution reduction.
				// TODO: we should combine the two hues.
				if (y < Height - 1)
					frame[frameOffset + Width + x] = c | (frame[frameOffset + Width + x] & 0x0f);
			}
			for ( ; x < Width + GtiaLeftSkip; x++)
				frame[frameOffset + x] = 0;
			contentOffset += contentStride;
		}
	}

	static int ToAtari8Char(int ascii)
	{
		switch (ascii & 0x60) {
		case 0x00:
			return ascii + 0x40;
		case 0x20:
		case 0x40:
			return ascii - 0x20;
		default:
			return ascii;
		}
	}

	void DecodeAtari8Gr0(byte[] characters, int charactersStride, byte[] font, int fontOffset, byte[] frame)
	{
		for (int y = 0; y < Height; y++) {
			for (int x = 0; x < Width; x++) {
				int ch = characters[(y >> 3) * charactersStride + (x >> 3)];
				int b = font[fontOffset + ((ch & 0x7f) << 3) + (y & 7)];
				if (ch >= 0x80)
					b ^= 0xff;
				frame[y * Width + x] = (b >> (~x & 7) & 1) == 0 ? 0x00 : 0x0e;
			}
		}
	}

	void DecodeAtari8Gr12Line(byte[] characters, int charactersOffset, byte[] font, int fontOffset, byte[] frame, int frameOffset)
	{
		for (int y = 0; y < 8; y++) {
			for (int x = 0; x < Width; x++) {
				int ch = characters[charactersOffset + (x >> 3)];
				int c = font[fontOffset + ((ch & 0x7f) << 3) + y] >> (~x & 6) & 3;
				int gr12Registers = ch >= 0x80 ? 0x7548 : 0x6548;
				frame[frameOffset + x] = GtiaColors[gr12Registers >> (c << 2) & 0xf] & 0xfe;
			}
			frameOffset += Width;
		}
	}

	void DecodeAtari8Player(byte[] content, int contentOffset, int color, byte[] frame, int frameOffset, int height)
	{
		color &= 0xfe;
		for (int y = 0; y < height; y++) {
			int b = content[contentOffset + y];
			for (int x = 0; x < 8; x++) {
				int c = b >> (7 - x) & 1;
				if (c != 0)
					frame[frameOffset + x * 2 + 1] = frame[frameOffset + x * 2] |= color;
			}
			frameOffset += Width;
		}
	}

	bool ApplyAtari8Palette(byte[] frame)
	{
		int pixelsLength = Width * Height;
		for (int i = 0; i < pixelsLength; i++)
			Pixels[i] = Atari8Palette[frame[i]];
		return true;
	}

	bool ApplyAtari8PaletteBlend(byte[] frame1, byte[] frame2)
	{
		int pixelsLength = Width * Height;
		Frames = 2;
		for (int i = 0; i < pixelsLength; i++) {
			int rgb1 = Atari8Palette[frame1[i]];
			int rgb2 = Atari8Palette[frame2[i]];
			// This clever formula just computes the byte-by-byte averages.
			Pixels[i] = (rgb1 & rgb2) + ((rgb1 ^ rgb2) >> 1 & 0x7f7f7f);
		}
		return true;
	}

	bool ApplyAtari8PaletteBlend3(byte[] frame1, byte[] frame2, byte[] frame3)
	{
		int pixelsLength = Width * Height;
		Frames = 3;
		for (int i = 0; i < pixelsLength; i++) {
			int rgb1 = Atari8Palette[frame1[i]];
			int rgb2 = Atari8Palette[frame2[i]];
			int rgb3 = Atari8Palette[frame3[i]];
			Pixels[i] = ((rgb1 >> 16) + (rgb2 >> 16) + (rgb3 >> 16)) / 3 << 16
				| ((rgb1 >> 8 & 0xff) + (rgb2 >> 8 & 0xff) + (rgb3 >> 8 & 0xff)) / 3 << 8
				| ((rgb1 & 0xff) + (rgb2 & 0xff) + (rgb3 & 0xff)) / 3;
		}
		return true;
	}

	bool DecodeGr8(byte[] content, int contentLength)
	{
		if (!SetAtari8RawSize(content, contentLength, FAILResolution.Xe1x1))
			return false;
		GtiaColors[6] = 0x00;
		GtiaColors[5] = 0x0e;
		int contentOffset = GetAtari8ExecutableOffset(content, contentLength);
		byte[320 * 240] frame;
		DecodeAtari8Gr8(content, contentOffset, frame);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeDrg(byte[] content, int contentLength)
	{
		return contentLength == 6400 && DecodeGr8(content, contentLength);
	}

	bool DecodeMbg(byte[] content, int contentLength)
	{
		if (contentLength != 16384)
			return false;
		SetSize(512, 256, FAILResolution.Xe1x1);
		GtiaColors[6] = 0x00;
		GtiaColors[5] = 0x0e;
		byte[512 * 256] frame;
		DecodeAtari8Gr8(content, 0, frame);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeGhg(byte[] content, int contentLength)
	{
		if (contentLength < 4)
			return false;
		int width = ((content[0] | content[1] << 8) + 7) & ~7; // round up to 8 pixels
		int height = content[2];
		if (width == 0 || width > 320 || height == 0 || height > 200)
			return false;
		SetSize(width, height, FAILResolution.Xe1x1);
		byte[320 * 200] frame;
		GtiaColors[6] = 0x0c;
		GtiaColors[5] = 0x02;
		DecodeAtari8Gr8(content, 3, frame);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeCpr(byte[] content, int contentLength)
	{
		if (contentLength < 2)
			return false;
		byte[7680] unpacked;
		if (!KoalaStream.UnpackKoala(content[0], content, 1, contentLength, unpacked, 7680))
			return false;
		GtiaColors[6] = 0x0c;
		GtiaColors[5] = 0x00;
		SetSize(320, 192, FAILResolution.Xe1x1);
		byte[320 * 192] frame;
		DecodeAtari8Gr8(unpacked, 0, frame);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeGr7(byte[] content, int contentOffset, int contentSize)
	{
		if (contentSize > 4804 || contentSize % 40 != 4)
			return false;
		int height = contentSize / 40;
		SetSize(320, height * 2, FAILResolution.Xe2x2);
		byte[320 * 240] frame;
		SetBakPF012(content, contentOffset + contentSize - 4, 1);
		DecodeAtari8Gr7(content, contentOffset, frame, 0, height);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeBkg(byte[] content, int contentLength)
	{
		return contentLength == 3856 && DecodeGr7(content, 0, 3844);
	}

	bool DecodeAtari8Artist(byte[] content, int contentLength)
	{
		if (contentLength != 3206 || content[0] != 7)
			return false;
		SetSize(320, 160, FAILResolution.Xe2x2);
		byte[320 * 160] frame;
		SetPF0123Bak(content, 1);
		DecodeAtari8Gr7(content, 6, frame, 0, 80);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeGr9(byte[] content, int contentLength)
	{
		if (!SetAtari8RawSize(content, contentLength, FAILResolution.Xe4x1))
			return false;
		GtiaColors[8] = 0x00;
		int contentOffset = GetAtari8ExecutableOffset(content, contentLength);
		byte[320 * 240] frame;
		DecodeAtari8Gr9(content, contentOffset, 40, frame, 0, 320, 320, Height);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeA4r(byte[] content, int contentLength)
	{
		A4rStream() a4r;
		a4r.Content = content;
		a4r.ContentOffset = 0;
		a4r.ContentLength = contentLength;
		if (!a4r.UnpackA4r())
			return false;
		SetSize(320, 256, FAILResolution.Xe4x1);
		byte[320 * 256] frame;
		GtiaColors[8] = 0x00;
		DecodeAtari8Gr9(a4r.Unpacked, 0x5010 - A4rStream.MinAddress, 40, frame, 0, 320, 320, 256);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeG11(byte[] content, int contentLength)
	{
		if (!SetAtari8RawSize(content, contentLength, FAILResolution.Xe4x1))
			return false;
		GtiaColors[8] = 0x06; // Atari operating system standard
		int contentOffset = GetAtari8ExecutableOffset(content, contentLength);
		byte[320 * 240] frame;
		DecodeAtari8Gr11(content, contentOffset, frame, 0, 320, Height);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeG10(byte[] content, int contentLength)
	{
		if (!SetAtari8RawSize(content, contentLength, FAILResolution.Xe4x1))
			return false;
		int contentOffset = GetAtari8ExecutableOffset(content, contentLength);
		if ((contentLength - contentOffset) % 40 != 9)
			return false;
		GtiaLeftSkip = 2;
		SetGtiaColors(content, contentLength - 9);
		byte[320 * 240] frame;
		DecodeAtari8Gr10(content, contentOffset, frame, 0, 320, Height);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeG09(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 7680:
			return DecodeGr9(content, contentLength);
		case 15360:
			break;
		default:
			return false;
		}
		SetSize(640, 192, FAILResolution.Xe4x1);
		GtiaColors[8] = 0x00;
		byte[640 * 192] frame;
		DecodeAtari8Gr9(content, 0, 40, frame, 0, 640, 320, 192);
		DecodeAtari8Gr9(content, 7680, 40, frame, 320, 640, 320, 192);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeMic(byte[] content, int contentLength)
	{
		if (contentLength == 15872) {
			// AtariGraphics file format.
			// AtariGraphics was included on a cartridge with the Atari Light Pen.
			// Its files have no default extension. I chose MIC, because it's similar.
			// The format is: 7680 bytes picture, followed by PF0,PF1,PF2,BAK colors,
			// followed by 508 bytes of padding, followed by 7680 bytes of fill map.
			// The fill map allows flood filling areas previously filled with a pattern.
			// It is a copy of the picture, except that areas filled with a pattern
			// are filled with a solid color here. Also, the fill map has inverted bits
			// compared to the picture, don't know why.
			contentLength = 7680;
			SetPF012Bak(content, 7680);
		}
		else {
			switch (contentLength % 40) {
			case 0:
			case 3: // I've found 7683-byte PIC files with three zero bytes at the end.
				SetGr15DefaultColors();
				break;
			case 4:
				SetBakPF012(content, contentLength - 4, 1);
				break;
			case 5:
				// Probably the last byte should be taken for COLBAK, not the previous one,
				// but I can't check that since the 7685-byte PIC files I found
				// have two zero bytes at the end.
				SetPF012Bak(content, contentLength - 5);
				break;
			default:
				return false;
			}
		}

		int height = contentLength / 40;
		if (height == 0 || height > 240)
			return false;
		SetSize(320, height, FAILResolution.Xe2x1);
		byte[320 * 240] frame;
		DecodeAtari8Gr15(content, 0, 40, frame, 0, 320, height);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeHpm(byte[] content, int contentLength)
	{
		// This format appears in Grass' Slideshow.
		byte[7684] unpacked;
		HpmStream() rle;
		rle.Content = content;
		rle.ContentOffset = 0;
		rle.ContentLength = contentLength;
		if (!rle.Unpack(unpacked, 0, 1, 7680))
			return false;

		// Colors aren't stored in the file.
		// Yvonne (http://atari8.sourceforge.net) sets colors according to filenames
		// (note Grass' Slideshow and Yvonne were programmed by the same guy).
		// I have found out that the last byte of the file is COLPF0.
		// Other colors can be deduced from this one.
		// One exception is JORDAN.HPM, which I additionally match by length (3494 bytes).
		switch (rle.ReadByte()) {
		case 0x34: // ALIEN.HPM, DN.HPM, HPZ.HPM, RAPER.HPM, SALEM.HPM, ZWIEWKA.HPM, JORDAN.HPM
		case 0x35: // KOPALNY.HPM
			unpacked[7680] = 0x00;
			unpacked[7681] = 0x34;
			unpacked[7682] = contentLength == 3494 ? 0x38 : 0xc8;
			unpacked[7683] = contentLength == 3494 ? 0x3c : 0x7c;
			break;
		case 0x51: // CZASZKA.HPM
			unpacked[7680] = 0xa4;
			unpacked[7681] = 0x51;
			unpacked[7682] = 0xb9;
			unpacked[7683] = 0x7c;
			break;
		case 0xe4: // FSILY.HPM
			unpacked[7680] = 0x00;
			unpacked[7681] = 0xe4;
			unpacked[7682] = 0xc8;
			unpacked[7683] = 0xbe;
			break;
		case 0x04: // GIRL.HPM
			unpacked[7680] = 0x06;
			unpacked[7681] = 0x04;
			unpacked[7682] = 0x00;
			unpacked[7683] = 0x0a;
			break;
		case 0x30: // KISS.HPM
			unpacked[7680] = 0x0e;
			unpacked[7681] = 0x30;
			unpacked[7682] = 0xc7;
			unpacked[7683] = 0x7b;
			break;
		case 0x74: // STAR.HPM, VIVALDI.HPM
			unpacked[7680] = 0x00;
			unpacked[7681] = 0x74; // for STAR.HPM Yvonne uses 0x64, unlike the slideshow
			unpacked[7682] = 0x58;
			unpacked[7683] = 0x7e;
			break;
		case 0x05: // FATHER.HPM
		default: // just in case
			unpacked[7680] = 0x00;
			unpacked[7681] = 0x04;
			unpacked[7682] = 0x08;
			unpacked[7683] = 0x0c;
			break;
		}

		return DecodeMic(unpacked, 7684);
	}

	bool DecodePic(byte[] content, int contentLength)
	{
		byte[7680] unpacked;
		if (KoalaStream.UnpackKoalaWrapped(content, contentLength, unpacked, 7680)) {
			SetSize(320, 192, FAILResolution.Xe2x1);
			SetPF0123Bak(content, 13);
			byte[320 * 192] frame;
			DecodeAtari8Gr15(unpacked, 0, 40, frame, 0, 320, 192);
			return ApplyAtari8Palette(frame);
		}

		// Some images with .PIC extension are GR8.
		if (contentLength == 7680)
			return DecodeGr8(content, contentLength);

		// Some images with .PIC extension are MIC.
		if (contentLength >= 7681 && contentLength <= 7685)
			return DecodeMic(content, contentLength);

		// Some images with .PIC extension are ST raw format.
		return DecodeDoo(content, contentLength);
	}

	bool DecodeWnd(byte[] content, int contentLength)
	{
		if (contentLength != 3072)
			return false;
		// first byte = width in pixels minus one
		// round up to 4 pixels
		int contentStride = (content[0] >> 2) + 1;
		int height = content[1];
		if (contentStride > 40 || height == 0 || height > 192 || contentStride * height > 3070)
			return false;
		SetSize(contentStride << 3, height, FAILResolution.Xe2x1);
		byte[320 * 192] frame;
		// Blazing Paddles default colors
		GtiaColors[8] = 0x00;
		GtiaColors[4] = 0x46;
		GtiaColors[5] = 0x88;
		GtiaColors[6] = 0x0e;
		DecodeAtari8Gr15(content, 2, contentStride, frame, 0, contentStride << 3, height);
		return ApplyAtari8Palette(frame);
	}

	const int At800SpriteGap = 2;

	void DecodeAt800Players(byte[] content, byte[] frame)
	{
		for (int i = 0; i < 4; i++)
			DecodeAtari8Player(content, 4 + i * 240, content[i], frame, i * (8 + At800SpriteGap) * 2, 240);
	}

	void DecodeAt800Missiles(byte[] content, int contentOffset, byte[] frame, int frameOffset)
	{
		for (int y = 0; y < 240; y++) {
			for (int i = 0; i < 4; i++) {
				int b = content[contentOffset + y] >> (i << 1);
				int offset = frameOffset + i * (2 + At800SpriteGap) * 2;
				frame[offset + 1] = frame[offset] = (b & 2) == 0 ? 0 : content[i];
				frame[offset + 3] = frame[offset + 2] = (b & 1) == 0 ? 0 : content[i];
			}
			frameOffset += Width;
		}
	}

	bool DecodePla(byte[] content, int contentLength)
	{
		if (contentLength != 241)
			return false;
		SetSize(16, 240, FAILResolution.Xe2x1);
		byte[16 * 240] frame = 0;
		DecodeAtari8Player(content, 1, content[0], frame, 0, 240);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeMis(byte[] content, int contentLength)
	{
		if (contentLength != 61 && contentLength != 241)
			return false;
		const int width = 2 * 2;
		SetSize(width, 240, FAILResolution.Xe2x1);
		byte[width * 240] frame;
		for (int y = 0; y < 240; y++) {
			int b = content[1 + (y >> 2)] >> ((~y & 3) << 1);
			frame[y * width + 1] = frame[y * width] = (b & 2) == 0 ? 0 : content[0];
			frame[y * width + 3] = frame[y * width + 2] = (b & 1) == 0 ? 0 : content[0];
		}
		return ApplyAtari8Palette(frame);
	}

	bool Decode4pl(byte[] content, int contentLength)
	{
		if (contentLength != 964)
			return false;
		const int width = 4 * (8 + At800SpriteGap) * 2;
		SetSize(width, 240, FAILResolution.Xe2x1);
		byte[width * 240] frame = 0;
		DecodeAt800Players(content, frame);
		return ApplyAtari8Palette(frame);
	}

	bool Decode4mi(byte[] content, int contentLength)
	{
		if (contentLength != 244)
			return false;
		const int width = 4 * (2 + At800SpriteGap) * 2;
		SetSize(width, 240, FAILResolution.Xe2x1);
		byte[width * 240] frame = 0;
		DecodeAt800Missiles(content, 4, frame, 0);
		return ApplyAtari8Palette(frame);
	}

	bool Decode4pm(byte[] content, int contentLength)
	{
		if (contentLength != 1204)
			return false;
		const int width = 4 * (8 + At800SpriteGap + 2 + At800SpriteGap) * 2;
		SetSize(width, 240, FAILResolution.Xe2x1);
		byte[width * 240] frame = 0;
		DecodeAt800Players(content, frame);
		DecodeAt800Missiles(content, 964, frame, 4 * (8 + At800SpriteGap) * 2);
		return ApplyAtari8Palette(frame);
	}

	bool DecodePmd(byte[] content, int contentLength)
	{
		if (contentLength < 3 + 4 + 4 + 1
		 || content[0] != 0xf0 || content[1] != 0xed || content[2] != 0xe4)
			return false;
		int sprites = content[7];
		int shapes = content[8] * content[9];
		int totalShapes = sprites * shapes;
		int height = content[10];
		if (sprites == 0 || sprites > 4
		 || shapes == 0 || shapes > 16 * 10
		 || height == 0 || height > 48
		 || 11 + totalShapes * height != contentLength)
			return false;

		// Unfortunately the information whether sprites are multi-color is not saved in the file.
		// We choose multi because there are three multi examples vs one mono.
		const bool multi = true;
		if (multi)
			totalShapes >>= 1;
		// 16 shapes per row * (8 pixels + 2 pixels gap) = 160 pixels wide
		int rows = (totalShapes + 15 >> 4);
		const int horizontalGap = 2;
		const int verticalGap = 2;
		if (rows == 1)
			SetSize(totalShapes * (8 + horizontalGap << 1), height, FAILResolution.Xe2x1);
		else {
			int totalHeight = rows * height + (rows - 1) * verticalGap;
			if (totalHeight > MaxHeight)
				return false;
			SetSize(320, totalHeight, FAILResolution.Xe2x1);
		}

		byte[320 * MaxHeight] frame = 0;
		for (int shape = 0; shape < totalShapes; shape++) {
			int frameOffset = (shape >> 4) * (height + verticalGap) * 320 + (shape & 0xf) * (8 + horizontalGap << 1);
			if (multi) {
				int spritePair = shape / shapes;
				int contentOffset = 11 + (spritePair * shapes + shape) * height;
				DecodeAtari8Player(content, contentOffset, content[3 + spritePair * 2], frame, frameOffset, height);
				DecodeAtari8Player(content, contentOffset + shapes * height, content[4 + spritePair * 2], frame, frameOffset, height);
			}
			else
				DecodeAtari8Player(content, 11 + shape * height, content[3 + shape / shapes], frame, frameOffset, height);
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeApl(byte[] content, int contentLength)
	{
		if (contentLength != 1677
		 || content[0] != 0x9a || content[1] != 0xf8 || content[2] != 0x39 || content[3] != 0x21)
			return false;
		int frames = content[4];
		int height = content[5];
		int gap = content[6];
		if (frames == 0 || frames > 16 || height == 0 || height > 48 || gap > 8)
			return false;
		const int frameGap = 2;
		int frameWidth = 8 + gap + frameGap << 1;
		SetSize(frames * frameWidth, height, FAILResolution.Xe2x1);
		byte[(16 + frameGap) * 2 * 16 * 48] frame = 0;

		for (int f = 0; f < frames; f++) {
			DecodeAtari8Player(content, 42 + f * 48, content[7 + f], frame, f * frameWidth, height);
			DecodeAtari8Player(content, 858 + f * 48, content[24 + f], frame, f * frameWidth + gap * 2, height);
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeHr(byte[] content, int contentLength)
	{
		if (contentLength != 16384)
			return false;
		SetSize(256, 239, FAILResolution.Xe1x1);
		GtiaColors[6] = 0x00;
		GtiaColors[5] = 0x0e;
		byte[256 * 239] frame1;
		DecodeAtari8Gr8(content, 0, frame1);
		byte[256 * 239] frame2;
		DecodeAtari8Gr8(content, 8192, frame2);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	// INP, ING
	bool DecodeInp(byte[] content, int contentLength)
	{
		if (contentLength < 16004)
			return false;
		SetSize(320, 200, FAILResolution.Xe2x1);
		SetBakPF012(content, 16000, 1);
		byte[320 * 200] frame1;
		DecodeAtari8Gr15(content, 0, 40, frame1, 0, 320, 200);
		byte[320 * 200] frame2;
		DecodeAtari8Gr15(content, 8000, 40, frame2, 0, 320, 200);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeIge(byte[] content, int contentLength)
	{
		if (contentLength != 6160
		 || content[0] != 0xff || content[1] != 0xff
		 || content[2] != 0xf6 || content[3] != 0xa3 || content[4] != 0xff || content[5] != 0xbb
		 || content[6] != 0xff || content[7] != 0x5f)
			return false;
		SetSize(256, 96, FAILResolution.Xe2x1);
		byte[256 * 96] frame1;
		SetBakPF012(content, 8, 1);
		DecodeAtari8Gr15(content, 0x10, 32, frame1, 0, 256, 96);
		byte[256 * 96] frame2;
		SetBakPF012(content, 12, 1);
		DecodeAtari8Gr15(content, 0xc10, 32, frame2, 0, 256, 96);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeInt(byte[] content, int contentLength)
	{
		if (contentLength < 18
		 || !IsStringAt(content, 0, "INT95a")
		 || content[8] != 0x0f || content[9] != 0x2b)
			return DecodeInp(content, contentLength);
		int contentStride = content[6];
		int height = content[7];
		if (contentStride == 0 || contentStride > 320
		 || height == 0 || height > 239
		 || 18 + contentStride * height * 2 != contentLength)
			return false;
		int width = contentStride << 3;
		SetSize(width, height, FAILResolution.Xe2x1);
		byte[320 * 239] frame1;
		SetBakPF012(content, 10, 1);
		DecodeAtari8Gr15(content, 18, contentStride, frame1, 0, width, height);
		byte[320 * 239] frame2;
		SetBakPF012(content, 10, 1);
		DecodeAtari8Gr15(content, 18 + contentStride * height, contentStride, frame2, 0, width, height);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeIst(byte[] content, int contentLength)
	{
		if (contentLength != 17184)
			return false;
		SetSize(320, 200, FAILResolution.Xe2x1);
		byte[320 * 200] frame1;
		byte[320 * 200] frame2;
		for (int y = 0; y < 200; y++) {
			SetBakPF012(content, 0x4000 + y, 200);
			DecodeAtari8Gr15(content, 16 + y * 40, 0, frame1, y * 320, 320, 1);
			DecodeAtari8Gr15(content, 0x2010 + y * 40, 0, frame2, y * 320, 320, 1);
		}
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeGr15Blend(byte[] content, int bitmapOffset, int colorsOffset, int height)
	{
		SetSize(320, height, FAILResolution.Xe2x1);
		byte[320 * 200] frame1;
		SetPF012Bak(content, colorsOffset);
		DecodeAtari8Gr15(content, bitmapOffset, 80, frame1, 0, 640, height >> 1);
		SetPF012Bak(content, colorsOffset + 4);
		DecodeAtari8Gr15(content, bitmapOffset + 40, 80, frame1, 320, 640, height >> 1);
		byte[320 * 200] frame2;
		DecodeAtari8Gr15(content, bitmapOffset + height * 40, 80, frame2, 0, 640, height >> 1);
		SetPF012Bak(content, colorsOffset);
		DecodeAtari8Gr15(content, bitmapOffset + height * 40 + 40, 80, frame2, 320, 640, height >> 1);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeMcp(byte[] content, int contentLength)
	{
		if (contentLength != 16008)
			return false;
		return DecodeGr15Blend(content, 0, 16000, 200);
	}

	bool DecodeRaw(byte[] content, int contentLength)
	{
		if (contentLength != 15372 || !IsStringAt(content, 0, "XLPB"))
			return false;
		return DecodeGr15Blend(content, 4, 0x3c04, 192);
	}

	bool DecodeXlp(byte[] content, int contentLength)
	{
		XlpStream() rle;
		rle.Content = content;
		rle.ContentLength = contentLength;
		byte[16000] unpacked;
		int height;
		int colorsOffset;
		if (contentLength >= 10 && IsStringAt(content, 0, "XLPC")) {
			// Ignore errors: STAIRS.XLP included with XL-Paint is missing last two image bytes.
			unpacked.Clear();
			rle.ContentOffset = 8;
			rle.Unpack(unpacked, 0, 40, 2 * 40 * 192);
			height = 192;
			colorsOffset = 4;
		}
		else {
			// No header so better check for errors.
			rle.ContentOffset = 4;
			if (rle.Unpack(unpacked, 0, 40, 2 * 40 * 200))
				height = 200;
			else {
				rle.ContentOffset = 4;
				if (rle.Unpack(unpacked, 0, 40, 2 * 40 * 192))
					height = 192;
				else
					return false;
			}
			colorsOffset = 0;
		}

		SetSize(320, height, FAILResolution.Xe2x1);
		SetPF012Bak(content, colorsOffset);
		byte[320 * 200] frame1;
		DecodeAtari8Gr15(unpacked, 0, 40, frame1, 0, 320, height);
		byte[320 * 200] frame2;
		DecodeAtari8Gr15(unpacked, height * 40, 40, frame2, 0, 320, height);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeMax(byte[] content, int contentLength)
	{
		if (contentLength < 4 + 9 * 192 || !IsStringAt(content, 0, "XLPM"))
			return false;
		XlpStream() rle;
		rle.Content = content;
		rle.ContentOffset = 4 + 9 * 192;
		rle.ContentLength = contentLength;
		byte[15360] unpacked;
		if (!rle.Unpack(unpacked, 0, 40, 15360))
			return false;

		SetSize(320, 192, FAILResolution.Xe2x1);
		byte[320 * 192] frame1;
		byte[320 * 192] frame2;
		for (int y = 0; y < 192; y++) {
			SetBakPF012(content, 4 + 4 * 192 + y, 192);
			DecodeAtari8Gr15(unpacked, y * 40, 40, frame1, y * 320, 320, 1);
			SetBakPF012(content, 4 + y, 192);
			DecodeAtari8Gr15(unpacked, 7680 + y * 40, 40, frame2, y * 320, 320, 1);
		}
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeHr2(byte[] content, int contentLength)
	{
		if (contentLength != 16006)
			return false;
		SetSize(320, 200, FAILResolution.Xe1x1);
		byte[320 * 200] frame1;
		SetPF21(content, 16000);
		DecodeAtari8Gr8(content, 0, frame1);
		byte[320 * 200] frame2;
		SetBakPF012(content, 16002, 1);
		DecodeAtari8Gr15(content, 8000, 40, frame2, 0, 320, 200);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	// APC, PLM
	bool DecodeApc(byte[] content, int contentLength)
	{
		if (contentLength != 7680 && contentLength != 7720)
			return false;
		SetSize(320, 192, FAILResolution.Xe4x2);
		byte[320 * 192] frame;
		GtiaColors[8] = 0x00;
		DecodeAtari8Gr9(content, 40, 80, frame, 320, 640, 320, 96);
		DecodeAtari8Gr11PalBlend(content, 0, 80, frame, 0);
		return ApplyAtari8Palette(frame);
	}

	// 256, AP2
	bool Decode256(byte[] content, int contentLength)
	{
		if (contentLength != 7680 && contentLength != 7684)
			return false;
		SetSize(320, 192, FAILResolution.Xe4x2);
		byte[320 * 192] frame;
		GtiaColors[8] = 0x00;
		DecodeAtari8Gr9(content, 3840, 40, frame, 320, 640, 320, 96);
		DecodeAtari8Gr11PalBlend(content, 0, 40, frame, 0);
		return ApplyAtari8Palette(frame);
	}

	// AP3, APV, DGP, ESC, ILC, PZM
	bool DecodeAp3(byte[] content, int contentLength)
	{
		int gr11Offset;
		switch (contentLength) {
		case 15360:
		case 15362:
			gr11Offset = 7680;
			break;
		case 15872:
			gr11Offset = 8192;
			break;
		default:
			return false;
		}
		SetSize(320, 192, FAILResolution.Xe4x1);
		GtiaColors[8] = 0x00;
		byte[320 * 192] frame1;
		DecodeAtari8Gr9(content, 0, 80, frame1, 0, 640, 320, 96);
		DecodeAtari8Gr11PalBlend(content, gr11Offset + 40, 80, frame1, 1);
		byte[320 * 192] frame2;
		DecodeAtari8Gr9(content, 40, 80, frame2, 320, 640, 320, 96);
		DecodeAtari8Gr11PalBlend(content, gr11Offset, 80, frame2, 0);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeApp(byte[] content, int contentLength)
	{
		if (contentLength < 22 + 15872 / 2 // two or more compressed bits per uncompressed nibble
		 || !IsStringAt(content, 0, "S101")
		 || content[4] != 0 || content[5] != 0x3e)
			return false;
		byte[15872] unpacked;
		int unpackedOffset = 0;
		BitStream() bitStream;
		bitStream.Content = content;
		bitStream.ContentOffset = 22;
		bitStream.ContentLength = contentLength;
		int current = bitStream.ReadBits(4);
		int hi = -1;
		for (;;) {
			if (hi < 0)
				hi = current;
			else {
				unpacked[unpackedOffset++] = hi << 4 | current;
				if (unpackedOffset >= 15872)
					break;
				hi = -1;
			}
			int code;
			int bit;
			for (code = 0; ; code += 2) {
				bit = bitStream.ReadBit();
				if (bit == 0)
					break;
				if (bit < 0 || code >= 14)
					return false;
			}
			bit = bitStream.ReadBit();
			if (bit < 0)
				return false;
			code += bit;
			current = current - content[6 + code] & 0xf;
		}
		return DecodeAp3(unpacked, 15872);
	}

	bool DecodeHip(byte[] content, int contentLength)
	{
		if (contentLength < 80)
			return false;
		const byte[] gr10Colors = { 0x00, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e };
		byte[320 * 240] frame1;
		byte[320 * 240] frame2;
		int frameLength = ParseAtari8ExecutableHeader(content, 0);
		if (frameLength > 0
		 && frameLength % 40 == 0
		 && 12 + frameLength * 2 == contentLength
		 && ParseAtari8ExecutableHeader(content, 6 + frameLength) == frameLength) {
			// HIP image with binary file headers.
			int height = frameLength / 40;
			if (height > 240)
				return false;
			SetSize(320, height, FAILResolution.Xe2x1);
			GtiaLeftSkip = 1;
			SetGtiaColors(gr10Colors, 0);
			DecodeAtari8Gr10(content, 6, frame1, 0, 320, height);
			GtiaColors[8] = 0x00;
			DecodeAtari8Gr9(content, 12 + frameLength, 40, frame2, 0, 320, 320, height);
		}
		else {
			// HIP image with GR. 10 palette.
			int height = contentLength / 80;
			if (height > 240)
				return false;
			SetSize(320, height, FAILResolution.Xe2x1);
			GtiaLeftSkip = 1;
			GtiaColors[8] = 0x00;
			DecodeAtari8Gr9(content, 0, 40, frame1, 0, 320, 320, height);
			if (contentLength % 80 == 9)
				SetGtiaColors(content, contentLength - 9);
			else
				SetGtiaColors(gr10Colors, 0);
			DecodeAtari8Gr10(content, height * 40, frame2, 0, 320, height);
		}
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeTip(byte[] content, int contentLength)
	{
		if (contentLength < 129
		 || content[0] != 'T' || content[1] != 'I' || content[2] != 'P'
		 || content[3] != 1 || content[4] != 0)
			return false;
		int width = content[5];
		int height = content[6];
		if (width > 160 || (width & 3) != 0 || height > 119)
			return false;
		int contentStride = width >> 2;
		int frameLength = content[7] | content[8] << 8;
		if (frameLength != contentStride * height
		 || contentLength != 9 + 3 * frameLength)
			return false;

		SetSize(width << 1, height << 1, FAILResolution.Xe2x2);
		GtiaLeftSkip = 1;
		const byte[] colors = { 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x00 };
		SetGtiaColors(colors, 0);
		byte[320 * 238] frame1;
		DecodeAtari8Gr9(content, 9, contentStride, frame1, width << 1, width << 2, width << 1, height);
		DecodeAtari8Gr11PalBlend(content, 9 + 2 * frameLength, contentStride, frame1, 0);
		byte[320 * 238] frame2;
		DecodeAtari8Gr10(content, 9 + frameLength, frame2, width << 1, width << 2, height);
		DecodeAtari8Gr11PalBlend(content, 9 + 2 * frameLength, contentStride, frame2, 0);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeCin(byte[] content, int contentLength)
	{
		int height;
		switch (contentLength) {
		case 15360:
			SetGr15DefaultColors();
			height = 192;
			break;
		case 16004:
			SetBakPF012(content, 16000, 1);
			height = 200;
			break;
		case 16384:
			height = 192;
			break;
		default:
			return false;
		}
		SetSize(320, height, FAILResolution.Xe2x1);
		byte[320 * 200] frame1;
		byte[320 * 200] frame2;
		for (int y = 0; y < height; y++) {
			if (contentLength == 16384)
				SetBakPF012(content, 0x3c00 + y, 256);
			DecodeAtari8Gr15(content, y * 40, 40, (y & 1) == 0 ? frame1 : frame2, y * 320, 320, 1);
		}
		DecodeAtari8Gr11PalBlend(content, 40 * height + 40, 80, frame1, 1);
		DecodeAtari8Gr11PalBlend(content, 40 * height, 80, frame2, 0);
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeCci(byte[] content, int contentLength)
	{
		if (contentLength < 24 || !IsStringAt(content, 0, "CIN 1.2 "))
			return false;
		CciStream() rle;
		rle.Content = content;
		rle.ContentOffset = 8;
		rle.ContentLength = contentLength;
		byte[16384] unpacked;
		if (!rle.UnpackGr15(unpacked, 0))
			return false;
		if (!rle.UnpackGr15(unpacked, 40))
			return false;
		rle.ContentOffset += 4;
		rle.RepeatCount = 0; // DRACONUS.CCI
		if (!rle.Unpack(unpacked, 7680, 40, 7680))
			return false;
		rle.ContentOffset += 4;
		rle.RepeatCount = 0;
		if (!rle.Unpack(unpacked, 15360, 1, 1024))
			return false;
		return DecodeCin(unpacked, 16384);
	}

	bool UnpackRip(byte[] content, int contentOffset, int contentLength, byte[] unpacked, int unpackedLength)
	{
		// "PCK" header (16 bytes)
		if (contentOffset + 304 > contentLength || !IsStringAt(content, contentOffset, "PCK"))
			return false;

		// 288 bytes Shannon-Fano bit lengths
		FanoTree() lengthTree;
		lengthTree.Create(content, contentOffset + 16, 64);
		FanoTree() distanceTree;
		distanceTree.Create(content, contentOffset + 16 + 32, 256);
		FanoTree() literalTree;
		literalTree.Create(content, contentOffset + 16 + 32 + 128, 256);

		// LZ77
		BitStream() bitStream;
		bitStream.Content = content;
		bitStream.ContentOffset = contentOffset + 16 + 288;
		bitStream.ContentLength = contentLength;
		for (int unpackedOffset = 0; unpackedOffset < unpackedLength; ) {
			switch (bitStream.ReadBit()) {
			case -1:
				return false;
			case 0:
				int literal = literalTree.ReadCode(bitStream);
				if (literal < 0)
					return false;
				unpacked[unpackedOffset++] = literal;
				break;
			case 1:
				int distance = distanceTree.ReadCode(bitStream);
				if (distance < 0)
					return false;
				distance += 2;
				if (distance > unpackedOffset)
					return false;
				int length = lengthTree.ReadCode(bitStream);
				if (length < 0)
					return false;
				length += 2;
				do {
					unpacked[unpackedOffset] = unpacked[unpackedOffset - distance];
					if (++unpackedOffset >= unpackedLength)
						return true;
				} while (--length > 0);
				break;
			}
		}
		return true;
	}

	bool DecodeRip(byte[] content, int contentLength)
	{
		if (contentLength < 34
		 || content[0] != 'R' || content[1] != 'I' || content[2] != 'P'
		 || content[18] != 'T' || content[19] != ':')
			return false;
		int headerLength = content[11] | content[12] << 8;
		int contentStride = content[13];
		int height = content[15];
		int textLength = content[17];
		if (headerLength >= contentLength
		 || contentStride == 0 || contentStride > 80 || (contentStride & 1) != 0 || height == 0 || height > 239
		 || 33 + textLength >= contentLength
		 || content[20 + textLength] != 9
		 || !IsStringAt(content, 21 + textLength, "CM:"))
			return false;

		if (content[7] < 0x10)
			contentStride >>= 1;
		int unpackedLength = contentStride * height;
		if (content[7] == 0x30)
			unpackedLength += (height + 1 >> 1) << 3; // Multi RIP: 8 bytes of palette per two lines
		byte[84 * 239] unpacked = 0;
		switch (content[9]) {
		case 0:
			if (headerLength + unpackedLength > contentLength)
				return false;
			content.CopyTo(headerLength, unpacked, 0, unpackedLength);
			break;
		case 1:
			// Ignore errors, because many RIP files included with Atari Interlace Studio are corrupted.
			UnpackRip(content, headerLength, contentLength, unpacked, unpackedLength);
			break;
		default:
			return false;
		}

		SetGtiaColors(content, 24 + textLength);
		contentStride = content[13] >> 1;
		int width = contentStride << 3;
		byte[320 * 239] frame1;
		byte[320 * 239] frame2;
		switch (content[7]) {
		case 0x0e: // GR. 15
			SetSize(width, height, FAILResolution.Xe2x1);
			DecodeAtari8Gr15(unpacked, 0, contentStride, frame1, 0, width, height);
			return ApplyAtari8Palette(frame1);
		case 0x0f: // GR. 8
			SetSize(width, height, FAILResolution.Xe1x1);
			DecodeAtari8Gr8(unpacked, 0, frame1);
			return ApplyAtari8Palette(frame1);
		case 0x4f: // GR. 9
			SetSize(width, height, FAILResolution.Xe4x1);
			DecodeAtari8Gr9(unpacked, 0, contentStride, frame1, 0, width, width, height);
			return ApplyAtari8Palette(frame1);
		case 0x8f: // GR. 10
			SetSize(width, height, FAILResolution.Xe4x1);
			GtiaLeftSkip = 2;
			DecodeAtari8Gr10(unpacked, 0, frame1, 0, width, height);
			return ApplyAtari8Palette(frame1);
		case 0xcf: // GR. 11
			SetSize(width, height, FAILResolution.Xe4x1);
			DecodeAtari8Gr11(content, 0, frame1, 0, width, height);
			return ApplyAtari8Palette(frame1);
		case 0x1e: // GR. 15 blend with one palette
			SetSize(width, height, FAILResolution.Xe2x1);
			DecodeAtari8Gr15(unpacked, 0, contentStride, frame1, 0, width, height);
			DecodeAtari8Gr15(unpacked, height * contentStride, contentStride, frame2, 0, width, height);
			return ApplyAtari8PaletteBlend(frame1, frame2);
		case 0x10: // GR. 15 blend with different palettes
			SetSize(width, height, FAILResolution.Xe2x1);
			SetBakPF012(content, 28 + textLength, 1);
			DecodeAtari8Gr15(unpacked, 0, contentStride << 1, frame1, 0, width << 1, height >> 1);
			SetBakPF012(content, 24 + textLength, 1);
			DecodeAtari8Gr15(unpacked, contentStride, contentStride << 1, frame1, width, width << 1, height >> 1);
			DecodeAtari8Gr15(unpacked, height * contentStride, contentStride << 1, frame2, 0, width << 1, height >> 1);
			SetBakPF012(content, 28 + textLength, 1);
			DecodeAtari8Gr15(unpacked, (height + 1) * contentStride, contentStride << 1, frame2, width, width << 1, height >> 1);
			return ApplyAtari8PaletteBlend(frame1, frame2);
		case 0x20: // HIP, RIP
			SetSize(width, height, FAILResolution.Xe2x1);
			GtiaLeftSkip = 1;
			DecodeAtari8Gr10(unpacked, 0, frame1, 0, width, height);
			GtiaColors[8] = 0x00;
			DecodeAtari8Gr9(unpacked, height * contentStride, contentStride, frame2, 0, width, width, height);
			return ApplyAtari8PaletteBlend(frame1, frame2);
		case 0x30: // Multi RIP
			SetSize(width, height, FAILResolution.Xe2x1);
			GtiaLeftSkip = 1;
			GtiaColors[0] = 0x00;
			int colorsOffset = height * contentStride << 1;
			for (int y = 0; y < height; y += 2) {
				SetPM123PF0123Bak(unpacked, colorsOffset + (y << 2));
				DecodeAtari8Gr10(unpacked, y * contentStride, frame1, y * width, width, y + 1 < height ? 2 : 1);
			}
			GtiaColors[8] = 0x00;
			DecodeAtari8Gr9(unpacked, height * contentStride, contentStride, frame2, 0, width, width, height);
			return ApplyAtari8PaletteBlend(frame1, frame2);
		default:
			return false;
		}
	}

	bool DecodeRm(byte[] content, int contentLength, int mode, FAILResolution resolution)
	{
		byte[7680] unpacked;
		int colorsOffset;
		int dliOffset;
		if (KoalaStream.UnpackKoalaWrapped(content, contentLength - 464, unpacked, mode == 0 ? 3840 : 7680)) {
			// File written by a Rambrandt plugin ("DOS module").
			// Documentation suggests RM0-RM4 extensions.
			colorsOffset = contentLength - 464;
			dliOffset = contentLength - 384;
		}
		else if (contentLength == 8192) {
			// Rambrandt native raw format.
			// Rambrandt writes directly to disk using its own filesystem:
			// 10 pictures per disk, 32 characters filename (no extension).
			// We assume RM0-RM4 extensions even though it's a different format.
			content.CopyTo(0, unpacked, 0, 7680);
			colorsOffset = 0x1e00;
			dliOffset = 0x1e80;
		}
		else
			return false;

		bool[192] dliPresent = false;
		for (int i = 0; i < 128; i++) {
			int y = content[dliOffset + i];
			switch (y) {
			case 0:
				break;
			case 1:
			case 2:
			case 4:
			case 5:
				return false;
			default:
				if (mode == 0) {
					if (y >= 5 + 96)
						return false;
					if (y == 3)
						y = 0;
					else
						y -= 5;
				}
				else {
					if (y == 100 || y == 101 || y >= 198)
						return false;
					if (y == 3)
						y = 1;
					else if (y < 100)
						y -= 4;
					else
						y -= 6;
				}
				dliPresent[y] = true;
				break;
			}
		}

		SetSize(320, 192, resolution);
		if (mode == 2)
			GtiaLeftSkip = 2;
		if (mode == 1)
			GtiaColors[8] = content[colorsOffset + 8] & 0xf0;
		else
			SetGtiaColors(content, colorsOffset);
		int height = mode == 0 ? 96 : 192;
		byte[320 * 192] frame;
		for (int y = 0; y < height; y++) {
			switch (mode) {
			case 0:
				DecodeAtari8Gr7(unpacked, y * 40, frame, y * 640, 1);
				break;
			case 1:
				DecodeAtari8Gr9(unpacked, y * 40, 40, frame, y * 320, 320, 320, 1);
				break;
			case 2:
				DecodeAtari8Gr10(unpacked, y * 40, frame, y * 320, 320, 1);
				break;
			case 3:
				DecodeAtari8Gr11(unpacked, y * 40, frame, y * 320, 320, 1);
				break;
			case 4:
				DecodeAtari8Gr15(unpacked, y * 40, 40, frame, y * 320, 320, 1);
				break;
			}
			if (dliPresent[y]) {
				int vcount = mode == 0 ? 16 + y : 16 + (y - 1 >> 1);
				int reg = content[dliOffset + 128 + vcount];
				if (reg < 9)
					SetGtiaColor(reg, content[dliOffset + 256 + vcount]);
				else if (reg != 0x80)
					return false;
			}
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAgp(byte[] content, int contentLength)
	{
		if (contentLength != 7690)
			return false;
		SetGtiaColors(content, 1);
		byte[320 * 192] frame;
		switch (content[0]) {
		case 8:
			SetSize(320, 192, FAILResolution.Xe1x1);
			DecodeAtari8Gr8(content, 10, frame);
			break;
		case 9:
			SetSize(320, 192, FAILResolution.Xe4x1);
			DecodeAtari8Gr9(content, 10, 40, frame, 0, 320, 320, 192);
			break;
		case 10:
			SetSize(320, 192, FAILResolution.Xe4x1);
			GtiaLeftSkip = 2;
			DecodeAtari8Gr10(content, 10, frame, 0, 320, 192);
			break;
		case 11:
			SetSize(320, 192, FAILResolution.Xe4x1);
			DecodeAtari8Gr11(content, 10, frame, 0, 320, 192);
			break;
		case 15:
			SetSize(320, 192, FAILResolution.Xe2x1);
			DecodeAtari8Gr15(content, 10, 40, frame, 0, 320, 192);
			break;
		default:
			return false;
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeShc(byte[] content, int contentLength)
	{
		if (contentLength != 17920)
			return false;
		SetSize(320, 192, FAILResolution.Xe1x1);
		byte[320 * 192] frame1;
		byte[320 * 192] frame2;
		int col1 = 0x3c00;
		int col2 = 0x4100;
		for (int y = 0; y < 192; y++) {
			for (int x = 0; x < 320; x++) {
				int i = 320 * y + x;
				int bit = ~x & 7;
				switch (x) {
				// Widths measured in Atari800Win PLus 4.0 and Altirra 2.0-test47.
				case 46 + 48:
				case 46 + 48 + 48+ 24:
				case 46 + 48 + 48+ 24 + 24 + 24:
				case 46 + 48 + 48+ 24 + 24 + 24 + 24 + 24:
				case 46 + 48 + 48+ 24 + 24 + 24 + 24 + 24 + 24 + 20:
					col1++;
					break;
				case 46:
				case 46 + 48 + 48:
				case 46 + 48 + 48 + 24 + 24:
				case 46 + 48 + 48 + 24 + 24 + 24 + 24:
				case 46 + 48 + 48 + 24 + 24 + 24 + 24 + 24 + 24:
					col2++;
					break;
				default:
					break;
				}
				// COLPF1 == 0
				frame1[i] = content[col1] & ((content[i >> 3] >> bit & 1) != 0 ? 0xf0 : 0xfe);
				frame2[i] = content[col2] & ((content[7680 + (i >> 3)] >> bit & 1) != 0 ? 0xf0 : 0xfe);
			}
			col1++;
			col2++;
		}
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	bool DecodeMgp(byte[] content, int contentLength)
	{
		if (contentLength != 3845)
			return false;
		SetSize(320, 192, FAILResolution.Xe2x2);
		byte[320 * 192] frame;
		SetPF0123Bak(content, 0);
		int rainbow = content[5];

		// The file is missing the last byte of the bitmap.
		byte[3840] bitmap;
		content.CopyTo(6, bitmap, 0, 3839);
		bitmap[3839] = 0; // put background in the missing byte

		for (int y = 0; y < 96; y++) {
			if (rainbow < 4) {
				// Rainbow effect :)
				// The constant 16 is arbitrary here.
				// For correct animation it should decrease every frame.
				GtiaColors[rainbow == 0 ? 8 : 3 + rainbow] = 16 + y & 0xfe;
			}
			DecodeAtari8Gr7(bitmap, y * 40, frame, y * 640, 1);
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeFwa(byte[] content, int contentLength)
	{
		if (contentLength < 0x1f18 || content[0] != 0xfe || content[1] != 0xfe
		 || content[6] != 0x70 || content[7] != 0x70 || content[8] != 0x70 || content[0xb] != 0x50 || content[0x73] != 0x60 || content[0xcd] != 0x41
		 || 0x1f18 + content[0x1f16] + (content[0x1f17] << 8) != contentLength)
			return false;
		SetSize(320, 192, FAILResolution.Xe2x1);
		byte[320 * 192] frame;
		SetBakPF012(content, 2, 1);
		int dlOffset = 9;
		int dliOffset = 0x1f18;
		for (int y = 0; y < 192; y++) {
			DecodeAtari8Gr15(content, 0x106 + 40 * y + (y >= 102 ? 16 : 0), 40, frame, y * 320, 320, 1);
			int dlInstr = content[dlOffset];
			if (dlOffset == 9 || dlOffset == 0x71) {
				if ((dlInstr & 0x7f) != 0x4e || content[dlOffset + 1] != 0)
					return false;
				dlOffset += 3;
			}
			else {
				if ((dlInstr & 0x7f) != 0x0e)
					return false;
				dlOffset++;
			}
			if (dlInstr >= 0x80) {
				if (dliOffset + 14 > contentLength || content[dliOffset] != 0x48 || content[dliOffset + 1] != 0x8a || content[dliOffset + 2] != 0x48
				 || content[dliOffset + 3] != 0xa9 || content[dliOffset + 5] != 0x8d || content[dliOffset + 6] != 0x0a || content[dliOffset + 7] != 0xd4)
					return false;
				byte a = content[dliOffset + 4];
				dliOffset += 8;
				while (content[dliOffset] != 0x20) {
					switch (content[dliOffset]) {
					case 0xa9:
						a = content[dliOffset + 1];
						dliOffset += 2;
						break;
					case 0x8d:
						if (content[dliOffset + 2] != 0xd0)
							return false;
						int lo = content[dliOffset + 1];
						switch (lo) {
						case 0x16:
						case 0x17:
						case 0x18:
						case 0x1a:
							GtiaColors[lo - 0x12] = a & 0xfe;
							break;
						default:
							return false;
						}
						dliOffset += 3;
						break;
					default:
						return false;
					}
					if (dliOffset + 3 > contentLength)
						return false;
				}
				if (content[dliOffset + 1] != 0xca || content[dliOffset + 2] != 0x06)
					return false;
				dliOffset += 3;
			}
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAtari8Font(byte[] characters, byte[] font, int fontOffset)
	{
		SetSize(256, 32, FAILResolution.Xe1x1);
		byte[256 * 32] frame;
		DecodeAtari8Gr0(characters, 32, font, fontOffset, frame);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeFnt(byte[] content, int contentLength)
	{
		int contentOffset;
		switch (contentLength) {
		case 1024:
		case 1025:
		case 1026:
			contentOffset = 0;
			break;
		case 1030:
			if (ParseAtari8ExecutableHeader(content, 0) != 1024)
				return false;
			contentOffset = 6;
			break;
		default:
			return false;
		}
		byte[128] characters;
		for (int i = 0; i < 128; i++)
			characters[i] = i;
		return DecodeAtari8Font(characters, content, contentOffset);
	}

	bool DecodeSxs(byte[] content, int contentLength)
	{
		if (contentLength != 1030 || ParseAtari8ExecutableHeader(content, 0) != 1024)
			return false;
		byte[128] characters;
		// 00 01 04 05 08 09 ... 3c 3d
		// 02 03 06 07 0a 0b ... 3e 3f
		// 40 41 44 45 48 49 ... 7c 7d
		// 42 43 46 47 4a 4b ... 7e 7f
		for (int i = 0; i < 128; i++)
			characters[i] = (i & 0x41) | (i >> 4 & 2) | ((i & 0x1e) << 1);
		return DecodeAtari8Font(characters, content, 6);
	}

	bool DecodeNlq(byte[] content, int contentLength)
	{
		if (contentLength < 19 + 90 * 4 || !IsStringAt(content, 0, "DAISY-DOT NLQ FONT") || content[18] != 0x9b)
			return false;
		SetSize(320, 96, FAILResolution.Xe1x1);
		byte[320 * 96] frame = 0;
		int contentOffset = 19;
		for (int i = 0; i < 91; i++) {
			if (contentOffset >= contentLength)
				return false;
			int width = content[contentOffset];
			if (width == 0 || width > 19)
				return false;
			int nextContentOffset = contentOffset + (width + 1) * 2;
			if (nextContentOffset > contentLength || content[nextContentOffset - 1] != 0x9b)
				return false;
			int c = i < 64 ? i : i < 90 ? i + 1 : 92;
			for (int y = 0; y < 16; y++) {
				for (int x = 0; x < width; x++) {
					int b = content[contentOffset + 1 + (y & 1) * width + x] >> (7 - (y >> 1)) & 1;
					frame[(c & 0xf0 | y) * 320 + (c & 0xf) * 20 + x] = b == 0 ? 0x00 : 0x0e;
				}
			}
			contentOffset = nextContentOffset;
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAcs(byte[] content, int contentLength)
	{
		if (contentLength != 1028)
			return false;
		byte[16] characters;
		for (int i = 0; i < 16; i++)
			characters[i] = i;
		SetBakPF012(content, 0, 1);
		SetSize(128, 64, FAILResolution.Xe2x1);
		byte[128 * 64] frame;
		for (int y = 0; y < 8; y++)
			DecodeAtari8Gr12Line(characters, 0, content, 4 + (y << 7), frame, y << 10);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeJgp(byte[] content, int contentLength)
	{
		if (contentLength != 2054 || ParseAtari8ExecutableHeader(content, 0) != 2048)
			return false;
		byte[32] characters;
		for (int i = 0; i < 32; i++)
			characters[i] = i;
		SetGr15DefaultColors();
		SetSize(256, 64, FAILResolution.Xe2x1);
		byte[256 * 64] frame;
		for (int y = 0; y < 8; y++)
			DecodeAtari8Gr12Line(characters, 0, content, 6 + ((y & 6) << 7) + ((y & 1) << 10), frame, y << 11);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeDlm(byte[] content, int contentLength)
	{
		if (contentLength != 256)
			return false;
		byte[11 * 16] characters;
		for (int y = 0; y < 16; y++)
			for (int x = 0; x < 11; x++)
				characters[y * 11 + x] = ToAtari8Char(content[y * 16 + 5 + x]);
		SetSize(88, 128, FAILResolution.Xe1x1);
		byte[88 * 128] frame;
		DecodeAtari8Gr0(characters, 11, BinaryResource("atari8.fnt"), 0, frame);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeSge(byte[] content, int contentLength)
	{
		if (contentLength != 960)
			return false;
		byte[1024] font;
		BinaryResource("atari8.fnt").CopyTo(0, font, 0, 1024);
		for (int i = 0; i < 4; i++) {
			font[0x7d * 8 + 4 + i] = font[0x5b * 8 + i] = 0x0f;
			font[0x7d * 8 + i] = font[0x5b * 8 + 4 + i] = 0xf0;
		}
		SetSize(320, 192, FAILResolution.Xe1x1);
		byte[320 * 192] frame;
		DecodeAtari8Gr0(content, 40, font, 0, frame);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAsciiArtEditor(byte[] content, int contentLength)
	{
		if (contentLength <= 0 || content[contentLength - 1] != 0x9b)
			return false;

		const int maxColumns = 64;
		const int maxRows = 24;
		byte[maxColumns * maxRows] characters;
		int columns = 1;
		int x = 0;
		int y = 0;
		for (int contentOffset = 0; contentOffset < contentLength; contentOffset++) {
			int ch = content[contentOffset];
			if (y >= maxRows)
				return false;
			if (ch == 0x9b) {
				if (columns < x)
					columns = x;
				while (x < maxColumns) // pad with spaces
					characters[y * maxColumns + x++] = 0x00;
				x = 0;
				y++;
			}
			else {
				if (x >= maxColumns)
					return false;
				characters[y * maxColumns + x++] = ToAtari8Char(ch);
			}
		}

		SetSize(columns << 3, y << 3, FAILResolution.Xe1x1);
		byte[maxColumns * 8 * maxRows * 8] frame;
		DecodeAtari8Gr0(characters, maxColumns, BinaryResource("atari8.fnt"), 0, frame);
		return ApplyAtari8Palette(frame);
	}

	bool DecodeMch(byte[] content, int contentLength)
	{
		int width;
		int charactersStride;
		int charactersOffset;
		switch (contentLength) {
		case 30 * 32 * 9 + 5 * 240:
			width = 128;
			charactersStride = 32;
			charactersOffset = 0;
			break;
		case 30 * 40 * 9 + 5 * 240:
			width = 160;
			charactersStride = 40;
			charactersOffset = 0;
			break;
		case 30 * 48 * 9 + 5 * 240:
			width = 176;
			charactersStride = 48;
			charactersOffset = 3;
			break;
		default:
			return false;
		}
		SetSize(width * 2, 240, FAILResolution.Xe2x1);
		byte[176 * 2 * 240] frame;
		for (int y = 0; y < 240; y++) {
			int colorsOffset = contentLength - 5 * 240 + y;
			for (int x = 0; x < width; x++) {
				int offset = (charactersOffset + (y >> 3) * charactersStride + (x >> 2)) * 9;
				int c = content[offset + 1 + (y & 7)] >> ((~x & 3) * 2) & 3;
				if (c == 3 && content[offset] >= 0x80)
					c = 4;
				offset = (y * width + x) * 2;
				frame[offset + 1] = frame[offset] = content[colorsOffset + c * 240] & 0xfe;
			}
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeAll(byte[] content, int contentLength)
	{
		// "ALL" format of GRAPH.COM by Adam Bienias:
		// 24 bytes - font in line (0-7)
		// n*1024 bytes - fonts
		// 960 bytes - characters
		// 5 bytes - PF0, PF1, PF2, PF3, BAK colors

		if ((contentLength & 0x3ff) != 24 + 960 + 5)
			return false;
		SetPF0123Bak(content, contentLength - 5);
		SetSize(320, 192, FAILResolution.Xe2x1);
		byte[320 * 192] frame;
		for (int y = 0; y < 24; y++) {
			int fontOffset = 24 + (content[y] << 10);
			if (fontOffset >= contentLength - 965)
				return false;
			DecodeAtari8Gr12Line(content, contentLength - 965 + y * 40, content, fontOffset, frame, y * (8 * 320));
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeMcs(byte[] content, int contentLength)
	{
		if (contentLength != 10185)
			return false;
		// "Super Bilder.atr" slideshow:
		// 9 bytes: COLPM0-3, COLPF0-3, COLBAK
		// 8192 bytes: 8 fonts (one font per 3 character lines)
		// 960 bytes: 40x24 characters
		// 640 bytes: missiles and four players
		// 384 bytes: apparently unused
		SetSize(320, 192, FAILResolution.Xe2x1);
		byte[320 * 192] frame;
		for (int y = 0; y < 192; y++) {
			int fontOffset = 9 + (y / 24 << 10);
			for (int x = 0; x < 320; x++) {
				int ch = content[9 + 8192 + (y >> 3) * 40 + (x >> 3)];
				int c;
				switch (content[fontOffset + ((ch & 0x7f) << 3) + (y & 7)] >> (~x & 6) & 3) {
				case 0:
					// Sprites are 4x width, arranged next to each other in the following order:
					// P0 M0 P1 M1 P2 M2 P3 M3
					c = x / 80; // player/missile number
					int pmgBit = (x >> 3) % 10;
					int pmgOffset;
					if (pmgBit < 8) {
						// player
						pmgBit = 7 - pmgBit;
						pmgOffset = 9 + 8192 + 960 + 128 + 16 + (c << 7);
					}
					else {
						// missile
						pmgBit = (c << 1) | (pmgBit ^ 9);
						pmgOffset = 9 + 8192 + 960 + 16;
					}
					if ((content[pmgOffset + (y >> 1)] >> pmgBit & 1) == 0)
						c = 8; // COLBAK
					break;
				case 1:
					c = 4;
					break;
				case 2:
					c = 5;
					break;
				case 3:
					c = 6 + (ch >> 7);
					break;
				}
				frame[y * 320 + x] = content[c] & 0xfe;
			}
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeIpc(byte[] content, int contentLength)
	{
		if (contentLength != 17354 || content[0] != 1)
			return false;
		SetGtiaColors(content, 1);
		SetSize(320, 192, FAILResolution.Xe2x1);
		byte[320 * 192] frame1;
		byte[320 * 192] frame2;
		for (int y = 0; y < 192; y++) {
			frame2[y * 320] = frame1[y * 320 + 319] = content[1] & 0xfe;
			for (int x = 0; x < 320; x++) {
				int ch = content[16394 + (y >> 3) * 40 + (x >> 3)];
				int gr12col = ch >= 0x80 ? 0x7540 : 0x6540;
				int fontOffset = 10 + (y / 24 << 11) + ((ch & 0x7f) << 3) + (y & 7);
				int i;
				if (x >= 1) {
					i = content[fontOffset] >> (~x & 6) & 3;
					frame1[y * 320 + x - 1] = GtiaColors[gr12col >> (i << 2) & 0xf];
				}
				if (x < 319) {
					i = content[fontOffset + 1024] >> (~x & 4) & 0xf;
					frame2[y * 320 + x + 1] = GtiaColors[i];
				}
			}
		}
		return ApplyAtari8PaletteBlend(frame1, frame2);
	}

	void DecodeRgbScreen(byte[] screens, int screensOffset, int color, byte[] frame)
	{
		if (Resolution == FAILResolution.Xe4x1) {
			GtiaColors[8] = color;
			DecodeAtari8Gr9(screens, screensOffset, 40, frame, 0, Width, Width, Height);
		}
		else {
			GtiaColors[8] = 0x00;
			GtiaColors[4] = color | 4;
			GtiaColors[5] = color | 0xa;
			GtiaColors[6] = color | 0xe;
			DecodeAtari8Gr15(screens, screensOffset, 40, frame, 0, Width, Height);
		}
	}

	bool DecodeRgb(byte[] content, int contentLength)
	{
		if (contentLength < 9 || !IsStringAt(content, 0, "RGB1"))
			return false;
		int titleLength = content[4];
		int width = content[6 + titleLength];
		int height = content[7 + titleLength];
		if (width == 0 || (width & 1) != 0 || width > 80 || height == 0 || height > 192 || content[8 + titleLength] != 1)
			return false;
		switch (content[5 + titleLength]) {
		case 9:
			SetSize(width << 2, height, FAILResolution.Xe4x1);
			break;
		case 15:
			SetSize(width << 2, height, FAILResolution.Xe2x1);
			break;
		default:
			return false;
		}

		int[192] leftRgbs;
		byte[3 * 40 * 192] screens;
		RgbStream() rle;
		rle.Content = content;
		rle.ContentOffset = 9 + titleLength;
		rle.ContentLength = contentLength;
		for (int x = 0; x < width; x++) {
			for (int y = 0; y < height; y++) {
				int rgb = rle.ReadRle();
				if (rgb < 0)
					return false;
				if ((x & 1) == 0)
					leftRgbs[y] = rgb;
				else {
					int leftRgb = leftRgbs[y];
					int screenOffset = y * 40 + (x >> 1);
					screens[screenOffset] = (leftRgb >> 4 & 0xf0) | (rgb >> 8);
					screens[40 * 192 + screenOffset] = (leftRgb & 0xf0) | (rgb >> 4 & 0x0f);
					screens[2 * 40 * 192 + screenOffset] = (leftRgb << 4 & 0xf0 | rgb & 0x0f);
				}
			}
		}

		byte[320 * 192] frame1;
		DecodeRgbScreen(screens, 0, 0x30, frame1);
		byte[320 * 192] frame2;
		DecodeRgbScreen(screens, 40 * 192, 0xc0, frame2);
		byte[320 * 192] frame3;
		DecodeRgbScreen(screens, 2 * 40 * 192, 0x70, frame3);
		return ApplyAtari8PaletteBlend3(frame1, frame2, frame3);
	}

	bool DrawBlazingPaddlesVector(byte[] content, int contentLength, byte[] frame, int frameOffset, int index, int startAddress)
	{
		if (index * 2 + 1 >= contentLength)
			return false;
		int contentOffset = content[index * 2] + (content[index * 2 + 1] << 8) - startAddress;
		if (contentOffset < 0)
			return false;
		while (contentOffset < contentLength) {
			int control = content[contentOffset++];
			if (control == 0x08)
				return true;
			// bits 7-4: length-1
			for ( ; control >= 0; control -= 16) {
				// bit 2: pen up */
				if ((control & 4) == 0)
					frame[frameOffset + 1] = frame[frameOffset] = 0x0e;
				// bits 1-0: direction
				switch (control & 3) {
				case 0: //right
					frameOffset += 2;
					break;
				case 1: // left
					frameOffset -= 2;
					break;
				case 2: // up
					frameOffset -= Width;
					break;
				case 3: // down
					frameOffset += Width;
					break;
				}
			}
		}
		return false;
	}

	bool DecodeBlazingPaddlesVectors(byte[] content, int contentLength, int startAddress)
	{
		// The file contains several independent shapes.
		// I layout them in reading order, so that they don't overlap,
		// the baselines are aligned and everything fits in 160x240.
		int x = 0;
		int y = 0;
		int i;
		int lineI = 0;
		int lineTop = 0;
		int lineBottom = 0;
		int[256] xs;
		int[256] ys;

		int width = 0;
		BlazingPaddlesBoundingBox() box;
		for (i = 0; i < 256; i++) {
			if (!box.Calculate(content, contentLength, i, startAddress))
				break;
			int shapeWidth = box.Right - box.Left + 2; // +1 because box.right is inclusive, +1 for space
			if (x + shapeWidth > 160) {
				// new line
				y -= lineTop;
				while (lineI < i)
					ys[lineI++] = y;
				if (width < x)
					width = (x + 3) & ~3; // round up to 4 pixels
				x = 0;
				y += lineBottom + 2; // +1 because box.bottom is inclusive, +1 for space
				lineTop = box.Top;
				lineBottom = box.Bottom;
			}
			// place this shape at x,y
			xs[i] = x - box.Left;
			x += shapeWidth;
			if (lineTop > box.Top)
				lineTop = box.Top;
			if (lineBottom < box.Bottom)
				lineBottom = box.Bottom;
		}
		y -= lineTop;
		while (lineI < i)
			ys[lineI++] = y;
		if (width < x)
			width = (x + 3) & ~3; // round up to 4 pixels
		y += lineBottom + 1; // +1 because box.bottom is inclusive
		if (i == 0 || y > 240)
			return false;

		// draw shapes
		SetSize(width * 2, y, FAILResolution.Xe2x1);
		byte[320 * 240] frame = 0;
		for (i = 0; i < 256; i++) {
			if (!DrawBlazingPaddlesVector(content, contentLength, frame, (ys[i] * width + xs[i]) * 2, i, startAddress))
				break;
		}

		return ApplyAtari8Palette(frame);
	}

	bool DecodeChr(byte[] content, int contentLength)
	{
		return contentLength == 3072 && DecodeBlazingPaddlesVectors(content, contentLength, 0x7000);
	}

	bool DecodeShp(byte[] content, int contentLength)
	{
		switch (contentLength) {
		case 1024:
			return DecodeBlazingPaddlesVectors(content, contentLength, 0x7c00);
		case 4384:
			return DecodeGr7(content, 0x210, 3844);
		default:
			return false;
		}
	}

	static void DrawSpcChar(byte[] pixels, int x1, int y1, int ch)
	{
		// The original program can print garbage from ROM.
		// We don't have the ROM, so just skip these characters.
		// FIXME: check lowercase and semigraphic.
		if (ch < 0x20 || ch > 0x5f)
			return;

		byte[] font = BinaryResource("atari8.fnt");
		int fontOffset = (ch - 0x20) << 3;
		for (int y = 0; y < 8 && y1 + y < 192; y++) {
			for (int x = 0; x < 4 && x1 + x < 160; x++)
				pixels[(y1 + y) * 160 + x1 + x] = font[fontOffset + y] >> (6 - x * 2) & 3;
		}
	}

	static void DrawSpcLine(byte[] pixels, int x1, int y1, int x2, int y2, int color)
	{
		int dx = x2 - x1;
		int dy = y2 - y1;
		// FIXME: I do standard Bresenham's algorithm here,
		// but the original program does something strange involving division of dx/dy.

		// The original draws right or down, so I try it too.
		if (dx < 0)
			dx = -dx;
		if (dy < 0)
			dy = -dy;
		if (dx >= dy) {
			int e = dx;
			if (x2 < x1) {
				// swap points to draw right
				int ty = y1;
				x1 = x2;
				x2 += dx;
				y1 = y2;
				y2 = ty;
			}
			for ( ; x1 <= x2; x1++) {
				if (x1 < 160 && y1 < 192)
					pixels[160 * y1 + x1] = color;
				e -= dy * 2;
				if (e < 0) {
					e += dx * 2;
					y1 += y1 < y2 ? 1 : -1;
				}
			}
		}
		else {
			int e = dy;
			if (y2 < y1) {
				// swap points to draw down
				int tx = x1;
				x1 = x2;
				x2 = tx;
				y1 = y2;
				y2 += dy;
			}
			for ( ; y1 <= y2; y1++) {
				if (x1 < 160 && y1 < 192)
					pixels[160 * y1 + x1] = color;
				e -= dx * 2;
				if (e < 0) {
					e += dy * 2;
					x1 += x1 < x2 ? 1 : -1;
				}
			}
		}
	}

	static void PlotSpcPattern(byte[] pixels, int x, int y, int pattern)
	{
		pixels[y * 160 + x] = pattern >> ((~y & 1) * 8 + (~x & 3) * 2) & 3;
	}

	static void DrawSpcBrush(byte[] pixels, int x1, int y1, int brush, int pattern)
	{
		const byte[8 * 16] brushes = {
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x10, 0x38, 0x38, 0x7c, 0x7c, 0x7c, 0x7c, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x18, 0x18, 0x3c, 0x3c, 0x7e, 0x7e, 0x7e, 0x7e, 0x3c, 0x3c, 0x18, 0x18, 0x00, 0x00, 0x00,
			0x10, 0x38, 0x7c, 0x7c, 0x7c, 0xfe, 0xfe, 0xfe, 0xfe, 0x7c, 0x7c, 0x7c, 0x38, 0x10, 0x00, 0x00,
			0x00, 0x00, 0x10, 0x28, 0x28, 0x50, 0x3c, 0x78, 0x14, 0x28, 0x28, 0x10, 0x00, 0x00, 0x00, 0x00,
			0x10, 0x28, 0x54, 0x28, 0x54, 0xba, 0x7c, 0x7c, 0xba, 0x54, 0x28, 0x54, 0x28, 0x10, 0x00, 0x00
		};
		for (int y = 0; y < 16 && y1 + y < 192; y++) {
			int brushShape = brushes[brush * 16 + y];
			for (int x = 0; x < 8 && x1 + x < 160; x++) {
				if ((brushShape >> (7 - x) & 1) != 0)
					PlotSpcPattern(pixels, x, y, pattern);
			}
		}
	}

	static bool FillSpc(byte[] pixels, int x, int y, int pattern)
	{
		if (x >= 160 || y >= 192)
			return false;
		// This is NOT real flood fill.
		while (y >= 0 && pixels[y * 160 + x] == 0)
			y--;
		while (++y < 192 && pixels[y * 160 + x] == 0) {
			do
				x--;
			while (x >= 0 && pixels[y * 160 + x] == 0);
			int x1 = x;
			while (x < 159 && pixels[y * 160 + ++x] == 0)
				PlotSpcPattern(pixels, x, y, pattern);
#if true
			// the original program seems to do this
			// FIXME: probably different if borders reached
			x = x1 + ((x - x1 + 1) >> 1);
#else
			// simpler, but different from above I guess
			x -= (x - x1) >> 1;
#endif
		}
		return true;
	}

	bool DecodeAtari8Spc(byte[] content, int contentLength)
	{
		if (contentLength < 3
		 || contentLength != content[0] + (content[1] << 8) + 3
		 || content[contentLength - 1] != 0)
			return false;

		byte[160 * 192] pixels = 0;
		int[96] lineColors = 0;
		int textX = 0;
		int textY = 0;
		int lineX = 0;
		int lineY = 0;
		int brush = 0;
		int pattern = 0x2288;
		int lineColor = 3;
		int x;
		int y;
		for (int contentOffset = 2; content[contentOffset] != 0; ) {
			switch (content[contentOffset]) {
			case 0x10:
				if (contentOffset + 3 >= contentLength)
					return false;
				textX = content[contentOffset + 1];
				textY = content[contentOffset + 2];
				contentOffset += 3;
				break;
			case 0x20:
			case 0x21:
			case 0x22:
			case 0x23:
				if (contentOffset + 1 >= contentLength)
					return false;
				lineColor = content[contentOffset] & 3;
				contentOffset++;
				break;
			case 0x30:
			case 0x50:
				if (contentOffset + 2 >= contentLength)
					return false;
				DrawSpcChar(pixels, textX, textY, content[contentOffset + 1]);
				textX += 4;
				contentOffset += 2;
				break;
			case 0x40:
			case 0x41:
			case 0x42:
			case 0x43:
			case 0x44:
			case 0x45:
			case 0x46:
			case 0x47:
				if (contentOffset + 1 >= contentLength)
					return false;
				brush = content[contentOffset] & 7;
				contentOffset++;
				break;
			case 0x60:
				if (contentOffset + 2 >= contentLength)
					return false;
				pattern = content[contentOffset + 1];
				const int[] patterns = { // ushort?
					0x0000, 0x5555, 0xaaaa, 0xffff, 0x1144, 0x2288, 0x33cc, 0x6699,
					0x77dd, 0xbbee, 0x1551, 0x2aa2, 0x3ff3, 0x4004, 0x6aa6, 0x7ff7,
					0x8008, 0x9559, 0xbffb, 0xc00c, 0xd55d, 0xeaae, 0x5588, 0x22cc,
					0x3344, 0x4499, 0x44dd, 0x7799, 0x88ee, 0x8866, 0x99ee, 0xcc77,
					0xccbb, 0xddbb, 0x1bb1, 0x1559, 0x155d, 0x955d, 0x4008, 0x400c,
					0x800c, 0x6aac, 0x2aae, 0x6aa2, 0x7ffb, 0x3ffb, 0xbff7, 0x5584,
					0x22c4, 0x3348, 0x4491, 0x44d1, 0x7791, 0x88e2, 0x8862, 0x99e1,
					0xcc73, 0xccb3, 0xddb3, 0x558c, 0x22c8, 0x334c, 0x449d, 0x44d9,
					0x779d, 0x88e6, 0x886e, 0x99e5, 0xcc7b, 0xccb7, 0xddb7
				};
				if (pattern >= patterns.Length)
					return false;
				pattern = patterns[pattern];
				contentOffset += 2;
				break;
			case 0x70:
				if (contentOffset + 7 >= contentLength)
					return false;
				for (y = content[contentOffset + 1]; y <= content[contentOffset + 2]; y++) {
					if (y >= 96)
						return false;
					lineColors[y] = contentOffset + 3;
				}
				contentOffset += 7;
				break;
			case 0x80:
				if (contentOffset + 3 >= contentLength)
					return false;
				lineX = content[contentOffset + 1];
				lineY = content[contentOffset + 2];
				contentOffset += 3;
				break;
			case 0xa0:
				if (contentOffset + 3 >= contentLength)
					return false;
				x = content[contentOffset + 1];
				y = content[contentOffset + 2];
				DrawSpcLine(pixels, lineX, lineY, x, y, lineColor);
				lineX = x;
				lineY = y;
				contentOffset += 3;
				break;
			case 0xc0:
				if (contentOffset + 3 >= contentLength)
					return false;
				DrawSpcBrush(pixels, content[contentOffset + 1], content[contentOffset + 2], brush, pattern);
				contentOffset += 3;
				break;
			case 0xe0:
				if (contentOffset + 3 >= contentLength)
					return false;
				if (!FillSpc(pixels, content[contentOffset + 1], content[contentOffset + 2], pattern))
					return false;
				contentOffset += 3;
				break;
			default:
				return false;
			}
		}

		SetSize(320, 192, FAILResolution.Xe2x1);
		byte[320 * 192] frame;
		for (y = 0; y < 192; y++) {
			const byte[4] defaultColors = { 0x00, 0x15, 0x95, 0x36 };
			int colorsOffset = lineColors[y >> 1];
			byte[] colors = colorsOffset == 0 ? defaultColors : content;
			for (x = 0; x < 160; x++) {
				int offset = y * 320 + x * 2;
				frame[offset + 1] = frame[offset] = colors[colorsOffset + pixels[y * 160 + x]] & 0xfe;
			}
		}
		return ApplyAtari8Palette(frame);
	}

	bool DecodeArt(byte[] content, int contentLength)
	{
		return DecodeArtDirector(content, contentLength)
			|| DecodeAtari8Artist(content, contentLength)
			|| DecodeAsciiArtEditor(content, contentLength);
	}

	bool DecodeSpc(byte[] content, int contentLength)
	{
		return DecodeStSpc(content, contentLength)
			|| DecodeAtari8Spc(content, contentLength);
	}

	macro PACKED_EXT(s) ( s.Length >> 1 == 1 ? s[0] + (s[1] << 8) + (s.Length == 3 ? s[2] << 16 : 0) | 0x202020 : 0 )

	static int GetPackedExt(string filename)
	{
		int ext = 0;
		for (int i = filename.Length; --i > 0; ) {
			int c = filename[i];
			if (c <= ' ' || c > 'z')
				return 0;
			if (c == '.')
				return ext | 0x202020;
			ext = (ext << 8) + c;
		}
		return 0;
	}

	/// Checks whether the filename extension is supported by FAIL.
	/// `true` doesn't necessarily mean that the file contents is valid for FAIL.
	/// This function is meant to avoid reading files which are known to be
	/// not supported (another criterium is the maximum file size, `MaxContentLength`).
	public static bool IsOurFile(string filename)
	{
		switch (GetPackedExt(filename)) {
		case PACKED_EXT("256"):
		case PACKED_EXT("4MI"):
		case PACKED_EXT("4PL"):
		case PACKED_EXT("4PM"):
		case PACKED_EXT("A4R"):
		case PACKED_EXT("ACS"):
		case PACKED_EXT("AGP"):
		case PACKED_EXT("ALL"):
		case PACKED_EXT("AP2"):
		case PACKED_EXT("AP3"):
		case PACKED_EXT("APV"):
		case PACKED_EXT("DGP"):
		case PACKED_EXT("ESC"):
		case PACKED_EXT("ILC"):
		case PACKED_EXT("PZM"):
		case PACKED_EXT("APC"):
		case PACKED_EXT("APL"):
		case PACKED_EXT("APP"):
		case PACKED_EXT("ART"):
		case PACKED_EXT("BG9"):
		case PACKED_EXT("G09"):
		case PACKED_EXT("BKG"):
		case PACKED_EXT("BRU"):
		case PACKED_EXT("CA1"):
		case PACKED_EXT("CA2"):
		case PACKED_EXT("CA3"):
		case PACKED_EXT("CCI"):
		case PACKED_EXT("CHR"):
		case PACKED_EXT("CIN"):
		case PACKED_EXT("CPR"):
		case PACKED_EXT("CPT"):
		case PACKED_EXT("DC1"):
		case PACKED_EXT("DEL"):
		case PACKED_EXT("DG1"):
		case PACKED_EXT("DGC"):
		case PACKED_EXT("DGU"):
		case PACKED_EXT("DLM"):
		case PACKED_EXT("DOO"):
		case PACKED_EXT("DPH"):
		case PACKED_EXT("DRG"):
		case PACKED_EXT("FNT"):
		case PACKED_EXT("FTC"):
		case PACKED_EXT("FWA"):
		case PACKED_EXT("GHG"):
		case PACKED_EXT("GOD"):
		case PACKED_EXT("G10"):
		case PACKED_EXT("G11"):
		case PACKED_EXT("GFB"):
		case PACKED_EXT("GR7"):
		case PACKED_EXT("GR8"):
		case PACKED_EXT("GR9"):
		case PACKED_EXT("HIP"):
		case PACKED_EXT("HPM"):
		case PACKED_EXT("HR"):
		case PACKED_EXT("HR2"):
		case PACKED_EXT("IFF"):
		case PACKED_EXT("BL1"):
		case PACKED_EXT("BL2"):
		case PACKED_EXT("BL3"):
		case PACKED_EXT("IGE"):
		case PACKED_EXT("ING"):
		case PACKED_EXT("INP"):
		case PACKED_EXT("INT"):
		case PACKED_EXT("IPC"):
		case PACKED_EXT("IST"):
		case PACKED_EXT("JGP"):
		case PACKED_EXT("MAX"):
		case PACKED_EXT("MBG"):
		case PACKED_EXT("MCH"):
		case PACKED_EXT("MCP"):
		case PACKED_EXT("MCS"):
		case PACKED_EXT("MGP"):
		case PACKED_EXT("MIC"):
		case PACKED_EXT("MIS"):
		case PACKED_EXT("NEO"):
		case PACKED_EXT("NLQ"):
		case PACKED_EXT("PAC"):
		case PACKED_EXT("PC1"):
		case PACKED_EXT("PC2"):
		case PACKED_EXT("PC3"):
		case PACKED_EXT("PCS"):
		case PACKED_EXT("PGC"):
		case PACKED_EXT("PGF"):
		case PACKED_EXT("PI1"):
		case PACKED_EXT("PI2"):
		case PACKED_EXT("PI3"):
		case PACKED_EXT("PI4"):
		case PACKED_EXT("PI9"):
		case PACKED_EXT("PIC"):
		case PACKED_EXT("PLA"):
		case PACKED_EXT("PLM"):
		case PACKED_EXT("PMD"):
		case PACKED_EXT("RAW"):
		case PACKED_EXT("RGB"):
		case PACKED_EXT("RIP"):
		case PACKED_EXT("RM0"):
		case PACKED_EXT("RM1"):
		case PACKED_EXT("RM2"):
		case PACKED_EXT("RM3"):
		case PACKED_EXT("RM4"):
		case PACKED_EXT("SGE"):
		case PACKED_EXT("SHC"):
		case PACKED_EXT("SHP"):
		case PACKED_EXT("SPC"):
		case PACKED_EXT("SPS"):
		case PACKED_EXT("SPU"):
		case PACKED_EXT("SXS"):
		case PACKED_EXT("TIP"):
		case PACKED_EXT("TN1"):
		case PACKED_EXT("TN2"):
		case PACKED_EXT("TN3"):
		case PACKED_EXT("TNY"):
		case PACKED_EXT("TRP"):
		case PACKED_EXT("TRU"):
		case PACKED_EXT("WND"):
		case PACKED_EXT("XLP"):
			return true;
		default:
			return false;
		}
	}

	/// Decodes Atari picture file to an RGB bitmap.
	/// Returns `true` on success.
	public bool Decode(
		/// Name of the file to decode. Only the extension is processed, for format recognition.
		string filename,
		/// File contents.
		byte[] content,
		/// File length.
		int contentLength)
	{
		switch (GetPackedExt(filename)) {
		case PACKED_EXT("256"):
			return Decode256(content, contentLength);
		case PACKED_EXT("4MI"):
			return Decode4mi(content, contentLength);
		case PACKED_EXT("4PL"):
			return Decode4pl(content, contentLength);
		case PACKED_EXT("4PM"):
			return Decode4pm(content, contentLength);
		case PACKED_EXT("A4R"):
			return DecodeA4r(content, contentLength);
		case PACKED_EXT("ACS"):
			return DecodeAcs(content, contentLength);
		case PACKED_EXT("AGP"):
			return DecodeAgp(content, contentLength);
		case PACKED_EXT("ALL"):
			return DecodeAll(content, contentLength);
		case PACKED_EXT("AP2"):
			return Decode256(content, contentLength);
		case PACKED_EXT("AP3"):
		case PACKED_EXT("APV"):
		case PACKED_EXT("DGP"):
		case PACKED_EXT("ESC"):
		case PACKED_EXT("ILC"):
		case PACKED_EXT("PZM"):
			return DecodeAp3(content, contentLength);
		case PACKED_EXT("APC"):
			return DecodeApc(content, contentLength);
		case PACKED_EXT("APL"):
			return DecodeApl(content, contentLength);
		case PACKED_EXT("APP"):
			return DecodeApp(content, contentLength);
		case PACKED_EXT("ART"):
			return DecodeArt(content, contentLength);
		case PACKED_EXT("BG9"):
		case PACKED_EXT("G09"):
			return DecodeG09(content, contentLength);
		case PACKED_EXT("BKG"):
			return DecodeBkg(content, contentLength);
		case PACKED_EXT("BRU"):
			return DecodeBru(content, contentLength);
		case PACKED_EXT("CA1"):
		case PACKED_EXT("CA2"):
		case PACKED_EXT("CA3"):
			return DecodeCa(content, contentLength);
		case PACKED_EXT("CCI"):
			return DecodeCci(content, contentLength);
		case PACKED_EXT("CHR"):
			return DecodeChr(content, contentLength);
		case PACKED_EXT("CIN"):
			return DecodeCin(content, contentLength);
		case PACKED_EXT("CPR"):
			return DecodeCpr(content, contentLength);
		case PACKED_EXT("CPT"):
			return DecodeCpt(content, contentLength);
		case PACKED_EXT("DC1"):
		case PACKED_EXT("DGC"):
			return DecodeDgc(content, contentLength);
		case PACKED_EXT("DEL"):
			return DecodeDel(content, contentLength);
		case PACKED_EXT("DG1"):
		case PACKED_EXT("DGU"):
			return DecodeDgu(content, contentLength);
		case PACKED_EXT("DLM"):
			return DecodeDlm(content, contentLength);
		case PACKED_EXT("DOO"):
			return DecodeDoo(content, contentLength);
		case PACKED_EXT("DPH"):
			return DecodeDph(content, contentLength);
		case PACKED_EXT("DRG"):
			return DecodeDrg(content, contentLength);
		case PACKED_EXT("FNT"):
			return DecodeFnt(content, contentLength);
		case PACKED_EXT("FTC"):
			return DecodeFtc(content, contentLength);
		case PACKED_EXT("FWA"):
			return DecodeFwa(content, contentLength);
		case PACKED_EXT("GHG"):
			return DecodeGhg(content, contentLength);
		case PACKED_EXT("GOD"):
			return DecodeGod(content, contentLength);
		case PACKED_EXT("G10"):
			return DecodeG10(content, contentLength);
		case PACKED_EXT("G11"):
			return DecodeG11(content, contentLength);
		case PACKED_EXT("GFB"):
			return DecodeGfb(content, contentLength);
		case PACKED_EXT("GR7"):
			return DecodeGr7(content, 0, contentLength);
		case PACKED_EXT("GR8"):
			return DecodeGr8(content, contentLength);
		case PACKED_EXT("GR9"):
			return DecodeGr9(content, contentLength);
		case PACKED_EXT("HIP"):
			return DecodeHip(content, contentLength);
		case PACKED_EXT("HPM"):
			return DecodeHpm(content, contentLength);
		case PACKED_EXT("HR"):
			return DecodeHr(content, contentLength);
		case PACKED_EXT("HR2"):
			return DecodeHr2(content, contentLength);
		case PACKED_EXT("IFF"):
		case PACKED_EXT("BL1"):
		case PACKED_EXT("BL2"):
		case PACKED_EXT("BL3"):
			return DecodeIff(content, contentLength);
		case PACKED_EXT("IGE"):
			return DecodeIge(content, contentLength);
		case PACKED_EXT("ING"):
		case PACKED_EXT("INP"):
			return DecodeInp(content, contentLength);
		case PACKED_EXT("INT"):
			return DecodeInt(content, contentLength);
		case PACKED_EXT("IPC"):
			return DecodeIpc(content, contentLength);
		case PACKED_EXT("IST"):
			return DecodeIst(content, contentLength);
		case PACKED_EXT("JGP"):
			return DecodeJgp(content, contentLength);
		case PACKED_EXT("MAX"):
			return DecodeMax(content, contentLength);
		case PACKED_EXT("MBG"):
			return DecodeMbg(content, contentLength);
		case PACKED_EXT("MCH"):
			return DecodeMch(content, contentLength);
		case PACKED_EXT("MCP"):
			return DecodeMcp(content, contentLength);
		case PACKED_EXT("MCS"):
			return DecodeMcs(content, contentLength);
		case PACKED_EXT("MGP"):
			return DecodeMgp(content, contentLength);
		case PACKED_EXT("MIC"):
			return DecodeMic(content, contentLength);
		case PACKED_EXT("MIS"):
			return DecodeMis(content, contentLength);
		case PACKED_EXT("NEO"):
			return DecodeNeo(content, contentLength);
		case PACKED_EXT("NLQ"):
			return DecodeNlq(content, contentLength);
		case PACKED_EXT("PAC"):
			return DecodePac(content, contentLength);
		case PACKED_EXT("PC1"):
		case PACKED_EXT("PC2"):
		case PACKED_EXT("PC3"):
			return DecodePc(content, contentLength);
		case PACKED_EXT("PCS"):
			return DecodePcs(content, contentLength);
		case PACKED_EXT("PGC"):
			return DecodePgc(content, contentLength);
		case PACKED_EXT("PGF"):
			return DecodePgf(content, contentLength);
		case PACKED_EXT("PI1"):
		case PACKED_EXT("PI2"):
		case PACKED_EXT("PI3"):
			return DecodePi(content, contentLength);
		case PACKED_EXT("PI4"):
		case PACKED_EXT("PI9"):
			return DecodePi4(content, contentLength);
		case PACKED_EXT("PIC"):
			return DecodePic(content, contentLength);
		case PACKED_EXT("PLA"):
			return DecodePla(content, contentLength);
		case PACKED_EXT("PLM"):
			return DecodeApc(content, contentLength);
		case PACKED_EXT("PMD"):
			return DecodePmd(content, contentLength);
		case PACKED_EXT("RAW"):
			return DecodeRaw(content, contentLength);
		case PACKED_EXT("RGB"):
			return DecodeRgb(content, contentLength);
		case PACKED_EXT("RIP"):
			return DecodeRip(content, contentLength);
		case PACKED_EXT("RM0"):
			return DecodeRm(content, contentLength, 0, FAILResolution.Xe2x2);
		case PACKED_EXT("RM1"):
			return DecodeRm(content, contentLength, 1, FAILResolution.Xe4x1);
		case PACKED_EXT("RM2"):
			return DecodeRm(content, contentLength, 2, FAILResolution.Xe4x1);
		case PACKED_EXT("RM3"):
			return DecodeRm(content, contentLength, 3, FAILResolution.Xe4x1);
		case PACKED_EXT("RM4"):
			return DecodeRm(content, contentLength, 4, FAILResolution.Xe2x1);
		case PACKED_EXT("SGE"):
			return DecodeSge(content, contentLength);
		case PACKED_EXT("SHC"):
			return DecodeShc(content, contentLength);
		case PACKED_EXT("SHP"):
			return DecodeShp(content, contentLength);
		case PACKED_EXT("SPC"):
			return DecodeSpc(content, contentLength);
		case PACKED_EXT("SPS"):
			return DecodeSps(content, contentLength);
		case PACKED_EXT("SPU"):
			return DecodeSpu(content, contentLength);
		case PACKED_EXT("SXS"):
			return DecodeSxs(content, contentLength);
		case PACKED_EXT("TIP"):
			return DecodeTip(content, contentLength);
		case PACKED_EXT("TN1"):
		case PACKED_EXT("TN2"):
		case PACKED_EXT("TN3"):
		case PACKED_EXT("TNY"):
			return DecodeTny(content, contentLength);
		case PACKED_EXT("TRP"):
			return DecodeTrp(content, contentLength);
		case PACKED_EXT("TRU"):
			return DecodeTru(content, contentLength);
		case PACKED_EXT("WND"):
			return DecodeWnd(content, contentLength);
		case PACKED_EXT("XLP"):
			return DecodeXlp(content, contentLength);
		default:
			return false;
		}
	}

	// Number of unique colors in `pixels`.
	int Colors;
	const int UnknownColors = -1;
	// Special case when palette-indexed conversion fails.
	const int MoreThan256Colors = 0;

	// Unique colors.
	// Values are in ascending order for the sake of binary search.
	int[256] Palette;

	/// Find the `rgb` value in `palette`.
	/// Searches `paletteEnd` entries.
	static int FindColor(int[] palette, int paletteEnd, int rgb)
	{
		int paletteBegin = 0;
		while (paletteBegin < paletteEnd) {
			int index = (paletteBegin + paletteEnd) >> 1;
			int paletteRgb = palette[index];
			if (rgb == paletteRgb)
				return index;
			if (rgb < paletteRgb)
				paletteEnd = index;
			else
				paletteBegin = index + 1;
		}
		return paletteBegin;
	}

	/// Calculates palette for the decoded picture.
	/// On entry, `palette` contains `paletteOffset` colors.
	void CalculatePalette(int[] palette, int paletteOffset, int paletteLength)
	{
		int pixelsCount = Width * Height;
		for (int pixelsOffset = 0; pixelsOffset < pixelsCount; pixelsOffset++) {
			int rgb = Pixels[pixelsOffset];
			int index = FindColor(palette, paletteOffset, rgb);
			if (index >= paletteOffset || palette[index] != rgb) {
				if (paletteOffset == paletteLength) {
					Colors = MoreThan256Colors;
					return;
				}
				for (int j = paletteOffset; --j >= index; )
					palette[j + 1] = palette[j];
				palette[index] = rgb;
				paletteOffset++;
			}
		}
		Colors = paletteOffset;
	}

	/// Returns number of unique colors in the decoded picture.
	public int GetColors()
	{
		if (Colors == UnknownColors) {
			Palette.Clear();
			CalculatePalette(Palette, 0, 256);
		}
		if (Colors == MoreThan256Colors) {
			int[] palette = new int[Width * Height];
			// Copy already found colors
			// - will be faster than starting from scratch.
			for (int j = 0; j < 256; j++)
				palette[j] = Palette[j];
			CalculatePalette(palette, 256, -1);
			delete palette;
		}
		return Colors;
	}

	/// Converts the decoded picture to palette-indexed.
	/// Returns palette of 256 0xRRGGBB entries.
	/// Call `GetColors()` for the actual number of colors.
	/// Returns `null` if conversion fails,
	/// because there are more than 256 colors.
	public int[] ToPalette(
		/// Out: palette-indexed picture.
		/// It must be caller-allocated of length `GetWidth() * GetHeight()`.
		byte[] indexes)
	{
		if (Colors == UnknownColors) {
			Palette.Clear();
			CalculatePalette(Palette, 0, 256);
		}
		if (Colors == MoreThan256Colors || Colors > 256)
			return null;
		int pixelsCount = Width * Height;
		for (int i = 0; i < pixelsCount; i++)
			indexes[i] = FindColor(Palette, Colors, Pixels[i]);
		return Palette;
	}
}
